{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\n\n\nThe code snippets in this sidebar are designed to work in your apps directly.\n The requests are performed using the following resources.\n\n\nGraphQL API: \ndocument.write(window.apiUrl)\n\n\nEmail address: \ndocument.write(window.currentUserEmail)\n\n\n\n\nWelcome! Scaphold is a backend-as-a-service platform that bundles all the tools you need to quickly build production-grade applications.\nIn a matter of minutes, you can create your own \ncustomizable GraphQL API\n backed by our highly available cloud infrastructure hosted on AWS.\n\n\nAs soon as you \ncreate an app on Scaphold\n, you'll instantly\u00a0have a persistent\u00a0data\nstore, data modeling tools, advanced\u00a0access\u00a0control management, and monitoring dashboards all at your fingertips.\u00a0This will\nget you most of the way to launching your app, but why stop there?\n\n\nScaphold also provides many powerful features that will \naccelerate your team's app development like never before\n:\n\n\nAlready an expert?\n \nGet started now!\n\n\nHave any questions?\n \nJoin our Slack!\n\n\nWhy GraphQL?\n\n\n\n\nDescribe your data\n\n\n\n\n1\n2\n3\n4\n5\ntype Mission {\n  id: ID!\n  codename: String\n  astronauts: [User]\n}\n\n\n\n\n\n\n\n\nAsk for what you want\n\n\n\n\n1\n2\n3\n4\n5\n{\n  getMission(id: \nabc123\n) {\n    codename\n  }\n}\n\n\n\n\n\n\n\n\nGet predictable results\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n  \ngetMission\n:\n \n{\n\n    \ncodename\n:\n \nGraphQL Takes Over The World!\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nAll responses from your API will be formatted as JSON.\n\n\n\n\n\nGraphQL\n was developed by Facebook over the years to power and scale many of their mobile and web applications. A\ngreat deal of care was taken\u00a0to ensure that GraphQL works from any client platform which means you can use Scaphold to build an application\non\u00a0virtually\u00a0any platform. This means you can target your Scaphold API from iOS, Android, Web, and IOT applications\u00a0using any framework\n\nwithout ever\u00a0having to download an SDK\n! GraphQL presents a better way to build applications.\u00a0It's that simple. You focus on what makes\nyour app awesome\u00a0and let us worry about the rest!\n\n\nPlus GraphQL is a massive improvement on REST. Here is why!\n\n\n\n\nA declarative type system helps create clean, structured, and safe APIs.\n\n\nWrite your queries once and run them anywhere! The intuitive GraphQL language is not only more powerful but also 100% cross-platform. No SDKs necessary!\n\n\nIntrospection lets you build documentation into the API itself. Your API easier to learn and eliminates the need to maintain external docs.\n\n\nA GraphQL API has one endpoint. No more tricky RESTful urls.\n\n\nClient driven. GraphQL empowers those who understand their requirements best. You!\n\n\nIt integrates seamlessly with the hottest frontend frameworks like React and Angular 2.0 using Relay and Apollo Client\n\n\nAnd many many more!", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "The code snippets in this sidebar are designed to work in your apps directly.  The requests are performed using the following resources.  GraphQL API:  document.write(window.apiUrl)  Email address:  document.write(window.currentUserEmail)   Welcome! Scaphold is a backend-as-a-service platform that bundles all the tools you need to quickly build production-grade applications.\nIn a matter of minutes, you can create your own  customizable GraphQL API  backed by our highly available cloud infrastructure hosted on AWS.  As soon as you  create an app on Scaphold , you'll instantly\u00a0have a persistent\u00a0data\nstore, data modeling tools, advanced\u00a0access\u00a0control management, and monitoring dashboards all at your fingertips.\u00a0This will\nget you most of the way to launching your app, but why stop there?  Scaphold also provides many powerful features that will  accelerate your team's app development like never before :  Already an expert?   Get started now!  Have any questions?   Join our Slack!", 
            "title": "Introduction"
        }, 
        {
            "location": "/#why-graphql", 
            "text": "Describe your data   1\n2\n3\n4\n5 type Mission {\n  id: ID!\n  codename: String\n  astronauts: [User]\n}    Ask for what you want   1\n2\n3\n4\n5 {\n  getMission(id:  abc123 ) {\n    codename\n  }\n}    Get predictable results   1\n2\n3\n4\n5 { \n   getMission :   { \n     codename :   GraphQL Takes Over The World! \n   }  }     \nAll responses from your API will be formatted as JSON.   GraphQL  was developed by Facebook over the years to power and scale many of their mobile and web applications. A\ngreat deal of care was taken\u00a0to ensure that GraphQL works from any client platform which means you can use Scaphold to build an application\non\u00a0virtually\u00a0any platform. This means you can target your Scaphold API from iOS, Android, Web, and IOT applications\u00a0using any framework without ever\u00a0having to download an SDK ! GraphQL presents a better way to build applications.\u00a0It's that simple. You focus on what makes\nyour app awesome\u00a0and let us worry about the rest!  Plus GraphQL is a massive improvement on REST. Here is why!   A declarative type system helps create clean, structured, and safe APIs.  Write your queries once and run them anywhere! The intuitive GraphQL language is not only more powerful but also 100% cross-platform. No SDKs necessary!  Introspection lets you build documentation into the API itself. Your API easier to learn and eliminates the need to maintain external docs.  A GraphQL API has one endpoint. No more tricky RESTful urls.  Client driven. GraphQL empowers those who understand their requirements best. You!  It integrates seamlessly with the hottest frontend frameworks like React and Angular 2.0 using Relay and Apollo Client  And many many more!", 
            "title": "Why GraphQL?"
        }, 
        {
            "location": "/getting-started/jumpstart-video/", 
            "text": "Jumpstart Video Tutorial\n\n\nWatch the video tutorial!", 
            "title": "Jumpstart Video"
        }, 
        {
            "location": "/getting-started/jumpstart-video/#jumpstart-video-tutorial", 
            "text": "Watch the video tutorial!", 
            "title": "Jumpstart Video Tutorial"
        }, 
        {
            "location": "/getting-started/starter-kits/", 
            "text": "Quick Start\n\n\nGetting started building a new app can be a daunting task. The development world moves at lightning\nspeed but don't worry! We work hard to make it as simple as possible to start by maintaining\na bunch of starter kits and our community builds a lot more.\n\n\nPick the stack and platform that works for you. We have already built the scaffolding to get you started in seconds.\n\n\nReact\n\n\nReact is the hot topic in web development. It is a component based framework specifically designed\nto create powerful \n performant user interfaces. It is supported by Facebook and is backed\nby a huge community. It also fits perfectly with GraphQL :)\n\n\n\n\nBuild Slack with React \n Apollo\n\n\nReact \n Apollo Client\n\n\nReact \n Relay\n\n\nAngular 2\n\n\nAngular is a web and mobile development framework that came out of Google. It promotes bi-directional\ndata binding and is great for building real-time apps. Angular2 is brand new and ready for you\nto start building on.\n\n\n\n\nReact, Angular 2 \n Apollo Client\n\n\nVue\n\n\nVue is a progressive Javascript framework built that was designed to have a light footprint and to\nbe incrementally adoptable.\n\n\n\n\nReact, Vue2, \n Apollo Tutorial\n\n\nVue2, Apollo \n Scaphold Tutorial\n\n\nReact Native\n\n\n\n\nReact Native is the new way to build mobile apps. You write your code once with\nJavascript and your app is automatically converted to native code and deployed so you can\ncreate rich experiences on any platform.\n\n\nReact Native VR\n\n\niOS\n\n\n\n\nThe GraphQL type system fits in perfectly with your swift projects. Its magic watching xcode\nautocomplete and type check your GraphQL queries. Apollo iOS is a great place to start.\n\n\nStart with Apollo for iOS\n\n\nAndroid\n\n\n\n\nGraphQL tooling on Android is young but is well on its way to being the best way to build Android apps.\n\n\nBuild for Android with Apollo\n\n\nOther\n\n\nCerebral\n\n\n\n\nCerebral is a next-gen state controller with a built in debugger. It's an awesome tool.\n\n\nCerebral TodoMVC\n\n\nCommunity Projects\n\n\nThe Scaphold community builds new projects \n starter kits all the time! Check them out on our\ncommunity page! If you have a project you would like to feature let us know on our \nSlack Community Channel\n\n\nCommunity Projects", 
            "title": "Starter Kits"
        }, 
        {
            "location": "/getting-started/starter-kits/#quick-start", 
            "text": "Getting started building a new app can be a daunting task. The development world moves at lightning\nspeed but don't worry! We work hard to make it as simple as possible to start by maintaining\na bunch of starter kits and our community builds a lot more.  Pick the stack and platform that works for you. We have already built the scaffolding to get you started in seconds.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/getting-started/starter-kits/#react", 
            "text": "React is the hot topic in web development. It is a component based framework specifically designed\nto create powerful   performant user interfaces. It is supported by Facebook and is backed\nby a huge community. It also fits perfectly with GraphQL :)   Build Slack with React   Apollo  React   Apollo Client  React   Relay", 
            "title": "React"
        }, 
        {
            "location": "/getting-started/starter-kits/#angular-2", 
            "text": "Angular is a web and mobile development framework that came out of Google. It promotes bi-directional\ndata binding and is great for building real-time apps. Angular2 is brand new and ready for you\nto start building on.   React, Angular 2   Apollo Client", 
            "title": "Angular 2"
        }, 
        {
            "location": "/getting-started/starter-kits/#vue", 
            "text": "Vue is a progressive Javascript framework built that was designed to have a light footprint and to\nbe incrementally adoptable.   React, Vue2,   Apollo Tutorial  Vue2, Apollo   Scaphold Tutorial", 
            "title": "Vue"
        }, 
        {
            "location": "/getting-started/starter-kits/#react-native", 
            "text": "React Native is the new way to build mobile apps. You write your code once with\nJavascript and your app is automatically converted to native code and deployed so you can\ncreate rich experiences on any platform.  React Native VR", 
            "title": "React Native"
        }, 
        {
            "location": "/getting-started/starter-kits/#ios", 
            "text": "The GraphQL type system fits in perfectly with your swift projects. Its magic watching xcode\nautocomplete and type check your GraphQL queries. Apollo iOS is a great place to start.  Start with Apollo for iOS", 
            "title": "iOS"
        }, 
        {
            "location": "/getting-started/starter-kits/#android", 
            "text": "GraphQL tooling on Android is young but is well on its way to being the best way to build Android apps.  Build for Android with Apollo", 
            "title": "Android"
        }, 
        {
            "location": "/getting-started/starter-kits/#other", 
            "text": "", 
            "title": "Other"
        }, 
        {
            "location": "/getting-started/starter-kits/#cerebral", 
            "text": "Cerebral is a next-gen state controller with a built in debugger. It's an awesome tool.  Cerebral TodoMVC", 
            "title": "Cerebral"
        }, 
        {
            "location": "/getting-started/starter-kits/#community-projects", 
            "text": "The Scaphold community builds new projects   starter kits all the time! Check them out on our\ncommunity page! If you have a project you would like to feature let us know on our  Slack Community Channel  Community Projects", 
            "title": "Community Projects"
        }, 
        {
            "location": "/coredata/", 
            "text": "Core Data\n\n\nScaphold's core data platform allows you to easily define complex data models that are instantly deployed\nto a production GraphQL API backed by a highly available SQL cluster. Core Data provides a great set of\ntools for powering core application logic.\n\n\nEvery type in your schema that implements the \nNode\n interface is backed by core data. That means every\ntype that implements \nNode\n maps to a single table and can be related to any other core data types via\n\nConnection\n fields. Each core data type \nX\n also receives a \ncreateX\n, \nupdateX\n, and \ndeleteX\n mutation as well\nas various ways to read the data with \ngetX\n, \nallX\n, and through connections.\n\n\nScaphold allows you to write GraphQL queries that are compiled down to SQL which means you get powerful\nfiltering abilities with \nWhereArgs\n as well as compound \norderBy\n expressions. We even expose the ability\nfor you to index certain fields in your data so that you can optimize the queries that are important to your\napplication.", 
            "title": "Introduction"
        }, 
        {
            "location": "/coredata/#core-data", 
            "text": "Scaphold's core data platform allows you to easily define complex data models that are instantly deployed\nto a production GraphQL API backed by a highly available SQL cluster. Core Data provides a great set of\ntools for powering core application logic.  Every type in your schema that implements the  Node  interface is backed by core data. That means every\ntype that implements  Node  maps to a single table and can be related to any other core data types via Connection  fields. Each core data type  X  also receives a  createX ,  updateX , and  deleteX  mutation as well\nas various ways to read the data with  getX ,  allX , and through connections.  Scaphold allows you to write GraphQL queries that are compiled down to SQL which means you get powerful\nfiltering abilities with  WhereArgs  as well as compound  orderBy  expressions. We even expose the ability\nfor you to index certain fields in your data so that you can optimize the queries that are important to your\napplication.", 
            "title": "Core Data"
        }, 
        {
            "location": "/coredata/schema/", 
            "text": "The Schema\n\n\n\n\nExample schema\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\ntype\n \nScapholdSchema\n \n{\n\n  \nid\n: \nID\n!\n\n  \nname\n: \nString\n!\n\n  \ndescription\n: \nString\n\n  \ntypes\n:\n \n[\nScapholdType\n]\n\n\n}\n\n\n\ntype\n \nScapholdType\n \n{\n\n  \nid\n: \nID\n!\n\n  \nname\n: \nString\n!\n\n  \ndescription\n: \nString\n\n  \nkind\n:\n \nOBJECT\n \n|\n \nENUM\n \n|\n \nINTERFACE\n\n  \nvalues\n:\n \n[\nString\n]\n                        \n#\n \nif\n \nENUM\n\n  \nfields\n:\n \n[\nScapholdField\n]\n                 \n#\n \nif\n \nINTERFACE\n \nor\n \nOBJECT\n\n  \ninterfaces\n:\n \n[\nString\n]\n                    \n#\n \nif\n \nOBJECT\n\n  \npermissions\n:\n \n[\nScapholdPermission\n]\n\n\n}\n\n\n\ntype\n \nScapholdField\n \n{\n\n  \nname\n: \nString\n!\n\n  \ndescription\n: \nString\n\n  \ntype\n: \nString\n!\n\n  \nofType\n: \nString\n\n  \nnonNull\n: \nBoolean\n\n  \nunique\n: \nBoolean\n\n  \nreverseName\n: \nString\n\n\n}\n\n\n\ninterface\n \nNode\n \n{\n\n  \nid\n: \nID\n!\n\n\n}\n\n\n\n\n\n\n\nEvery application you build on Scaphold will have a schema. A schema consists of a set of types and a set of\nconnections between those types. This connected web of types creates the 'graph' that will come to define your API.\n\n\nOne of GraphQL's biggest benefits is that it provides a mechanism to express types at the API level. Types have\nexisted in general purpose programming languages and other query languages like SQL for years so it's about\ntime we brought it to APIs.\n\n\nThere are \ntwo main classes of types\n that you need to be aware of on Scaphold.\n\n\n\n\n\n\nTypes that implement the \nNode\n interface.\nThese are first-class entities in your Scaphold API. We will generate queries\u00a0and mutations for them, you may create\nconnections between them, and you may use them with event-based integrations.\n\n\n\n\n\n\nTypes that \ndon't\n implement the \nNode\n interface.\nThese are auxiliary structures in your GraphQL API and these objects\u00a0are\u00a0stored\u00a0inline within other \nNode\n types.\nScaphold will not create queries and mutations for non-node types nor\u00a0can\u00a0you use them\u00a0to fire event-based integrations.\nYou can, however, still relate them to other objects via the \nList\n\u00a0type or as an inline object.\n\n\n\n\n\n\nScaphold's \nSchema Designer\n allows you to define complex schemas in a fraction of the\ntime while also offering you a convenient place to setup access control rules (\npermissions\n) for your\ndata. As you\u00a0define the structure of your schema we'll generate the backend that will host your custom GraphQL API. By\ndefault we generate a \nget\n, \ncreate\n, \nupdate\n, and \ndelete\n operation for each type in your schema. And to give you that\nextra boost, we also create mutations to handle user authentication, schema migration, and integration management.\n\n\nScalars\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nID\n\n\nThe ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an \nID\n signifies that it is not intended to be human\u2010readable.\n\n\n\n\n\n\nString\n\n\nA UTF\u20108 character sequence\n\n\n\n\n\n\nText\n\n\nCharacter sequence with unlimited length (cannot be indexed or have a default value)\n\n\n\n\n\n\nInt\n\n\nA signed 32-bit integer\n\n\n\n\n\n\nFloat\n\n\nA signed double-precision floating-point value\n\n\n\n\n\n\nBoolean\n\n\ntrue\n or \nfalse\n\n\n\n\n\n\nDateTime\n\n\nValid timestamp that can be converted to standard ISO 8601 date time format.\n\n\n\n\n\n\n\n\nTypes\n\n\n\n\n\n  Scaphold provides 3 objects types to start off with: \nUser\n, \nRole\n, and \nFile\n.\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ntype Computer {\n  id: ID!\n  name: String!\n  brand: String\n  memory: Float\n  diskSpace: Float\n  numCores: Int\n  price: Float\n  isNew: Boolean\n}\n\n\n\n\n\n\n\n\n\n  Scaphold provides 3 interfaces to start off with: \nNode\n, \nTimestamped\n, and \nBlob\n.\n\n\n\n\n\n1\n2\n3\n4\n5\ninterface\n \nAnimal\n \n{\n\n  \nname\n: \nString\n\n  \nheight\n: \nFloat\n\n  \nweight\n: \nFloat\n\n\n}\n\n\n\n\n\n\n\n\n\n\n  Scaphold provides 2 enums to start off with: \nCredentialType\n and \nAccessLevel\n.\n\n\n\n\n\n1\n2\n3\n4\n5\n6\nenum\n \nHouseTypeEnum\n {\n  \ncondominium\n\n  \napartment\n\n  \nhouse\n\n  \nduplex\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nThese are the bread and butter of the GraphQL type system and schema. They are the model definitions of your data, telling the GraphQL server what types exist, the fields that belong to a type, and the complex relations between your data. GraphQL queries are validated against this type system.\u00a0Scaphold allows you to easily define your types without having to write any server-side code, so you can leverage the benefits of GraphQL from your client side, without having to write this all yourself.\n\n\n\n\n\n\nInterface\n\n\nAn interface is an abstract type that must be implemented by a type. The fields belonging to an interface must also exist on the type that implements it.\n\n\n\n\n\n\nEnum\n\n\nEnums are special scalar types that restrict values to a finite set of data.\n\n\n\n\n\n\n\n\nAdding a Type\n\n\nIn the Schema Designer tab once you've created your app, click the dropdown on the top right to add a type.\n\n\n\n\nType Modifiers\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nList\n\n\nA List indicates that this field will return an array of a particular type. This is denoted in GraphQL as \n[ ... ]\n surrounding the name of a type or scalar.\n\n\n\n\n\n\nNon-Null\n\n\nThe Non-Null type modifier can also be used when defining arguments for a field, which will cause the GraphQL server to return a validation error if a null value is passed as that argument, whether in the GraphQL string or in the variables. This is denoted in GraphQL as a \n!\n following the name of a type or scalar.\n\n\n\n\n\n\n\n\nFields\n\n\nIn GraphQL, like many other type systems, each type will have a set of fields associated with it. Fields are used to describe a particular type, and types in Scaphold will come by default\nwith an \nid\n, \ncreatedAt\n, and \nmodifiedAt\n fields as part of implementing the \nNode\n and \nTimestamped\n interfaces. These can be removed when creating a new type; however, a type must have at least one field.\n\n\nAdding a Field\n\n\nIn the Schema Designer tab once you've created your type, click the dropdown on the top right of a Type panel.", 
            "title": "The Schema"
        }, 
        {
            "location": "/coredata/schema/#the-schema", 
            "text": "Example schema    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 type   ScapholdSchema   { \n   id :  ID ! \n   name :  String ! \n   description :  String \n   types :   [ ScapholdType ]  }  type   ScapholdType   { \n   id :  ID ! \n   name :  String ! \n   description :  String \n   kind :   OBJECT   |   ENUM   |   INTERFACE \n   values :   [ String ]                          #   if   ENUM \n   fields :   [ ScapholdField ]                   #   if   INTERFACE   or   OBJECT \n   interfaces :   [ String ]                      #   if   OBJECT \n   permissions :   [ ScapholdPermission ]  }  type   ScapholdField   { \n   name :  String ! \n   description :  String \n   type :  String ! \n   ofType :  String \n   nonNull :  Boolean \n   unique :  Boolean \n   reverseName :  String  }  interface   Node   { \n   id :  ID !  }    Every application you build on Scaphold will have a schema. A schema consists of a set of types and a set of\nconnections between those types. This connected web of types creates the 'graph' that will come to define your API.  One of GraphQL's biggest benefits is that it provides a mechanism to express types at the API level. Types have\nexisted in general purpose programming languages and other query languages like SQL for years so it's about\ntime we brought it to APIs.  There are  two main classes of types  that you need to be aware of on Scaphold.    Types that implement the  Node  interface.\nThese are first-class entities in your Scaphold API. We will generate queries\u00a0and mutations for them, you may create\nconnections between them, and you may use them with event-based integrations.    Types that  don't  implement the  Node  interface.\nThese are auxiliary structures in your GraphQL API and these objects\u00a0are\u00a0stored\u00a0inline within other  Node  types.\nScaphold will not create queries and mutations for non-node types nor\u00a0can\u00a0you use them\u00a0to fire event-based integrations.\nYou can, however, still relate them to other objects via the  List \u00a0type or as an inline object.    Scaphold's  Schema Designer  allows you to define complex schemas in a fraction of the\ntime while also offering you a convenient place to setup access control rules ( permissions ) for your\ndata. As you\u00a0define the structure of your schema we'll generate the backend that will host your custom GraphQL API. By\ndefault we generate a  get ,  create ,  update , and  delete  operation for each type in your schema. And to give you that\nextra boost, we also create mutations to handle user authentication, schema migration, and integration management.", 
            "title": "The Schema"
        }, 
        {
            "location": "/coredata/schema/#scalars", 
            "text": "Name  Description      ID  The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an  ID  signifies that it is not intended to be human\u2010readable.    String  A UTF\u20108 character sequence    Text  Character sequence with unlimited length (cannot be indexed or have a default value)    Int  A signed 32-bit integer    Float  A signed double-precision floating-point value    Boolean  true  or  false    DateTime  Valid timestamp that can be converted to standard ISO 8601 date time format.", 
            "title": "Scalars"
        }, 
        {
            "location": "/coredata/schema/#types", 
            "text": "Scaphold provides 3 objects types to start off with:  User ,  Role , and  File .    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 type Computer {\n  id: ID!\n  name: String!\n  brand: String\n  memory: Float\n  diskSpace: Float\n  numCores: Int\n  price: Float\n  isNew: Boolean\n}    \n  Scaphold provides 3 interfaces to start off with:  Node ,  Timestamped , and  Blob .   1\n2\n3\n4\n5 interface   Animal   { \n   name :  String \n   height :  Float \n   weight :  Float  }     \n  Scaphold provides 2 enums to start off with:  CredentialType  and  AccessLevel .   1\n2\n3\n4\n5\n6 enum   HouseTypeEnum  {\n   condominium \n   apartment \n   house \n   duplex \n}      Name  Description      Object  These are the bread and butter of the GraphQL type system and schema. They are the model definitions of your data, telling the GraphQL server what types exist, the fields that belong to a type, and the complex relations between your data. GraphQL queries are validated against this type system.\u00a0Scaphold allows you to easily define your types without having to write any server-side code, so you can leverage the benefits of GraphQL from your client side, without having to write this all yourself.    Interface  An interface is an abstract type that must be implemented by a type. The fields belonging to an interface must also exist on the type that implements it.    Enum  Enums are special scalar types that restrict values to a finite set of data.     Adding a Type  In the Schema Designer tab once you've created your app, click the dropdown on the top right to add a type.", 
            "title": "Types"
        }, 
        {
            "location": "/coredata/schema/#type-modifiers", 
            "text": "Name  Description      List  A List indicates that this field will return an array of a particular type. This is denoted in GraphQL as  [ ... ]  surrounding the name of a type or scalar.    Non-Null  The Non-Null type modifier can also be used when defining arguments for a field, which will cause the GraphQL server to return a validation error if a null value is passed as that argument, whether in the GraphQL string or in the variables. This is denoted in GraphQL as a  !  following the name of a type or scalar.", 
            "title": "Type Modifiers"
        }, 
        {
            "location": "/coredata/schema/#fields", 
            "text": "In GraphQL, like many other type systems, each type will have a set of fields associated with it. Fields are used to describe a particular type, and types in Scaphold will come by default\nwith an  id ,  createdAt , and  modifiedAt  fields as part of implementing the  Node  and  Timestamped  interfaces. These can be removed when creating a new type; however, a type must have at least one field.  Adding a Field  In the Schema Designer tab once you've created your type, click the dropdown on the top right of a Type panel.", 
            "title": "Fields"
        }, 
        {
            "location": "/coredata/queries/", 
            "text": "Queries\n\n\n\n\nExample \ngetX\n query\n\n\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{\nquery\n: \nquery GetUser ($input: ID!) { getUser (id: $input) { id, username, createdAt, modifiedAt, lastLogin } }\n,\n\n\n    \nvariables\n: {\ninput\n: \nVXNlcjoxMQ==\n}}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nimport\n \nrequest\n \nfrom\n \nrequest\n;\n\n\n\nconst\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`query GetUser ($input: ID!) {\n\n\n    getUser (id: $input) {\n\n\n      id\n\n\n      username\n\n\n      createdAt\n\n\n      modifiedAt\n\n\n      lastLogin\n\n\n    }\n\n\n  }`\n,\n\n  \nvariables\n:\n \n{\n\n    \ninput\n:\n \nVXNlcjoxMQ==\n\n  \n}\n\n\n};\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n=\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n\n  \ndata\n:\n \n{\n\n    \ngetUser\n:\n \n{\n\n      \nid\n:\n \nVXNlcjoxMQ==\n,\n\n      \nusername\n:\n \nElon Musk\n,\n\n      \ncreatedAt\n:\n \n2016-12-08T12:33:56.000Z\n,\n\n      \nmodifiedAt\n:\n \n2016-12-08T12:33:56.000Z\n,\n\n      \nlastLogin\n:\n \n2016-12-08T12:33:56.000Z\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nYou can see every custom query available in the doc explorer in\u00a0the GraphiQL tab.\nSee how GraphQL results directly mirror the query? It's awesome!\n\n\n\n\n\nQueries allow you to read data from your GraphQL API!\n\n\nEach core data type \nX\n gets its own queries \ngetX\n and \nviewer.allXs\n. Since core data types can be involved in\nconnections, you can also read related objects through any connection fields in your schema. All core data connections\ntake the \nXWhereArgs\n and \nXOrderByArgs\n inputs that allow you to do complex filtering and compound ordering.\n\n\nViewer\n\n\n\n\nExample \nviewer\n query\n\n\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nquery GetAllUsers($first: Int, $after: String, $orderBy: [UserOrderByArgs]) { viewer { allUsers(first: $first, after: $after, orderBy: $orderBy) { edges { cursor node { username createdAt } } } } }\n,\n\n\n    \nvariables\n: { \nfirst\n: 3, \nafter\n: \nYzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MzguMDAwWiIsImlkIjo2fQ==\n, \norderBy\n: { \nfield\n: \ncreatedAt\n, \ndirection\n: \nDESC\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nimport\n \nrequest\n \nfrom\n \nrequest\n;\n\n\n\nconst\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`query GetAllUsers($first: Int, $after: String, $orderBy: [UserOrderByArgs]) {\n\n\n    viewer {\n\n\n        allUsers(first: $first, after: $after, orderBy: $orderBy) {\n\n\n          edges {\n\n\n            cursor\n\n\n            node {\n\n\n              username\n\n\n              createdAt\n\n\n            }\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \nfirst\n:\n \n3\n,\n\n    \nafter\n:\n \nYzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MzguMDAwWiIsImlkIjo2fQ==\n,\n\n    \norderBy\n:\n \n{\n\n        \nfield\n:\n \ncreatedAt\n,\n\n        \ndirection\n:\n \nDESC\n\n    \n}\n\n  \n}\n\n\n};\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n=\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n{\n  \ndata\n: {\n    \nviewer\n: {\n      \nallUsers\n: {\n        \nedges\n: [\n          {\n            \ncursor\n: \nYzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MjMuMDAwWiIsImlkIjo1fQ==\n,\n            \nnode\n: {\n              \nusername\n: \nSteve Jobs\n,\n              \ncreatedAt\n: \n2016-12-08T15:02:23.000Z\n\n            }\n          },\n          {\n            \ncursor\n: \nYzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MTcuMDAwWiIsImlkIjo0fQ==\n,\n            \nnode\n: {\n              \nusername\n: \nBill Gates\n,\n              \ncreatedAt\n: \n2016-12-08T15:02:17.000Z\n\n            }\n          },\n          {\n            \ncursor\n: \nYzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MDYuMDAwWiIsImlkIjozfQ==\n,\n            \nnode\n: {\n              \nusername\n: \nLarry Page\n,\n              \ncreatedAt\n: \n2016-12-08T15:02:06.000Z\n\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe \nRELATION\n permission restricts access to queries through \nviewer.user\n.  This is how we are able\nto efficiently enable you to provide full user field paths in your \nRELATION\n permission.\n\n\n\nThe viewer is a convention from \nRelay\n that allows you to both easily paginate\nthrough all objects in your app as well as get a view for the currently logged in user.\u00a0We generate a viewer field\n\nallX\n for each type \nX\n in your schema.\u00a0Queries that go through the viewer are subject to your set permissions so\nusers can only access the data you allow.\n\n\nThe viewer also contains a \nuser\n field that will always return information on the currently logged in user.\n\n\nIt's powerful since it uses connections and cursors to enable pagination out of the box! Cursors are essentially\na mechanism that uniquely identifies a single piece of data in a paginated list. With this unique ID, you can\napply it to the \nafter\n or \nbefore\n parameters in your query to retrieve data past or prior to a particular piece\nof data, respectively.\n\n\nFiltering (WhereArgs)\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nquery ($where: UserWhereArgs) { viewer { allUsers(where: $where) { edges { node { id username } } } } }\n,\n\n\n    \nvariables\n: { \nwhere\n: { \nusername\n: { \nlike\n: \n%elon%\n } } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nvar\n \nrequest\n \n=\n \nrequire\n(\nrequest\n);\n\n\n\nvar\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    query ($where: UserWhereArgs) {\n\n\n      viewer {\n\n\n        allUsers(where: $where) {\n\n\n          edges {\n\n\n            node {\n\n\n              id\n\n\n              username\n\n\n            }\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \nwhere\n:\n \n{\n\n      \nusername\n:\n \n{\n\n        \nlike\n:\n \n%elon%\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \nfunction\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n{\n\n  \ndata\n:\n \n{\n\n    \nviewer\n:\n \n{\n\n      \nallUsers\n:\n \n{\n\n        \nedges\n:\n \n[\n\n          \n{\n\n            \nnode\n:\n \n{\n\n              \nid\n:\n \nVXNlcjo3\n,\n\n              \nusername\n:\n \nelon@tesla.com\n\n            \n}\n\n          \n},\n\n          \n{\n\n            \nnode\n:\n \n{\n\n              \nid\n:\n \nVXNlcjox\n,\n\n              \nusername\n:\n \nElon Musk\n\n            \n}\n\n          \n}\n\n        \n]\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nScaphold allows you to write GraphQL queries that are compiled down to SQL which means you get powerful filtering abilities with \nWhereArgs\n as well as compound \norderBy\n expressions. We even expose the ability for you to\nindex certain fields in your data so that you can optimize the queries that are important to your application.\n\n\nFor each Node-implemented type, we provide a way to query using SQL-like syntax through GraphQL! For each field on a particular type, you are able to query by SQL operators and you will be returned a list of instances\nthat satisfy those filter arguments. The allowable operators include the following:\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neq\n\n\nEqual to. This takes a higher precedence than the other operators.\n\n\n\n\n\n\ngt\n\n\nGreater than.\n\n\n\n\n\n\ngte\n\n\nGreater than or equal to.\n\n\n\n\n\n\nlt\n\n\nLess than.\n\n\n\n\n\n\nlte\n\n\nLess than or equal to.\n\n\n\n\n\n\nne\n\n\nNot equal to.\n\n\n\n\n\n\nbetween\n\n\nA two element tuple describing a range of values.\n\n\n\n\n\n\nnotBetween\n\n\nA two element tuple describing an excluded range of values.\n\n\n\n\n\n\nin\n\n\nA list of values to include.\n\n\n\n\n\n\nnotIn\n\n\nA list of values to exclude.\n\n\n\n\n\n\nlike\n\n\nA pattern to match for likeness.\n\n\n\n\n\n\nnotLike\n\n\nA pattern to match for likeness and exclude.\n\n\n\n\n\n\nisNull\n\n\nFilters for null values. This takes precedence after \neq\n but before all other fields.\n\n\n\n\n\n\n\n\nQuerying with AND \n OR\n\n\n\n\nGet all posts with a title containing the word 'graphql' AND that were created in 2017.\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# select * from Post where (title LIKE \n%graphql%\n) AND (createdAt \n \n01/01/2017 00:00:00 AM\n)\nquery  {\n  viewer {\n    allPosts(where:{\n      AND: [\n        {\n          title: { like: \n%graphql%\n }\n        },\n        {\n          createdAt: { gt: \n2017\n }\n        }\n      ]\n    }) {\n      edges {\n        cursor\n        node {\n          id\n          title\n          createdAt\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\nGet all roles with name 'admin' OR 'executive'\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# select * from Role where (name = \nadmin\n) OR (name = \nexecutive\n)\nquery  {\n  viewer {\n    allRoles(where:{\n      OR: [\n        {\n          name: { eq: \nadmin\n }\n        },\n        {\n          name: { eq: \nexecutive\n }\n        }\n      ]\n    }) {\n      edges {\n        cursor\n        node {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\nGet all movies created after 2017 OR movies that were created before 2017 AND had a rating \n 90\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# select * from Movie\n#   where (createdAt \n \n01/01/2017 00:00:00 AM\n)\n#   OR (createdAt \n \n01/01/2017 00:00:00 AM\n AND rating \n 90)\nquery  {\n  viewer {\n    allMovies(where:{\n      OR: [\n        {\n          createdAt: { gt: \n2017\n }\n        },\n        {\n          AND: [\n            {\n              createdAt: { lt: \n2017\n },\n              rating: { gt: 90 }\n            }\n          ]\n        }\n      ]\n    }) {\n      edges {\n        cursor\n        node {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nYou may use the AND \n OR operators in each WhereArgs input object to combine WhereArgs in\ninteresting ways. Take a look at the queries to the right to learn see how they work.\n\n\nAggregations\n\n\n\n\nA single \nArticle\n type\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\ntype Article {\n  id: ID!\n  title: String\n  content: Text    # Like a String but larger\n  recommends: Int\n  reads: Int\n}\n\n\n\n\n\n\n\n\nHow many times were all the articles reads in 2016?\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nquery LikeData {\n  viewer {\n    allArticles(where:{ createdAt: { gt: \n2016\n, lt: \n2017\n }}) {\n      aggregations {\n        sum {\n          reads\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nImagine you were building a blogging platform like Medium. It would be an obvious value add\nto be able to slice \n dice your data to better understand how your posts are performing. Let's\nsay our blogging platform has an \nArticle\n model like this:\n\n\nIt would be really nice to be able to ask questions like, how many times were all the our articles\nreads in 2016?\nWith aggregations and GraphQL this is easy!\n\n\n\n\nDigging deeper. What is the conversion from reads to recommends?\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nquery PostData {\n  viewer {\n    allArticles(where:{ createdAt: { gt: \n2016\n, lt: \n2017\n }}) {\n      aggregations {\n        count\n        sum {\n          recommends\n          reads\n        }\n        avg {\n          recommends\n          reads\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThis is great, but what if we also wanted to know the average read count and the total number\nof articles listed  on the site.\nWhile we're at it, lets also grab the total \n average number of recommendations for our articles.\n\n\nThis query is both intuitive to understand and performant. Behind the scenes all of these\nmetrics are calculated in a single query keeping your api snappy and you user's happy! Aggregations\nopen the door for all kinds of insights into our data. For example, we could use the query above\nto answer a question like what is the average conversion rate from a read to a recommendation.\n\n\nThis is just touching the surface of our aggregation capabilities. Let's keep digging.\n\n\nAdvanced Aggregations Using Connections\n\n\n\n\nA simple connection between \nUser\n and \nArticle\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\ntype User {\n  id: ID!\n  username: String\n  password: Secret\n  articles: ArticleConnection\n}\n\ntype Article {\n  id: ID!\n  title: String\n  content: Text\n  recommends: Int\n  reads: Int\n  author: User\n}\n\n\n\n\n\n\n\n\nHow many reads did I get in 2016? Conversion?\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nquery PostData {\n  viewer {\n    user {\n      articles(where:{ createdAt: { gt: \n2016\n, lt: \n2017\n }}) {\n        aggregations {\n          count\n          sum {\n            recommends\n            reads\n          }\n          avg {\n            recommends\n            reads\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nIn the previous section, we showed how you can crunch the numbers for all the records\nin your dataset. This is useful for administrative tasks, but often our applications\nare more user-centric. The good news is that aggregations work for every connection in\nyour API.\n\n\nLet's compound on the previous example and ask the question, \"How many reads did MY posts\nget on average in 2016?\". To make this work, we need to introduce a \nUser\n type.\n\n\nOnce we setup the connection between our \nUser\n and \nArticle\n types, we can issue a query like this\n\n\nThis query will only perform the aggregation on the articles that are attached to the logged in\nuser via the \narticles\n connection. You can continue to manipulate these queries with more and more\nadvanced filters and aggregations. You'll find that every connection in your API operates the same\nway allowing you do run multiple aggregations at different levels in your GraphQL API!", 
            "title": "Queries"
        }, 
        {
            "location": "/coredata/queries/#queries", 
            "text": "Example  getX  query   1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  { query :  query GetUser ($input: ID!) { getUser (id: $input) { id, username, createdAt, modifiedAt, lastLogin } } ,       variables : { input :  VXNlcjoxMQ== }}     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 import   request   from   request ;  const   data   =   { \n   query :   `query GetUser ($input: ID!) {      getUser (id: $input) {        id        username        createdAt        modifiedAt        lastLogin      }    }` , \n   variables :   { \n     input :   VXNlcjoxMQ== \n   }  };  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   ( error ,   response ,   body )   =   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 { \n   data :   { \n     getUser :   { \n       id :   VXNlcjoxMQ== , \n       username :   Elon Musk , \n       createdAt :   2016-12-08T12:33:56.000Z , \n       modifiedAt :   2016-12-08T12:33:56.000Z , \n       lastLogin :   2016-12-08T12:33:56.000Z \n     } \n   }  }     \nYou can see every custom query available in the doc explorer in\u00a0the GraphiQL tab.\nSee how GraphQL results directly mirror the query? It's awesome!   Queries allow you to read data from your GraphQL API!  Each core data type  X  gets its own queries  getX  and  viewer.allXs . Since core data types can be involved in\nconnections, you can also read related objects through any connection fields in your schema. All core data connections\ntake the  XWhereArgs  and  XOrderByArgs  inputs that allow you to do complex filtering and compound ordering.", 
            "title": "Queries"
        }, 
        {
            "location": "/coredata/queries/#viewer", 
            "text": "Example  viewer  query   1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  query GetAllUsers($first: Int, $after: String, $orderBy: [UserOrderByArgs]) { viewer { allUsers(first: $first, after: $after, orderBy: $orderBy) { edges { cursor node { username createdAt } } } } } ,       variables : {  first : 3,  after :  Yzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MzguMDAwWiIsImlkIjo2fQ== ,  orderBy : {  field :  createdAt ,  direction :  DESC  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 import   request   from   request ;  const   data   =   { \n   query :   `query GetAllUsers($first: Int, $after: String, $orderBy: [UserOrderByArgs]) {      viewer {          allUsers(first: $first, after: $after, orderBy: $orderBy) {            edges {              cursor              node {                username                createdAt              }            }          }        }      }    ` , \n   variables :   { \n     first :   3 , \n     after :   Yzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MzguMDAwWiIsImlkIjo2fQ== , \n     orderBy :   { \n         field :   createdAt , \n         direction :   DESC \n     } \n   }  };  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   ( error ,   response ,   body )   =   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 {\n   data : {\n     viewer : {\n       allUsers : {\n         edges : [\n          {\n             cursor :  Yzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MjMuMDAwWiIsImlkIjo1fQ== ,\n             node : {\n               username :  Steve Jobs ,\n               createdAt :  2016-12-08T15:02:23.000Z \n            }\n          },\n          {\n             cursor :  Yzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MTcuMDAwWiIsImlkIjo0fQ== ,\n             node : {\n               username :  Bill Gates ,\n               createdAt :  2016-12-08T15:02:17.000Z \n            }\n          },\n          {\n             cursor :  Yzp7ImNyZWF0ZWRBdCI6IjIwMTYtMTItMDhUMTU6MDI6MDYuMDAwWiIsImlkIjozfQ== ,\n             node : {\n               username :  Larry Page ,\n               createdAt :  2016-12-08T15:02:06.000Z \n            }\n          }\n        ]\n      }\n    }\n  }\n}      The  RELATION  permission restricts access to queries through  viewer.user .  This is how we are able\nto efficiently enable you to provide full user field paths in your  RELATION  permission.  The viewer is a convention from  Relay  that allows you to both easily paginate\nthrough all objects in your app as well as get a view for the currently logged in user.\u00a0We generate a viewer field allX  for each type  X  in your schema.\u00a0Queries that go through the viewer are subject to your set permissions so\nusers can only access the data you allow.  The viewer also contains a  user  field that will always return information on the currently logged in user.  It's powerful since it uses connections and cursors to enable pagination out of the box! Cursors are essentially\na mechanism that uniquely identifies a single piece of data in a paginated list. With this unique ID, you can\napply it to the  after  or  before  parameters in your query to retrieve data past or prior to a particular piece\nof data, respectively.", 
            "title": "Viewer"
        }, 
        {
            "location": "/coredata/queries/#filtering-whereargs", 
            "text": "1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  query ($where: UserWhereArgs) { viewer { allUsers(where: $where) { edges { node { id username } } } } } ,       variables : {  where : {  username : {  like :  %elon%  } } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42 var   request   =   require ( request );  var   data   =   { \n   query :   `      query ($where: UserWhereArgs) {        viewer {          allUsers(where: $where) {            edges {              node {                id                username              }            }          }        }      }    ` , \n   variables :   { \n     where :   { \n       username :   { \n         like :   %elon% \n       } \n     } \n   }  }  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   function ( error ,   response ,   body )   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 { \n   data :   { \n     viewer :   { \n       allUsers :   { \n         edges :   [ \n           { \n             node :   { \n               id :   VXNlcjo3 , \n               username :   elon@tesla.com \n             } \n           }, \n           { \n             node :   { \n               id :   VXNlcjox , \n               username :   Elon Musk \n             } \n           } \n         ] \n       } \n     } \n   }  }    Scaphold allows you to write GraphQL queries that are compiled down to SQL which means you get powerful filtering abilities with  WhereArgs  as well as compound  orderBy  expressions. We even expose the ability for you to\nindex certain fields in your data so that you can optimize the queries that are important to your application.  For each Node-implemented type, we provide a way to query using SQL-like syntax through GraphQL! For each field on a particular type, you are able to query by SQL operators and you will be returned a list of instances\nthat satisfy those filter arguments. The allowable operators include the following:     Name  Description      eq  Equal to. This takes a higher precedence than the other operators.    gt  Greater than.    gte  Greater than or equal to.    lt  Less than.    lte  Less than or equal to.    ne  Not equal to.    between  A two element tuple describing a range of values.    notBetween  A two element tuple describing an excluded range of values.    in  A list of values to include.    notIn  A list of values to exclude.    like  A pattern to match for likeness.    notLike  A pattern to match for likeness and exclude.    isNull  Filters for null values. This takes precedence after  eq  but before all other fields.", 
            "title": "Filtering (WhereArgs)"
        }, 
        {
            "location": "/coredata/queries/#querying-with-and-or", 
            "text": "Get all posts with a title containing the word 'graphql' AND that were created in 2017.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 # select * from Post where (title LIKE  %graphql% ) AND (createdAt    01/01/2017 00:00:00 AM )\nquery  {\n  viewer {\n    allPosts(where:{\n      AND: [\n        {\n          title: { like:  %graphql%  }\n        },\n        {\n          createdAt: { gt:  2017  }\n        }\n      ]\n    }) {\n      edges {\n        cursor\n        node {\n          id\n          title\n          createdAt\n        }\n      }\n    }\n  }\n}    Get all roles with name 'admin' OR 'executive'    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 # select * from Role where (name =  admin ) OR (name =  executive )\nquery  {\n  viewer {\n    allRoles(where:{\n      OR: [\n        {\n          name: { eq:  admin  }\n        },\n        {\n          name: { eq:  executive  }\n        }\n      ]\n    }) {\n      edges {\n        cursor\n        node {\n          id\n          name\n        }\n      }\n    }\n  }\n}    Get all movies created after 2017 OR movies that were created before 2017 AND had a rating   90    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 # select * from Movie\n#   where (createdAt    01/01/2017 00:00:00 AM )\n#   OR (createdAt    01/01/2017 00:00:00 AM  AND rating   90)\nquery  {\n  viewer {\n    allMovies(where:{\n      OR: [\n        {\n          createdAt: { gt:  2017  }\n        },\n        {\n          AND: [\n            {\n              createdAt: { lt:  2017  },\n              rating: { gt: 90 }\n            }\n          ]\n        }\n      ]\n    }) {\n      edges {\n        cursor\n        node {\n          id\n          name\n        }\n      }\n    }\n  }\n}   You may use the AND   OR operators in each WhereArgs input object to combine WhereArgs in\ninteresting ways. Take a look at the queries to the right to learn see how they work.", 
            "title": "Querying with AND &amp; OR"
        }, 
        {
            "location": "/coredata/queries/#aggregations", 
            "text": "A single  Article  type   1\n2\n3\n4\n5\n6\n7 type Article {\n  id: ID!\n  title: String\n  content: Text    # Like a String but larger\n  recommends: Int\n  reads: Int\n}    How many times were all the articles reads in 2016?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 query LikeData {\n  viewer {\n    allArticles(where:{ createdAt: { gt:  2016 , lt:  2017  }}) {\n      aggregations {\n        sum {\n          reads\n        }\n      }\n    }\n  }\n}   Imagine you were building a blogging platform like Medium. It would be an obvious value add\nto be able to slice   dice your data to better understand how your posts are performing. Let's\nsay our blogging platform has an  Article  model like this:  It would be really nice to be able to ask questions like, how many times were all the our articles\nreads in 2016?\nWith aggregations and GraphQL this is easy!   Digging deeper. What is the conversion from reads to recommends?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 query PostData {\n  viewer {\n    allArticles(where:{ createdAt: { gt:  2016 , lt:  2017  }}) {\n      aggregations {\n        count\n        sum {\n          recommends\n          reads\n        }\n        avg {\n          recommends\n          reads\n        }\n      }\n    }\n  }\n}   This is great, but what if we also wanted to know the average read count and the total number\nof articles listed  on the site.\nWhile we're at it, lets also grab the total   average number of recommendations for our articles.  This query is both intuitive to understand and performant. Behind the scenes all of these\nmetrics are calculated in a single query keeping your api snappy and you user's happy! Aggregations\nopen the door for all kinds of insights into our data. For example, we could use the query above\nto answer a question like what is the average conversion rate from a read to a recommendation.  This is just touching the surface of our aggregation capabilities. Let's keep digging.", 
            "title": "Aggregations"
        }, 
        {
            "location": "/coredata/queries/#advanced-aggregations-using-connections", 
            "text": "A simple connection between  User  and  Article    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 type User {\n  id: ID!\n  username: String\n  password: Secret\n  articles: ArticleConnection\n}\n\ntype Article {\n  id: ID!\n  title: String\n  content: Text\n  recommends: Int\n  reads: Int\n  author: User\n}    How many reads did I get in 2016? Conversion?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 query PostData {\n  viewer {\n    user {\n      articles(where:{ createdAt: { gt:  2016 , lt:  2017  }}) {\n        aggregations {\n          count\n          sum {\n            recommends\n            reads\n          }\n          avg {\n            recommends\n            reads\n          }\n        }\n      }\n    }\n  }\n}   In the previous section, we showed how you can crunch the numbers for all the records\nin your dataset. This is useful for administrative tasks, but often our applications\nare more user-centric. The good news is that aggregations work for every connection in\nyour API.  Let's compound on the previous example and ask the question, \"How many reads did MY posts\nget on average in 2016?\". To make this work, we need to introduce a  User  type.  Once we setup the connection between our  User  and  Article  types, we can issue a query like this  This query will only perform the aggregation on the articles that are attached to the logged in\nuser via the  articles  connection. You can continue to manipulate these queries with more and more\nadvanced filters and aggregations. You'll find that every connection in your API operates the same\nway allowing you do run multiple aggregations at different levels in your GraphQL API!", 
            "title": "Advanced Aggregations Using Connections"
        }, 
        {
            "location": "/coredata/mutations/", 
            "text": "Mutations\n\n\nA GraphQL mutation is a write followed by a fetch in one operation.\n\n\nMutations are your means of modifying data in your API. Each core data type \nX\n, gets a \ncreateX\n, \nupdateX\n, and \ndeleteX\n\nmutation. Input arguments are automatically created to fit your schema and can be inspected from GraphiQL's Doc Explorer.\n\n\nHere's an example of each type of mutation:\n\n\nCreate\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nmutation CreateUser($user: CreateUserInput!) { createUser(input: $user) { changedUser { id username } } }\n,\n\n\n    \nvariables\n: { \nuser\n: { \nusername\n: \nelon@tesla.com\n, \npassword\n: \nSuperSecretPassword\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nimport\n \nrequest\n \nfrom\n \nrequest\n;\n\n\n\nconst\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    mutation CreateUser($user: CreateUserInput!) {\n\n\n      createUser(input: $user) {\n\n\n        changedUser {\n\n\n          id\n\n\n          username\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \nuser\n:\n \n{\n\n      \nusername\n:\n \nelon@tesla.com\n,\n\n      \npassword\n:\n \nSuperSecretPassword\n\n    \n}\n\n  \n}\n\n\n};\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n=\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n{\n\n  \ndata\n:\n \n{\n\n    \ncreateUser\n:\n \n{\n\n      \nchangedUser\n:\n \n{\n\n        \nid\n:\n \nVXNlcjo3\n,\n\n        \nusername\n:\n \nelon@tesla.com\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n  The request above may throw an error since there's a \nuniqueness constrainst set automatically\n on the User model's \nusername\n field.\n\n\n\n\n\nIn this request, JSON-formatted variables are used to send an object as part of the payload for the mutation request.\nThe dollar sign ($) specifies a GraphQL variable, and the variable definition can be found in the variables section\nof the request. Another thing to note here is that when introducing variables in the mutation string,\n\n$user: CreateUserInput!\n means that that variable is of type \nCreateUserInput!\n and is required (!).\n\n\nNested Create\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nmutation CreateNested($input: CreateTripInput!) {\n  createTrip(input: $input) {\n    changedTrip {\n      destination\n      group {\n        name\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\nNotice the nested \ngroup\n field in the input variable\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n{\n  \ntrip\n: {\n    \ndestination\n: \nSan Francisco\n,\n    \ngroup\n: {\n      \nname\n: \nSeattlites\n\n    }\n  }\n}\n\n\n\n\n\n\nAs an added convenience you are able to create objects and associate them in the same request.\n\n\nFor example, lets say we were making an app to help friends manage group trips. For our app we would\nhave a schema where \nUser\ns have \nGroup\ns and \nGroup\ns have a \nTrip\n. If we were starting a new\n\nGroup\n then we would likely want to start a new \nTrip\n at the same time. then you\ncould create both a \nGroup\n and a \nTrip\n as well as associate them in a connection with this query.\n\n\nNote: typeId takes precedence over type\n\n\nIf you provide an object id as well as a nested input argument, the object id will take precedence\nand the nested object will not be created. In the example to the right, there would also be a field\n\ngroupId\n of type ID in the \nCreateTripInput\n type. If you were to provide both a \ngroup\n and \ngroupId\n,\nthe \ngroupId\n would take precendence and the new trip would be associated with the existing group\nwith that id instead of making a new group.\n\n\nUpdate\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nmutation UpdateUser($user: UpdateUserInput!) { updateUser(input: $user) { changedUser { id username biography } } }\n,\n\n\n    \nvariables\n: { \nuser\n: { \nid\n: \nVXNlcjox\n, \nbiography\n: \nSpends his days saving the world with renewable energy.\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\nimport\n \nrequest\n \nfrom\n \nrequest\n;\n\n\n\nconst\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    mutation UpdateUser($user: UpdateUserInput!) {\n\n\n      updateUser(input: $user) {\n\n\n        changedUser {\n\n\n          id\n\n\n          username\n\n\n          biography\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \nuser\n:\n \n{\n\n      \nid\n:\n \nVXNlcjox\n,\n\n      \nbiography\n:\n \nSpends his days saving the world with renewable energy.\n\n    \n}\n\n  \n}\n\n\n};\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n=\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n\n  \ndata\n:\n \n{\n\n    \nupdateUser\n:\n \n{\n\n      \nchangedUser\n:\n \n{\n\n        \nid\n:\n \nVXNlcjox\n,\n\n        \nusername\n:\n \nElon Musk\n,\n\n        \nbiography\n:\n \nSpends his days saving the world with renewable energy.\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nYou can also make a mutation to update data. The update operation performs a non-destructive update\nto an object in your dataset. I.E. Update only updates the fields that you include as part of the\ninput. The object's \nid\n is required in every update mutation so that we can uniquely identify the\nobject you would like to update. If you don't know it, you should perform a query\u00a0operation to fetch\nthe data first, or save it in your application's state after creating the object.\n\n\nDelete\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nmutation DeleteUser($user: DeleteUserInput!) { deleteUser(input: $user) { changedUser { id username } } }\n,\n\n\n    \nvariables\n: { \nuser\n: { \nid\n: \nVXNlcjo4\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nimport\n \nrequest\n \nfrom\n \nrequest\n;\n\n\n\nconst\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    mutation DeleteUser($user: DeleteUserInput!) {\n\n\n      deleteUser(input: $user) {\n\n\n        changedUser {\n\n\n          id\n\n\n          username\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \nuser\n:\n \n{\n\n      \nid\n:\n \nVXNlcjo4\n\n    \n}\n\n  \n}\n\n\n};\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n=\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n{\n\n  \ndata\n:\n \n{\n\n    \ndeleteUser\n:\n \n{\n\n      \nchangedUser\n:\n \n{\n\n        \nid\n:\n \nVXNlcjo4\n,\n\n        \nusername\n:\n \nelon@spacex.com\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n  The request above may return \nnull\n. This is an indication that you tried to delete a piece of data\n  that doesn't exist.\n\n\n\n\n\nUse delete operations to delete data from your API. Delete requires the unique global identifier \nid\n\nof the piece of data that you wish to delete. Upon deleting data, you will receive the data back one\nlast time in case you need it again, and to serve as confirmation that that particular object was removed.", 
            "title": "Mutations"
        }, 
        {
            "location": "/coredata/mutations/#mutations", 
            "text": "A GraphQL mutation is a write followed by a fetch in one operation.  Mutations are your means of modifying data in your API. Each core data type  X , gets a  createX ,  updateX , and  deleteX \nmutation. Input arguments are automatically created to fit your schema and can be inspected from GraphiQL's Doc Explorer.  Here's an example of each type of mutation:", 
            "title": "Mutations"
        }, 
        {
            "location": "/coredata/mutations/#create", 
            "text": "1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  mutation CreateUser($user: CreateUserInput!) { createUser(input: $user) { changedUser { id username } } } ,       variables : {  user : {  username :  elon@tesla.com ,  password :  SuperSecretPassword  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37 import   request   from   request ;  const   data   =   { \n   query :   `      mutation CreateUser($user: CreateUserInput!) {        createUser(input: $user) {          changedUser {            id            username          }        }      }    ` , \n   variables :   { \n     user :   { \n       username :   elon@tesla.com , \n       password :   SuperSecretPassword \n     } \n   }  };  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   ( error ,   response ,   body )   =   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 { \n   data :   { \n     createUser :   { \n       changedUser :   { \n         id :   VXNlcjo3 , \n         username :   elon@tesla.com \n       } \n     } \n   }  }     \n  The request above may throw an error since there's a  uniqueness constrainst set automatically  on the User model's  username  field.   In this request, JSON-formatted variables are used to send an object as part of the payload for the mutation request.\nThe dollar sign ($) specifies a GraphQL variable, and the variable definition can be found in the variables section\nof the request. Another thing to note here is that when introducing variables in the mutation string, $user: CreateUserInput!  means that that variable is of type  CreateUserInput!  and is required (!).", 
            "title": "Create"
        }, 
        {
            "location": "/coredata/mutations/#nested-create", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 mutation CreateNested($input: CreateTripInput!) {\n  createTrip(input: $input) {\n    changedTrip {\n      destination\n      group {\n        name\n      }\n    }\n  }\n}    Notice the nested  group  field in the input variable   1\n2\n3\n4\n5\n6\n7\n8 {\n   trip : {\n     destination :  San Francisco ,\n     group : {\n       name :  Seattlites \n    }\n  }\n}   As an added convenience you are able to create objects and associate them in the same request.  For example, lets say we were making an app to help friends manage group trips. For our app we would\nhave a schema where  User s have  Group s and  Group s have a  Trip . If we were starting a new Group  then we would likely want to start a new  Trip  at the same time. then you\ncould create both a  Group  and a  Trip  as well as associate them in a connection with this query.  Note: typeId takes precedence over type  If you provide an object id as well as a nested input argument, the object id will take precedence\nand the nested object will not be created. In the example to the right, there would also be a field groupId  of type ID in the  CreateTripInput  type. If you were to provide both a  group  and  groupId ,\nthe  groupId  would take precendence and the new trip would be associated with the existing group\nwith that id instead of making a new group.", 
            "title": "Nested Create"
        }, 
        {
            "location": "/coredata/mutations/#update", 
            "text": "1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  mutation UpdateUser($user: UpdateUserInput!) { updateUser(input: $user) { changedUser { id username biography } } } ,       variables : {  user : {  id :  VXNlcjox ,  biography :  Spends his days saving the world with renewable energy.  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38 import   request   from   request ;  const   data   =   { \n   query :   `      mutation UpdateUser($user: UpdateUserInput!) {        updateUser(input: $user) {          changedUser {            id            username            biography          }        }      }    ` , \n   variables :   { \n     user :   { \n       id :   VXNlcjox , \n       biography :   Spends his days saving the world with renewable energy. \n     } \n   }  };  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   ( error ,   response ,   body )   =   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 { \n   data :   { \n     updateUser :   { \n       changedUser :   { \n         id :   VXNlcjox , \n         username :   Elon Musk , \n         biography :   Spends his days saving the world with renewable energy. \n       } \n     } \n   }  }    You can also make a mutation to update data. The update operation performs a non-destructive update\nto an object in your dataset. I.E. Update only updates the fields that you include as part of the\ninput. The object's  id  is required in every update mutation so that we can uniquely identify the\nobject you would like to update. If you don't know it, you should perform a query\u00a0operation to fetch\nthe data first, or save it in your application's state after creating the object.", 
            "title": "Update"
        }, 
        {
            "location": "/coredata/mutations/#delete", 
            "text": "1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  mutation DeleteUser($user: DeleteUserInput!) { deleteUser(input: $user) { changedUser { id username } } } ,       variables : {  user : {  id :  VXNlcjo4  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 import   request   from   request ;  const   data   =   { \n   query :   `      mutation DeleteUser($user: DeleteUserInput!) {        deleteUser(input: $user) {          changedUser {            id            username          }        }      }    ` , \n   variables :   { \n     user :   { \n       id :   VXNlcjo4 \n     } \n   }  };  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   ( error ,   response ,   body )   =   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 { \n   data :   { \n     deleteUser :   { \n       changedUser :   { \n         id :   VXNlcjo4 , \n         username :   elon@spacex.com \n       } \n     } \n   }  }     \n  The request above may return  null . This is an indication that you tried to delete a piece of data\n  that doesn't exist.   Use delete operations to delete data from your API. Delete requires the unique global identifier  id \nof the piece of data that you wish to delete. Upon deleting data, you will receive the data back one\nlast time in case you need it again, and to serve as confirmation that that particular object was removed.", 
            "title": "Delete"
        }, 
        {
            "location": "/coredata/subscriptions/", 
            "text": "Subscriptions\n\n\n\n\nExample: Subscribe and get a real-time feed of when any user logs in or is created.\n\n\nQuery\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nsubscription SubscribeToUser($user: [UserMutationEvent]!) {\n  subscribeToUser(mutations: $user) {\n    mutation\n    value {\n      id\n      username\n    }\n  }\n}\n\n\n\n\n\n\n\n\nVariables\n\n\n\n\n1\n2\n3\n4\n5\n6\n{\n\n  \nuser\n:\n \n[\n\n    \nloginUser\n,\n\n    \ncreateUser\n\n  \n]\n\n\n}\n\n\n\n\n\n\n\nWhen Facebook open-sourced GraphQL, they described how applications can perform reads\nwith queries, and writes with mutations. However, oftentimes clients want to get pushed\nupdates from the server when data they care about changes. Enter Subscriptions. \nSubscriptions\nmake real-time functionality a first class citizen in GraphQL!\n\n\nSubscriptions offer a clean and efficient way to get pushed updates in real-time. They act\nin parallel to mutations. Just like how mutations describe the set of actions you can\ntake to change your data, subscriptions define the set of events that you can subscribe\nto when data changes. In fact, you can think of subscriptions as a way to react to\nmutations made elsewhere.\n\n\nFor example, think about a chat application like \nSlack\n. To create a good user experience,\nour application needs to stay up to date at all times. I.E. when a co-worker sends me a message,\nI shouldn't have to refresh the page to see the message. A much better solution is to have the\nserver push my chat client the message as soon as it is created. This is how subscriptions work.\nWhen someone creates a message (or in other words issues a mutation), the server immediately\npushes the data to every client that is both subscribed to that event.\n\n\n\n    \nGraphQL Subscriptions require a web socket connection.\n This is client-specific. We use Apollo Client\n    for our web apps as they have functionality to add a web socket handler to their base network interface.\n\n\n\n\nSubscriptions in GraphiQL\n\n\n\n\nQuery\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nsubscription SubscribeToNewMessages($messageFilter:MessageSubscriptionFilter) {\n  subscribeToMessage(mutations:[createMessage], filter:$messageFilter) {\n    mutation\n    value {\n      id\n      content\n      channel {\n        id\n        name\n      }\n      createdAt\n    }\n  }\n}\n\n\n\n\n\n\n\n\nVariables\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n{\n\n  \nmessageFilter:\n \n{\n\n    \ncontent:\n \n{\n\n      \nmatches:\n \n.\\*GraphQL.\\*\n\n    \n}\n,\n\n    \nchannelId:\n \n{\n\n      \neq:\n \nSavedChannelId\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nYou can play around with Subscriptions in our GraphiQL page! It's hooked up to handle web socket connections, so Subscription\nrequests will work immediately. Normal HTTP clients won't work with Subscriptions since it requires a web socket connection.\n\n\n\n\nThis is what I'm doing:\n\n\n1) I create a \nChannel\n object with name \nGraphQL News!\n and save its id.\n\n\n2) By issuing the query to the right, I subscribe to all new messages that are created in the \nGraphQL News!\n channel\nand that have content matching the regex \n.*GraphQL.*\n\n\n3) I send a \nMessage\n with content \nGraphQL is future!\n to channel \nGraphQLNews!\n and see a message pushed into the Subscription stream.\n\n\n4) I send a \nMessage\n with content \nREST is dead!\n to channel \nGraphQLNews!\n and no message appears in the Subscription stream.\n\n\n5) I send a \nMessage\n with content \nGraphQL Subscriptions are Awesome!\n to channel \nGraphQLNews!\n and another message appears in the Subscription stream.\n\n\n6) I close the Subscription by double-tapping the pulse icon in the subscription stream.\n\n\nSubscribing to changes to data in your API is that easy! There are a number of subscription filters you can use to\nfine tune your subscriptions and you can even filter on One-To-Many and One-to-One connections using the associated\nid filters.\n\n\nOur Subscription implementation works (\nalmost\n) out of the box with Apollo Client. Follow these\nsteps to make your app real-time!\n\n\nSubscription Filters\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\ntype XSubscriptionFilter {\n  eq: String\n  gt: String\n  gte: String\n  lt: String\n  lte: String\n  ne: String\n  between: [String]\n  notBetween: [String]\n  in: [String]\n  notIn: [String]\n  like: String\n  notLike: String\n  matches: String\n  notMatches: String\n  isNull: Boolean\n}\n\n\n\n\n\n\n\n\nlike\n and \nnotLike\n accept SQL match syntax while \nmatches\n and \nnotMatches\n accepts JS Regex\nsyntax.\n\n\n\n\nScaphold exposes \nSubscriptionFilter\n arguments to subscription calls in your API so you can specify\nfine-grained conditions for when your subscription should fire. There are a lot of options available\nfor you to use in \nSubscriptionFilters\n\n\nYou will get the following operators for each scalar field in the type you are subscribing to.\n\n\nSubscribing to Connections\n\n\n\n\nQuery\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nsubscription SubscribeToNewMessages($messageFilter:MessageSubscriptionFilter) {\n  subscribeToMessage(mutations:[createMessage], filter:$messageFilter) {\n    mutation\n    value {\n      id\n      content\n      channel {\n        id\n      }\n      createdAt\n    }\n  }\n}\n\n\n\n\n\n\n\n\nVariables\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n  \nmessageFilter:\n \n{\n\n    \nchannelId:\n \n{\n\n      \neq:\n \nMyBase64ChannelId\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nApplications often need a way to subscribe to changes in objects that are somehow related to\nother objects in their API. For example, if you were building a chat application you might\nonly want to subscribe to messages in a particular chat room or channel. Scaphold allows you to\nissue this type of subscription using a \nSubscriptionFilter\n.\n\n\nThe example to the right shows how you can subscribe to all new messages for a particular channel\nin our \nSlackr tutorial\n.\nNotice how we pass in a \nMessageSubscriptionFilter\n that contains a \nchannelId\n field. These id based\nfilters work with all One-To-Many and One-To-One connections in your GraphQL schema. As you add\nthese connections in the Schema Designer, filter arguments will automatically appear in the relvant\n\nSubscriptionFilter\n.", 
            "title": "Subscriptions"
        }, 
        {
            "location": "/coredata/subscriptions/#subscriptions", 
            "text": "Example: Subscribe and get a real-time feed of when any user logs in or is created.  Query   1\n2\n3\n4\n5\n6\n7\n8\n9 subscription SubscribeToUser($user: [UserMutationEvent]!) {\n  subscribeToUser(mutations: $user) {\n    mutation\n    value {\n      id\n      username\n    }\n  }\n}    Variables   1\n2\n3\n4\n5\n6 { \n   user :   [ \n     loginUser , \n     createUser \n   ]  }    When Facebook open-sourced GraphQL, they described how applications can perform reads\nwith queries, and writes with mutations. However, oftentimes clients want to get pushed\nupdates from the server when data they care about changes. Enter Subscriptions.  Subscriptions\nmake real-time functionality a first class citizen in GraphQL!  Subscriptions offer a clean and efficient way to get pushed updates in real-time. They act\nin parallel to mutations. Just like how mutations describe the set of actions you can\ntake to change your data, subscriptions define the set of events that you can subscribe\nto when data changes. In fact, you can think of subscriptions as a way to react to\nmutations made elsewhere.  For example, think about a chat application like  Slack . To create a good user experience,\nour application needs to stay up to date at all times. I.E. when a co-worker sends me a message,\nI shouldn't have to refresh the page to see the message. A much better solution is to have the\nserver push my chat client the message as soon as it is created. This is how subscriptions work.\nWhen someone creates a message (or in other words issues a mutation), the server immediately\npushes the data to every client that is both subscribed to that event.  \n     GraphQL Subscriptions require a web socket connection.  This is client-specific. We use Apollo Client\n    for our web apps as they have functionality to add a web socket handler to their base network interface.", 
            "title": "Subscriptions"
        }, 
        {
            "location": "/coredata/subscriptions/#subscriptions-in-graphiql", 
            "text": "Query    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 subscription SubscribeToNewMessages($messageFilter:MessageSubscriptionFilter) {\n  subscribeToMessage(mutations:[createMessage], filter:$messageFilter) {\n    mutation\n    value {\n      id\n      content\n      channel {\n        id\n        name\n      }\n      createdAt\n    }\n  }\n}    Variables    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 { \n   messageFilter:   { \n     content:   { \n       matches:   .\\*GraphQL.\\* \n     } , \n     channelId:   { \n       eq:   SavedChannelId \n     } \n   }  }    You can play around with Subscriptions in our GraphiQL page! It's hooked up to handle web socket connections, so Subscription\nrequests will work immediately. Normal HTTP clients won't work with Subscriptions since it requires a web socket connection.   This is what I'm doing:  1) I create a  Channel  object with name  GraphQL News!  and save its id.  2) By issuing the query to the right, I subscribe to all new messages that are created in the  GraphQL News!  channel\nand that have content matching the regex  .*GraphQL.*  3) I send a  Message  with content  GraphQL is future!  to channel  GraphQLNews!  and see a message pushed into the Subscription stream.  4) I send a  Message  with content  REST is dead!  to channel  GraphQLNews!  and no message appears in the Subscription stream.  5) I send a  Message  with content  GraphQL Subscriptions are Awesome!  to channel  GraphQLNews!  and another message appears in the Subscription stream.  6) I close the Subscription by double-tapping the pulse icon in the subscription stream.  Subscribing to changes to data in your API is that easy! There are a number of subscription filters you can use to\nfine tune your subscriptions and you can even filter on One-To-Many and One-to-One connections using the associated\nid filters.  Our Subscription implementation works ( almost ) out of the box with Apollo Client. Follow these\nsteps to make your app real-time!", 
            "title": "Subscriptions in GraphiQL"
        }, 
        {
            "location": "/coredata/subscriptions/#subscription-filters", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 type XSubscriptionFilter {\n  eq: String\n  gt: String\n  gte: String\n  lt: String\n  lte: String\n  ne: String\n  between: [String]\n  notBetween: [String]\n  in: [String]\n  notIn: [String]\n  like: String\n  notLike: String\n  matches: String\n  notMatches: String\n  isNull: Boolean\n}    like  and  notLike  accept SQL match syntax while  matches  and  notMatches  accepts JS Regex\nsyntax.   Scaphold exposes  SubscriptionFilter  arguments to subscription calls in your API so you can specify\nfine-grained conditions for when your subscription should fire. There are a lot of options available\nfor you to use in  SubscriptionFilters  You will get the following operators for each scalar field in the type you are subscribing to.", 
            "title": "Subscription Filters"
        }, 
        {
            "location": "/coredata/subscriptions/#subscribing-to-connections", 
            "text": "Query    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 subscription SubscribeToNewMessages($messageFilter:MessageSubscriptionFilter) {\n  subscribeToMessage(mutations:[createMessage], filter:$messageFilter) {\n    mutation\n    value {\n      id\n      content\n      channel {\n        id\n      }\n      createdAt\n    }\n  }\n}    Variables   1\n2\n3\n4\n5\n6\n7 { \n   messageFilter:   { \n     channelId:   { \n       eq:   MyBase64ChannelId \n     } \n   }  }    Applications often need a way to subscribe to changes in objects that are somehow related to\nother objects in their API. For example, if you were building a chat application you might\nonly want to subscribe to messages in a particular chat room or channel. Scaphold allows you to\nissue this type of subscription using a  SubscriptionFilter .  The example to the right shows how you can subscribe to all new messages for a particular channel\nin our  Slackr tutorial .\nNotice how we pass in a  MessageSubscriptionFilter  that contains a  channelId  field. These id based\nfilters work with all One-To-Many and One-To-One connections in your GraphQL schema. As you add\nthese connections in the Schema Designer, filter arguments will automatically appear in the relvant SubscriptionFilter .", 
            "title": "Subscribing to Connections"
        }, 
        {
            "location": "/coredata/connections-pagination/", 
            "text": "Connections \n Pagination\n\n\n\n\nEach type will have associated \nConnection\n types like so:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\ntype XConnection {\n  edges: [XEdge]\n  pageInfo: PageInfo\n}\n\ntype XEdge {\n  cursor: String\n  node: X\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n}\n\n\n\n\n\n\n\n\nAll connection fields will take the form:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nquery {\n  connectionFieldOfTypeX (\n    first: Int,\n    after: String!,\n    last: Int,\n    before: String,\n    orderBy: String\n  ) {\n    edges {\n      cursor\n      node {\n        ...fields in type X\n      }\n    }\n    pageInfo {\n      hasNextPage\n      hasPreviousPage\n    }\n  }\n}\n\n\n\n\n\n\nWe use the concept of \nConnections\n to provide a standardized way of paginating through large sets of objects.\nYou can use the \nConnection\n type when defining your schema whenever you need to model relations on potentially\nlarge sets of data.\n\n\nConnections expose the following arguments:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwhere\n\n\nObject\n\n\nObject that represents SQL-like terms used for \nfiltering\n on a per-field basis\n\n\n\n\n\n\norderBy\n\n\nList\n\n\nFields that you wish to order by, and the order in which your app needs the data (\nASC\n or \nDESC\n)\n\n\n\n\n\n\nfirst\n\n\nInt\n\n\nActs as a limiting number of records to return and counts forward (i.e. from 0 to n)\n\n\n\n\n\n\nafter\n\n\nString\n\n\nPass in the cursor of an object, and you will retrieve the data \nafter\n that particular record in a paginated list\n\n\n\n\n\n\nlast\n\n\nInt\n\n\nActs as a limiting number of records to return and counts backward (i.e. from n to 0)\n\n\n\n\n\n\nbefore\n\n\nString\n\n\nPass in the cursor of an object, and you will retrieve the data \nbefore\n that particular record in a paginated list\n\n\n\n\n\n\n\n\n\n  Although connections expose \nfirst\n, \nafter\n, \nlast\n, and \nbefore\n we strongly recommend that you only ever use either\n  (\nfirst\n and \nafter\n) or (\nlast\n and \nbefore\n) together at once as unexpected behavior can occur if you use both at the same time.\n  The \norderBy\n paramater allows you to order your data with respect to a field in the connected type and we will maintain the order throughout the pagination.\n\n\n\n\nOne-to-One\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nmutation UpdateCountry($input: UpdateCountryInput!) { updateCountry(input: $input) { changedCountry { id name capitalCity { id name } } } }\n,\n\n\n    \nvariables\n: { \ninput\n: { \nid\n: \nQ291bnRyeTox\n, \ncapitalCityId\n: \nQ2FwaXRhbENpdHk6MQ==\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nvar\n \nrequest\n \n=\n \nrequire\n(\nrequest\n);\n\n\n\nvar\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    mutation UpdateCountry($input: UpdateCountryInput!) {\n\n\n      updateCountry(input: $input) {\n\n\n        changedCountry {\n\n\n          id\n\n\n          name\n\n\n          capitalCity {\n\n\n            id\n\n\n            name\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \ninput\n:\n \n{\n\n      \nid\n:\n \nQ291bnRyeTox\n,\n                         \n// Country ID\n\n      \ncapitalCityId\n:\n \nQ2FwaXRhbENpdHk6MQ==\n       \n// Capital City ID\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \nfunction\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n{\n\n  \ndata\n:\n \n{\n\n    \nupdateCountry\n:\n \n{\n\n      \nchangedCountry\n:\n \n{\n\n        \nid\n:\n \nQ291bnRyeTox\n,\n\n        \nname\n:\n \nUnited States\n,\n\n        \ncapitalCity\n:\n \n{\n\n          \nid\n:\n \nQ2FwaXRhbENpdHk6MQ==\n,\n\n          \nname\n:\n \nWashington, D.C.\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nGiven two types, \nCountry\n and \nCapitalCity\n, you can designate a one-to-one relationship between them since one country can only have one capital city. In a one-to-one connection\nbetween two types, there will be a field\u00a0on each of the connected types that refers back to the other (i.e. reverse name). With that, you can associate an instance of \nCountry\n\nwith another instance of \nCapitalCity\n.\n\n\nSteps:\n\n\n\n\nProvided the two types have been created already, add a field called \ncountry\n to \nCapitalCity\n with this configuration.\n\n\n\n\n\n\n\n\n\n\nCreate an instance of \nCountry\n.\n\n\n\n\n\n\nCreate an instance of \nCapitalCity\n.\n\n\n\n\n\n\nUpdate the country instance with the id of the newly created capital city on the \ncapitalCityId\n field.\n\n\n\n\n\n\nOne-to-Many\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nmutation UpdateFile($input: UpdateFileInput!) { updateFile(input: $input) { changedFile { id name owner { id username } } } }\n,\n\n\n    \nvariables\n: { \ninput\n: { \nid\n: \nRmlsZTox\n, \nownerId\n: \nVXNlcjox\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nvar\n \nrequest\n \n=\n \nrequire\n(\nrequest\n);\n\n\n\nvar\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    mutation UpdateFile($input: UpdateFileInput!) {\n\n\n      updateFile(input: $input) {\n\n\n        changedFile {\n\n\n          id\n\n\n          name\n\n\n          owner {\n\n\n            id\n\n\n            username\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \ninput\n:\n \n{\n\n      \nid\n:\n \nRmlsZTox\n,\n                 \n// File ID\n\n      \ncapitalCityId\n:\n \nVXNlcjox\n       \n// User ID\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \nfunction\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n{\n\n  \ndata\n:\n \n{\n\n    \nupdateFile\n:\n \n{\n\n      \nchangedFile\n:\n \n{\n\n        \nid\n:\n \nRmlsZTox\n,\n\n        \nname\n:\n \nprofilePicture\n,\n\n        \nowner\n:\n \n{\n\n          \nid\n:\n \nVXNlcjox\n,\n\n          \nusername\n:\n \nElon Musk\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nOne-to-many relationships work very similarly to one-to-one relationships. The difference is that after you connect two types, you \nmust\n update the instance on the \"many side\" of the\nconnection. Only the \"many side\" instance will have a field that associates it to an instance of the \"one side\" of the relationship.\n\n\nGiven two types, \nUser\n and \nFile\n, you can designate a one-to-many relationship between them since one user can have multiple files, while a file can only have one owner (user). In a\none-to-many connection\u00a0between two types, there will be a field injected on the file type called ownerId (id of the user). With that, you can associate an instance of \nUser\n\u00a0with another instance of \nFile\n.\n\n\nSteps:\n\n\n\n\nProvided the two types have been created already, add a field called \nfiles\n to \nUser\n with this configuration.\n\n\n\n\n\n\n\n\n\n\nCreate an instance of \nUser\n.\n\n\n\n\n\n\nCreate an instance of \nFile\n.\n\n\n\n\n\n\nUpdate the file instance with the id of the newly created user on the \nownerId\n field.\n\n\n\n\n\n\nMany-to-Many\n\n\n\n\nFor example, suppose we have the following schema:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\ntype User {\n  id: ID!\n  username: String!\n  posts: [Post]\n  edits: [Post]\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String\n  author: User\n  editors: [User]\n}\n\n\n\n\n\n\nMany-to-many connections are defined by having two types with Connection fields pointing to one another via their \nreverseName\n and have a special workflow for managing edges between their objects.\n\n\nGiven the example on the right, Scaphold will generate 3 special mutations for dealing with the many-to-many relations between \nUser\n and \nPost\n via the edits \n editors fields. These mutations will be:\n\n\n\n\naddToUserEditsConnection\n\n\nupdateUserEditsConnection\n\n\nremoveFromUserEditsConnection\n\n\n\n\nThese mutations can be used to add edges between objects in the many-to-many connection.\n\n\n\n  Connections are bi-directional and thus if you use addToUserEditsConnection(...) to\u00a0add a post to a users set of edited posts, then it will also add that user to the posts set of editors.\n\n\n\n\nSpecial Case\n\n\n\n\nSpecial Case Example\n\n\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nmutation AddFriendship($input: AddToFriendshipConnectionInput!) { addToFriendshipConnection(input: $input) { changedFriendship { status user1 { id username } user2 { id username } } } }\n,\n\n\n    \nvariables\n: { \ninput\n: { \nuser1Id\n: \nVXNlcjo0\n, \nuser2Id\n: \nVXNlcjoz\n, \nstatus\n: \nAccepted\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\nvar\n \nrequest\n \n=\n \nrequire\n(\nrequest\n);\n\n\n\nvar\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    mutation AddFriendship($input: AddToFriendshipConnectionInput!) {\n\n\n      addToFriendshipConnection(input: $input) {\n\n\n        changedFriendship {\n\n\n          status\n\n\n          user1 {\n\n\n            id\n\n\n            username\n\n\n          }\n\n\n          user2 {\n\n\n            id\n\n\n            username\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{\n\n    \ninput\n:\n \n{\n\n      \nuser1Id\n:\n \nVXNlcjo0\n,\n\n      \nuser2Id\n:\n \nVXNlcjoz\n,\n\n      \nstatus\n:\n \nAccepted\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \nfunction\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n{\n\n  \ndata\n:\n \n{\n\n    \naddToFriendshipConnection\n:\n \n{\n\n      \nchangedFriendship\n:\n \n{\n\n        \nstatus\n:\n \nAccepted\n,\n\n        \nuser1\n:\n \n{\n\n          \nid\n:\n \nVXNlcjo0\n,\n\n          \nusername\n:\n \nSteve Jobs\n\n        \n},\n\n        \nuser2\n:\n \n{\n\n          \nid\n:\n \nVXNlcjoz\n,\n\n          \nusername\n:\n \nBill Gates\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nIf you wanted to create a many-to-many relationship between a type and itself, Scaphold makes it easy to do so! Perhaps you wanted to create a relation between a User type and itself, thereby defining a friendship.\n\n\nThe steps to do so are:\n\n\n\n\n\n\nAdd a field to User called \nfriends\n.\n\n\n\n\n\n\nIt is a \nConnection\n of type \nUser\n with a many-to-many relationship and a \nreverse name that is the same as the field name\n. Upon selecting the many-to-many relationship, a new field will appear called \nConnection Name\n.\nThis will be the name of the \"join table\" (in the SQL sense) that will be automatically generated for you after\u00a0creating the new connection.\n\n\n\n\n\n\n\n\n\n\nThe resulting \"join table\" will be a new type in your schema. This creates a new table in Scaphold that will hold all your data that pertains to the\nedges of the connection for friends on the User type and you can add additional fields to this type as well.", 
            "title": "Connections"
        }, 
        {
            "location": "/coredata/connections-pagination/#connections-pagination", 
            "text": "Each type will have associated  Connection  types like so:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 type XConnection {\n  edges: [XEdge]\n  pageInfo: PageInfo\n}\n\ntype XEdge {\n  cursor: String\n  node: X\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n}    All connection fields will take the form:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 query {\n  connectionFieldOfTypeX (\n    first: Int,\n    after: String!,\n    last: Int,\n    before: String,\n    orderBy: String\n  ) {\n    edges {\n      cursor\n      node {\n        ...fields in type X\n      }\n    }\n    pageInfo {\n      hasNextPage\n      hasPreviousPage\n    }\n  }\n}   We use the concept of  Connections  to provide a standardized way of paginating through large sets of objects.\nYou can use the  Connection  type when defining your schema whenever you need to model relations on potentially\nlarge sets of data.  Connections expose the following arguments:     Name  Type  Description      where  Object  Object that represents SQL-like terms used for  filtering  on a per-field basis    orderBy  List  Fields that you wish to order by, and the order in which your app needs the data ( ASC  or  DESC )    first  Int  Acts as a limiting number of records to return and counts forward (i.e. from 0 to n)    after  String  Pass in the cursor of an object, and you will retrieve the data  after  that particular record in a paginated list    last  Int  Acts as a limiting number of records to return and counts backward (i.e. from n to 0)    before  String  Pass in the cursor of an object, and you will retrieve the data  before  that particular record in a paginated list     \n  Although connections expose  first ,  after ,  last , and  before  we strongly recommend that you only ever use either\n  ( first  and  after ) or ( last  and  before ) together at once as unexpected behavior can occur if you use both at the same time.\n  The  orderBy  paramater allows you to order your data with respect to a field in the connected type and we will maintain the order throughout the pagination.", 
            "title": "Connections &amp; Pagination"
        }, 
        {
            "location": "/coredata/connections-pagination/#one-to-one", 
            "text": "1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  mutation UpdateCountry($input: UpdateCountryInput!) { updateCountry(input: $input) { changedCountry { id name capitalCity { id name } } } } ,       variables : {  input : {  id :  Q291bnRyeTox ,  capitalCityId :  Q2FwaXRhbENpdHk6MQ==  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41 var   request   =   require ( request );  var   data   =   { \n   query :   `      mutation UpdateCountry($input: UpdateCountryInput!) {        updateCountry(input: $input) {          changedCountry {            id            name            capitalCity {              id              name            }          }        }      }    ` , \n   variables :   { \n     input :   { \n       id :   Q291bnRyeTox ,                           // Country ID \n       capitalCityId :   Q2FwaXRhbENpdHk6MQ==         // Capital City ID \n     } \n   }  }  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   function ( error ,   response ,   body )   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 { \n   data :   { \n     updateCountry :   { \n       changedCountry :   { \n         id :   Q291bnRyeTox , \n         name :   United States , \n         capitalCity :   { \n           id :   Q2FwaXRhbENpdHk6MQ== , \n           name :   Washington, D.C. \n         } \n       } \n     } \n   }  }    Given two types,  Country  and  CapitalCity , you can designate a one-to-one relationship between them since one country can only have one capital city. In a one-to-one connection\nbetween two types, there will be a field\u00a0on each of the connected types that refers back to the other (i.e. reverse name). With that, you can associate an instance of  Country \nwith another instance of  CapitalCity .  Steps:   Provided the two types have been created already, add a field called  country  to  CapitalCity  with this configuration.      Create an instance of  Country .    Create an instance of  CapitalCity .    Update the country instance with the id of the newly created capital city on the  capitalCityId  field.", 
            "title": "One-to-One"
        }, 
        {
            "location": "/coredata/connections-pagination/#one-to-many", 
            "text": "1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  mutation UpdateFile($input: UpdateFileInput!) { updateFile(input: $input) { changedFile { id name owner { id username } } } } ,       variables : {  input : {  id :  RmlsZTox ,  ownerId :  VXNlcjox  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41 var   request   =   require ( request );  var   data   =   { \n   query :   `      mutation UpdateFile($input: UpdateFileInput!) {        updateFile(input: $input) {          changedFile {            id            name            owner {              id              username            }          }        }      }    ` , \n   variables :   { \n     input :   { \n       id :   RmlsZTox ,                   // File ID \n       capitalCityId :   VXNlcjox         // User ID \n     } \n   }  }  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   function ( error ,   response ,   body )   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 { \n   data :   { \n     updateFile :   { \n       changedFile :   { \n         id :   RmlsZTox , \n         name :   profilePicture , \n         owner :   { \n           id :   VXNlcjox , \n           username :   Elon Musk \n         } \n       } \n     } \n   }  }    One-to-many relationships work very similarly to one-to-one relationships. The difference is that after you connect two types, you  must  update the instance on the \"many side\" of the\nconnection. Only the \"many side\" instance will have a field that associates it to an instance of the \"one side\" of the relationship.  Given two types,  User  and  File , you can designate a one-to-many relationship between them since one user can have multiple files, while a file can only have one owner (user). In a\none-to-many connection\u00a0between two types, there will be a field injected on the file type called ownerId (id of the user). With that, you can associate an instance of  User \u00a0with another instance of  File .  Steps:   Provided the two types have been created already, add a field called  files  to  User  with this configuration.      Create an instance of  User .    Create an instance of  File .    Update the file instance with the id of the newly created user on the  ownerId  field.", 
            "title": "One-to-Many"
        }, 
        {
            "location": "/coredata/connections-pagination/#many-to-many", 
            "text": "For example, suppose we have the following schema:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 type User {\n  id: ID!\n  username: String!\n  posts: [Post]\n  edits: [Post]\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String\n  author: User\n  editors: [User]\n}   Many-to-many connections are defined by having two types with Connection fields pointing to one another via their  reverseName  and have a special workflow for managing edges between their objects.  Given the example on the right, Scaphold will generate 3 special mutations for dealing with the many-to-many relations between  User  and  Post  via the edits   editors fields. These mutations will be:   addToUserEditsConnection  updateUserEditsConnection  removeFromUserEditsConnection   These mutations can be used to add edges between objects in the many-to-many connection.  \n  Connections are bi-directional and thus if you use addToUserEditsConnection(...) to\u00a0add a post to a users set of edited posts, then it will also add that user to the posts set of editors.  Special Case   Special Case Example   1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  mutation AddFriendship($input: AddToFriendshipConnectionInput!) { addToFriendshipConnection(input: $input) { changedFriendship { status user1 { id username } user2 { id username } } } } ,       variables : {  input : {  user1Id :  VXNlcjo0 ,  user2Id :  VXNlcjoz ,  status :  Accepted  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45 var   request   =   require ( request );  var   data   =   { \n   query :   `      mutation AddFriendship($input: AddToFriendshipConnectionInput!) {        addToFriendshipConnection(input: $input) {          changedFriendship {            status            user1 {              id              username            }            user2 {              id              username            }          }        }      }    ` , \n   variables :   { \n     input :   { \n       user1Id :   VXNlcjo0 , \n       user2Id :   VXNlcjoz , \n       status :   Accepted \n     } \n   }  }  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   function ( error ,   response ,   body )   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 { \n   data :   { \n     addToFriendshipConnection :   { \n       changedFriendship :   { \n         status :   Accepted , \n         user1 :   { \n           id :   VXNlcjo0 , \n           username :   Steve Jobs \n         }, \n         user2 :   { \n           id :   VXNlcjoz , \n           username :   Bill Gates \n         } \n       } \n     } \n   }  }    If you wanted to create a many-to-many relationship between a type and itself, Scaphold makes it easy to do so! Perhaps you wanted to create a relation between a User type and itself, thereby defining a friendship.  The steps to do so are:    Add a field to User called  friends .    It is a  Connection  of type  User  with a many-to-many relationship and a  reverse name that is the same as the field name . Upon selecting the many-to-many relationship, a new field will appear called  Connection Name .\nThis will be the name of the \"join table\" (in the SQL sense) that will be automatically generated for you after\u00a0creating the new connection.      The resulting \"join table\" will be a new type in your schema. This creates a new table in Scaphold that will hold all your data that pertains to the\nedges of the connection for friends on the User type and you can add additional fields to this type as well.", 
            "title": "Many-to-Many"
        }, 
        {
            "location": "/authentication/tokens/", 
            "text": "Scaphold seamelessly handles user authentication for you. Each Scaphold application comes with a default User model which includes a \nusername\n and \npassword\n that are used to authenticate your users.\nWe securely encrypt and store each user's password as well as ensure that they are not readable.\n\n\nToken\n\n\n\n\nExample \nloginUser\n query\n\n\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{\nquery\n: \nmutation LoginUserQuery ($input: LoginUserInput!) { loginUser(input: $input) { token user { id username createdAt } } }\n,\n\n\n    \nvariables\n: { \ninput\n: { \nusername\n: \nelon@tesla.com\n, \npassword\n: \nSuperSecretPassword\n } } }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nimport\n \nrequest\n \nfrom\n \nrequest\n;\n\n\n\nconst\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`mutation LoginUserQuery ($input: LoginUserInput!) {\n\n\n    loginUser(input: $input) {\n\n\n      token\n\n\n      user {\n\n\n        id\n\n\n        username\n\n\n        createdAt\n\n\n      }\n\n\n    }\n\n\n  }`\n,\n\n  \nvariables\n:\n \n{\n\n    \ninput\n:\n \n{\n\n      \nusername\n:\n \nelon@tesla.com\n,\n\n      \npassword\n:\n \nSuperSecretPassword\n\n    \n}\n\n  \n}\n\n\n};\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n=\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n{\n\n  \ndata\n:\n \n{\n\n    \nloginUser\n:\n \n{\n\n      \ntoken\n:\n \neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODI4ODI0ODgsImlhdCI6MTQ4MTU4NjQ4OCwiYXVkIjoiNDRiZTA4NmYtYmYzMy00OTk3LTgxMzYtOWMwMWQ5OWE4OGM0IiwiaXNzIjoiaHR0cHM6Ly9zY2FwaG9sZC5pbyIsInN1YiI6IjcifQ.TDRtD5vD7MIVrViDgVMThhzOzE_teufTo51a4GZ3aGA\n,\n\n      \nuser\n:\n \n{\n\n        \nid\n:\n \nVXNlcjo3\n,\n\n        \nusername\n:\n \nelon@tesla.com\n,\n\n        \ncreatedAt\n:\n \n2016-12-08T20:43:14.000Z\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nImportant\n: Use the \ntoken\n in the response in the header of future requests as:\n\n\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODI4ODI0ODgsImlhdCI6MTQ4MTU4NjQ4OCwiYXVkIjoiNDRiZTA4NmYtYmYzMy00OTk3LTgxMzYtOWMwMWQ5OWE4OGM0IiwiaXNzIjoiaHR0cHM6Ly9zY2FwaG9sZC5pbyIsInN1YiI6IjcifQ.TDRtD5vD7MIVrViDgVMThhzOzE_teufTo51a4GZ3aGA\n\n\n\n\nLogging in a user is simple. Use the \nloginUser\n mutation we provide you and we will return a JSON Web Token (JWT) if the credentials match. To authenticate a user, you simply set the \nAuthorization\n\nHTTP header of your request with the format \nBearer {TOKEN_FROM_LOGIN_USER}\n.\n\n\nThis token informs your API what user is logged in at any given time and enables our permissions system to layer access control rules on your data.\n\n\n\n  There are two ways to change a user's password:\n  \n\n    \n\n      \nReset password\n: Use the \nupdateUser\n mutation to update a user's password given a user's \nid\n, and new \npassword\n.\n      Note here that no server-side validation for the old password.\n    \n\n    \n\n      \nForgot password\n: Use the \nupdateUserPassword\n mutation to update a user's password given a user's \nid\n, \noldPassword\n, and \nnewPassword\n.", 
            "title": "Auth Tokens"
        }, 
        {
            "location": "/authentication/tokens/#token", 
            "text": "Example  loginUser  query   1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  { query :  mutation LoginUserQuery ($input: LoginUserInput!) { loginUser(input: $input) { token user { id username createdAt } } } ,       variables : {  input : {  username :  elon@tesla.com ,  password :  SuperSecretPassword  } } }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37 import   request   from   request ;  const   data   =   { \n   query :   `mutation LoginUserQuery ($input: LoginUserInput!) {      loginUser(input: $input) {        token        user {          id          username          createdAt        }      }    }` , \n   variables :   { \n     input :   { \n       username :   elon@tesla.com , \n       password :   SuperSecretPassword \n     } \n   }  };  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   ( error ,   response ,   body )   =   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 { \n   data :   { \n     loginUser :   { \n       token :   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODI4ODI0ODgsImlhdCI6MTQ4MTU4NjQ4OCwiYXVkIjoiNDRiZTA4NmYtYmYzMy00OTk3LTgxMzYtOWMwMWQ5OWE4OGM0IiwiaXNzIjoiaHR0cHM6Ly9zY2FwaG9sZC5pbyIsInN1YiI6IjcifQ.TDRtD5vD7MIVrViDgVMThhzOzE_teufTo51a4GZ3aGA , \n       user :   { \n         id :   VXNlcjo3 , \n         username :   elon@tesla.com , \n         createdAt :   2016-12-08T20:43:14.000Z \n       } \n     } \n   }  }     Important : Use the  token  in the response in the header of future requests as:  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0ODI4ODI0ODgsImlhdCI6MTQ4MTU4NjQ4OCwiYXVkIjoiNDRiZTA4NmYtYmYzMy00OTk3LTgxMzYtOWMwMWQ5OWE4OGM0IiwiaXNzIjoiaHR0cHM6Ly9zY2FwaG9sZC5pbyIsInN1YiI6IjcifQ.TDRtD5vD7MIVrViDgVMThhzOzE_teufTo51a4GZ3aGA   Logging in a user is simple. Use the  loginUser  mutation we provide you and we will return a JSON Web Token (JWT) if the credentials match. To authenticate a user, you simply set the  Authorization \nHTTP header of your request with the format  Bearer {TOKEN_FROM_LOGIN_USER} .  This token informs your API what user is logged in at any given time and enables our permissions system to layer access control rules on your data.  \n  There are two ways to change a user's password:\n   \n     \n       Reset password : Use the  updateUser  mutation to update a user's password given a user's  id , and new  password .\n      Note here that no server-side validation for the old password.\n     \n     \n       Forgot password : Use the  updateUserPassword  mutation to update a user's password given a user's  id ,  oldPassword , and  newPassword .", 
            "title": "Token"
        }, 
        {
            "location": "/authentication/permissions/", 
            "text": "Permissions (Authorization)\n\n\n\n\nImportant\n: If a type has no permissions then anyone can perform any operations on it so make sure you add them before launching!\n\n\n\n\nScaphold implements a permissions system that allows you to define powerful access control rules by leveraging a combination of features from role-based access control systems (RBAC) as well as the connections in your API's graph to define what users can access what information.\n\n\nEach type and field in your schema has an optional set of permissions applied to it. When a user tries to complete an operation, your API checks the type- and field-level permissions and validates that the user is authorized to complete that operation. When you login to the Scaphold portal, you are logged in as an admin user and will have complete access to your application.\n\n\nTo add a permission, click on the \n+\n sign in the top right for the panel of the type you wish to add a permission to. There you can add a permission for all of the fields of a particular type or only specific fields on that type.\n\n\n\n\nThe following sections delineate the various types of permissioning that you can apply to your data.\n\n\n\n  Keep in mind that if you layer permissions, the most lenient authorization rule wins.\n\n\n\n\nEveryone\n\n\nEveryone\n scoped permissions are the loosest available. Everyone can access the type. No login required.\n\n\nAuthenticated\n\n\nAuthenticated\n scoped permissions required a valid auth token to be present in the request headers (See \nauthentication\n for more details). Scaphold provides a number of authentication mechanisms that all work seamlessly with your permissions.\n\n\nRoles\n\n\n\n\nGraphQL types used in role-based permissioning to manage roles, members, and access levels.\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\ntype User {\n  id: ID!\n  username: String\n  password: Secret\n  credentials: CredentialConnection\n  lastLogin: DateTime\n  roles: RoleConnection\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\ntype Role {\n  id: ID\n  name: String\n  members: UserConnection\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\ntype UserRoles {\n  accessLevel: AccessLevel\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\nenum AccessLevel {\n  admin\n  readwrite\n  readonly\n}\n\n\n\n\n\n\nRole\n permissions allow you to layer more generic role-based authentication methods on top of the connection and user-based permissions you already have. We have added a few queries and mutations that make it easy to manage your new roles and permissions.\n\n\nIn particular, you role-based permissioning is concerned with 3 object types: \nUser\n, \nRole\n, and a through type called \nUserRoles\n. In addition, we use the enum \nAcessLevel\n to manage how much access we should provide a particular instance of a \nUserRole\n.\n\n\n\n\n\n\n\n\nName\n\n\nInputs\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetRole\n\n\nid: ID!\n\n\nGet objects of type Role by id.\n\n\n\n\n\n\ncreateRole\n\n\nname: String!\n\n\nCreates a new role and enrolls the creator as a role admin.\n\n\n\n\n\n\nupdateRole\n\n\nid: ID!\n, \nname: String\n\n\nUpdate an existing role.\n\n\n\n\n\n\ndeleteRole\n\n\nid: ID!\n\n\nDelete an existing role. Only role admins can delete roles.\n\n\n\n\n\n\naddToUserRolesConnection\n\n\nuserId: ID!\n, \nroleID: ID!\n, \naccessLevel: AccessLevel\n\n\nEnrolls a user as a member of a role. Only admins can create other admins and you must be an admin to enroll another user.\n\n\n\n\n\n\nupdateUserRolesConnection\n\n\nuserId: ID!\n, \nroleID: ID!\n, \naccessLevel: AccessLevel\n\n\nUpdates a connection between an object of type \nUser\n and an object of type \nRole\n.\n\n\n\n\n\n\nremoveFromUserRolesConnection\n\n\nuserId: ID!\n, \nroleId: ID!\n\n\nRemoves a user from a role. Anyone can disenroll themself and admins can disenroll anyone.\n\n\n\n\n\n\n\n\nBy default, we create a special \nadmin\n role for each of your apps. Users that are enrolled into the \nadmin\n role are given full access to your GraphQL API without having to specify any custom permissions.\n\n\n\n\nRole\n scoped permissions can be used alongside existing \nRelation\n scoped permissions to easily create complex access control rules. Let's take an example where we would like to have a \nset of notes\n that \nonly executives of my company can see\n.\nPart of our schema might look something like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n// Schema\ntype User {\n  id: ID!\n  username: String!\n  authoredExecNotes: ExecutiveNoteConnection\n}\n\ntype ExecutiveNote {\n  id: ID!\n  author: User\n  content: String\n}\n\n// Permissions\n[{\n  scope: \nROLE\n,\n  roles: [\nExecutives\n],\n  read: true,\n  create: true\n}\n{\n  scope: \nRELATION\n,\n  userFields: [\nauthor\n],\n  update: true,\n  delete: true\n}]\n\n\n\n\n\n\nRelation\n\n\n\n\nExample of \nRelation\n permission\n\n\nIn Slack, a user should only be able to view messages that belong to a channel that you're a member of. Looking at the example to the right, if you wanted to add this permission, you would add a\n\nRelation\n scoped permission to the \nMessage\n type with the user fields \nchannel.members\n.\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n# Simple Slack schema\n\ntype Channel {\n  id: ID!\n  messages: [Message]\n  members: [User]\n}\n\ntype Message {\n  id: ID!\n  body: String!\n  channel: Channel\n}\n\n\n\n\n\n\nRelation\n scoped permissions use the connections in your data's graph to authorize behaviors. When you add a \nRelation\n permission, you can specify a path in your data graph that from the type you're adding the permission\nto back to the authenticated user.\n\n\n\n\nIn our example, you would have to use the query like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n  viewer {\n    user {\n      channels {\n        messages {\n          body\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\nQuerying through \nviewer.allMessages\n would throw a permissioning error.\n\n\n\n\nIn order to keep queries that are protected by \nRelation\n scoped permissions performant, you must query through \nviewer.user\n. This allows us to trace the user field's path to ensure that you're only accessing objects\nrelated to the logged in user.", 
            "title": "Permissions"
        }, 
        {
            "location": "/authentication/permissions/#permissions-authorization", 
            "text": "Important : If a type has no permissions then anyone can perform any operations on it so make sure you add them before launching!   Scaphold implements a permissions system that allows you to define powerful access control rules by leveraging a combination of features from role-based access control systems (RBAC) as well as the connections in your API's graph to define what users can access what information.  Each type and field in your schema has an optional set of permissions applied to it. When a user tries to complete an operation, your API checks the type- and field-level permissions and validates that the user is authorized to complete that operation. When you login to the Scaphold portal, you are logged in as an admin user and will have complete access to your application.  To add a permission, click on the  +  sign in the top right for the panel of the type you wish to add a permission to. There you can add a permission for all of the fields of a particular type or only specific fields on that type.   The following sections delineate the various types of permissioning that you can apply to your data.  \n  Keep in mind that if you layer permissions, the most lenient authorization rule wins.", 
            "title": "Permissions (Authorization)"
        }, 
        {
            "location": "/authentication/permissions/#everyone", 
            "text": "Everyone  scoped permissions are the loosest available. Everyone can access the type. No login required.", 
            "title": "Everyone"
        }, 
        {
            "location": "/authentication/permissions/#authenticated", 
            "text": "Authenticated  scoped permissions required a valid auth token to be present in the request headers (See  authentication  for more details). Scaphold provides a number of authentication mechanisms that all work seamlessly with your permissions.", 
            "title": "Authenticated"
        }, 
        {
            "location": "/authentication/permissions/#roles", 
            "text": "GraphQL types used in role-based permissioning to manage roles, members, and access levels.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 type User {\n  id: ID!\n  username: String\n  password: Secret\n  credentials: CredentialConnection\n  lastLogin: DateTime\n  roles: RoleConnection\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\ntype Role {\n  id: ID\n  name: String\n  members: UserConnection\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\ntype UserRoles {\n  accessLevel: AccessLevel\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\nenum AccessLevel {\n  admin\n  readwrite\n  readonly\n}   Role  permissions allow you to layer more generic role-based authentication methods on top of the connection and user-based permissions you already have. We have added a few queries and mutations that make it easy to manage your new roles and permissions.  In particular, you role-based permissioning is concerned with 3 object types:  User ,  Role , and a through type called  UserRoles . In addition, we use the enum  AcessLevel  to manage how much access we should provide a particular instance of a  UserRole .     Name  Inputs  Description      getRole  id: ID!  Get objects of type Role by id.    createRole  name: String!  Creates a new role and enrolls the creator as a role admin.    updateRole  id: ID! ,  name: String  Update an existing role.    deleteRole  id: ID!  Delete an existing role. Only role admins can delete roles.    addToUserRolesConnection  userId: ID! ,  roleID: ID! ,  accessLevel: AccessLevel  Enrolls a user as a member of a role. Only admins can create other admins and you must be an admin to enroll another user.    updateUserRolesConnection  userId: ID! ,  roleID: ID! ,  accessLevel: AccessLevel  Updates a connection between an object of type  User  and an object of type  Role .    removeFromUserRolesConnection  userId: ID! ,  roleId: ID!  Removes a user from a role. Anyone can disenroll themself and admins can disenroll anyone.     By default, we create a special  admin  role for each of your apps. Users that are enrolled into the  admin  role are given full access to your GraphQL API without having to specify any custom permissions.   Role  scoped permissions can be used alongside existing  Relation  scoped permissions to easily create complex access control rules. Let's take an example where we would like to have a  set of notes  that  only executives of my company can see .\nPart of our schema might look something like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 // Schema\ntype User {\n  id: ID!\n  username: String!\n  authoredExecNotes: ExecutiveNoteConnection\n}\n\ntype ExecutiveNote {\n  id: ID!\n  author: User\n  content: String\n}\n\n// Permissions\n[{\n  scope:  ROLE ,\n  roles: [ Executives ],\n  read: true,\n  create: true\n}\n{\n  scope:  RELATION ,\n  userFields: [ author ],\n  update: true,\n  delete: true\n}]", 
            "title": "Roles"
        }, 
        {
            "location": "/authentication/permissions/#relation", 
            "text": "Example of  Relation  permission  In Slack, a user should only be able to view messages that belong to a channel that you're a member of. Looking at the example to the right, if you wanted to add this permission, you would add a Relation  scoped permission to the  Message  type with the user fields  channel.members .     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 # Simple Slack schema\n\ntype Channel {\n  id: ID!\n  messages: [Message]\n  members: [User]\n}\n\ntype Message {\n  id: ID!\n  body: String!\n  channel: Channel\n}   Relation  scoped permissions use the connections in your data's graph to authorize behaviors. When you add a  Relation  permission, you can specify a path in your data graph that from the type you're adding the permission\nto back to the authenticated user.   In our example, you would have to use the query like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 {\n  viewer {\n    user {\n      channels {\n        messages {\n          body\n        }\n      }\n    }\n  }\n}    Querying through  viewer.allMessages  would throw a permissioning error.   In order to keep queries that are protected by  Relation  scoped permissions performant, you must query through  viewer.user . This allows us to trace the user field's path to ensure that you're only accessing objects\nrelated to the logged in user.", 
            "title": "Relation"
        }, 
        {
            "location": "/authentication/social/", 
            "text": "Social\n\n\nFor social authentication, Scaphold has a solution for that as well! Integrating with OAuth providers like Facebook, Google, and Twtiter has never been easier with Scaphold's Auth0 integration.\n\n\nFind out how to \nintegrate social authentication\n or \nintegrate passwordless authentication\n.", 
            "title": "Social Auth"
        }, 
        {
            "location": "/authentication/social/#social", 
            "text": "For social authentication, Scaphold has a solution for that as well! Integrating with OAuth providers like Facebook, Google, and Twtiter has never been easier with Scaphold's Auth0 integration.  Find out how to  integrate social authentication  or  integrate passwordless authentication .", 
            "title": "Social"
        }, 
        {
            "location": "/authentication/super-users/", 
            "text": "Super Users\n\n\nScaphold provides the ability for you to generate an admin token that gives you super user access that supercedes all permission rules and access controls.\nThis is a great tool for importing or exporting data, any one-off data management tasks that need to be done, or scheduled jobs.\n\n\nPlease refer to the \nAdmin Token section\n\u00a0under App Management for more details.", 
            "title": "Super Users"
        }, 
        {
            "location": "/authentication/super-users/#super-users", 
            "text": "Scaphold provides the ability for you to generate an admin token that gives you super user access that supercedes all permission rules and access controls.\nThis is a great tool for importing or exporting data, any one-off data management tasks that need to be done, or scheduled jobs.  Please refer to the  Admin Token section \u00a0under App Management for more details.", 
            "title": "Super Users"
        }, 
        {
            "location": "/realtime/subscriptions-apollo/", 
            "text": "Subscriptions With Apollo Client\n\n\n\n\nCondensed example from our Slackr app (JavaScript only)\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n/* File: addGraphQLSubscriptions.js */\n\n\n\nimport\n \n{\n \nprint\n \n}\n \nfrom\n \ngraphql-tag/printer\n;\n\n\n\n// quick way to add the subscribe and unsubscribe functions to the network interface\n\n\nexport\n \ndefault\n \nfunction\n \naddGraphQLSubscriptions\n(\nnetworkInterface\n,\n \nwsClient\n)\n \n{\n\n  \nreturn\n \nObject\n.\nassign\n(\nnetworkInterface\n,\n \n{\n\n    \nsubscribe\n(\nrequest\n,\n \nhandler\n)\n \n{\n\n      \nreturn\n \nwsClient\n.\nsubscribe\n({\n\n        \nquery\n:\n \nprint\n(\nrequest\n.\nquery\n),\n\n        \nvariables\n:\n \nrequest\n.\nvariables\n,\n\n      \n},\n \nhandler\n);\n\n    \n},\n\n    \nunsubscribe\n(\nid\n)\n \n{\n\n      \nwsClient\n.\nunsubscribe\n(\nid\n);\n\n    \n},\n\n  \n});\n\n\n}\n\n\n\n/* End of file: addGraphQLSubscriptions.js */\n\n\n\n------------------------------------------------------------------------\n\n\n\n/* File: makeApolloClient.js */\n\n\n\nimport\n \naddGraphQLSubscriptions\n \nfrom\n \n./addGraphQLSubscriptions\n;\n\n\nimport\n \nApolloClient\n,\n \n{\n \ncreateNetworkInterface\n \n}\n \nfrom\n \napollo-client\n;\n\n\nimport\n \n{\n \nClient\n \n}\n \nfrom\n \nsubscriptions-transport-ws\n;\n\n\n\n// creates a subscription ready Apollo Client instance\n\n\nexport\n \nfunction\n \nmakeApolloClient\n()\n \n{\n\n  \nconst\n \nscapholdUrl\n \n=\n \nus-west-2.api.scaphold.io/graphql/scaphold-graphql\n;\n\n  \nconst\n \ngraphqlUrl\n \n=\n \n`https://\n${\nscapholdUrl\n}\n`\n;\n\n  \nconst\n \nwebsocketUrl\n \n=\n \n`wss://\n${\nscapholdUrl\n}\n`\n;\n\n  \nconst\n \nnetworkInterface\n \n=\n \ncreateNetworkInterface\n(\ngraphqlUrl\n);\n\n  \nnetworkInterface\n.\nuse\n([{\n\n    \napplyMiddleware\n(\nreq\n,\n \nnext\n)\n \n{\n\n      \n// Easy way to add authorization headers for every request\n\n      \nif\n \n(\n!\nreq\n.\noptions\n.\nheaders\n)\n \n{\n\n        \nreq\n.\noptions\n.\nheaders\n \n=\n \n{};\n  \n// Create the header object if needed.\n\n      \n}\n\n      \nif\n \n(\nlocalStorage\n.\ngetItem\n(\nscaphold_user_token\n))\n \n{\n\n        \n// This is how to authorize users using http auth headers\n\n        \nreq\n.\noptions\n.\nheaders\n.\nAuthorization\n \n=\n \n`Bearer \n${\nlocalStorage\n.\ngetItem\n(\nscaphold_user_token\n)\n}\n`\n;\n\n      \n}\n\n      \nnext\n();\n\n    \n},\n\n  \n}]);\n\n  \nconst\n \nwsClient\n \n=\n \nnew\n \nClient\n(\nwebsocketUrl\n);\n\n  \nconst\n \nnetworkInterfaceWithSubscriptions\n \n=\n \naddGraphQLSubscriptions\n(\nnetworkInterface\n,\n \nwsClient\n);\n\n\n  \nconst\n \nclientGraphql\n \n=\n \nnew\n \nApolloClient\n({\n\n    \nnetworkInterface\n:\n \nnetworkInterfaceWithSubscriptions\n,\n\n    \ninitialState\n:\n \n{},\n\n  \n});\n\n  \nreturn\n \nclientGraphql\n;\n\n\n}\n\n\n\n/* End of File: makeApolloClient.js */\n\n\n\n\n\n\n\nApollo Client is a (currently) JavaScript-only networking interface that provides a fully-featured\ncaching GraphQL client for any server or UI framework. It's an easy-to-use GraphQL\u00a0networking client\nthat works with HTTP and web socket requests. We use it at Scaphold to power our web apps, and many\nof the examples in \nour GitHub\n. But you can also use it for your\nReact Native apps as well to address mobile needs. They are coming out with support for native mobile\niOS and Android clients as well. You can read more about it \nhere\n.\n\n\nThe Scaphold GraphiQL page has already implemented the subscription protocol for you. The good news is that it is really easy to set this up in your own application. Here is how.\n\n\n1) \nDownload Apollo Client from npm!\n (Apollo Client works pretty much the same whether you are building a React, AngularJS, or vanilla JavaScript applications)\n\n\n\n\n\n\nnpm install apollo-client graphql-tag --save\n\n\n\n\n\n\nIf using React also \nnpm install react-apollo --save\n\n\n\n\n\n\nIf using Angular2 also \nnpm install angular2-apollo --save\n\n\n\n\n\n\n2) \nConfigure the Apollo Client network layer to work with websockets.\n To do this we can use the following two code snippets:\n\n\nThe \naddGraphQLSubscriptions\n function retrofits the Apollo Client network interface with the subscribe and unsubscribe methods that we can use from our application code.\n\n\nThe \nmakeApolloClient\n function then creates a new Apollo Client instance, applies the subscription methods, and adds a peice of authentication middleware before returning the client for use in our application.\n\n\nThis is all we need to do to configure our Apollo Client instance for GraphQL Subscriptions.", 
            "title": "Subscriptions With Apollo Client"
        }, 
        {
            "location": "/realtime/subscriptions-apollo/#subscriptions-with-apollo-client", 
            "text": "Condensed example from our Slackr app (JavaScript only)    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59 /* File: addGraphQLSubscriptions.js */  import   {   print   }   from   graphql-tag/printer ;  // quick way to add the subscribe and unsubscribe functions to the network interface  export   default   function   addGraphQLSubscriptions ( networkInterface ,   wsClient )   { \n   return   Object . assign ( networkInterface ,   { \n     subscribe ( request ,   handler )   { \n       return   wsClient . subscribe ({ \n         query :   print ( request . query ), \n         variables :   request . variables , \n       },   handler ); \n     }, \n     unsubscribe ( id )   { \n       wsClient . unsubscribe ( id ); \n     }, \n   });  }  /* End of file: addGraphQLSubscriptions.js */  ------------------------------------------------------------------------  /* File: makeApolloClient.js */  import   addGraphQLSubscriptions   from   ./addGraphQLSubscriptions ;  import   ApolloClient ,   {   createNetworkInterface   }   from   apollo-client ;  import   {   Client   }   from   subscriptions-transport-ws ;  // creates a subscription ready Apollo Client instance  export   function   makeApolloClient ()   { \n   const   scapholdUrl   =   us-west-2.api.scaphold.io/graphql/scaphold-graphql ; \n   const   graphqlUrl   =   `https:// ${ scapholdUrl } ` ; \n   const   websocketUrl   =   `wss:// ${ scapholdUrl } ` ; \n   const   networkInterface   =   createNetworkInterface ( graphqlUrl ); \n   networkInterface . use ([{ \n     applyMiddleware ( req ,   next )   { \n       // Easy way to add authorization headers for every request \n       if   ( ! req . options . headers )   { \n         req . options . headers   =   {};    // Create the header object if needed. \n       } \n       if   ( localStorage . getItem ( scaphold_user_token ))   { \n         // This is how to authorize users using http auth headers \n         req . options . headers . Authorization   =   `Bearer  ${ localStorage . getItem ( scaphold_user_token ) } ` ; \n       } \n       next (); \n     }, \n   }]); \n   const   wsClient   =   new   Client ( websocketUrl ); \n   const   networkInterfaceWithSubscriptions   =   addGraphQLSubscriptions ( networkInterface ,   wsClient ); \n\n   const   clientGraphql   =   new   ApolloClient ({ \n     networkInterface :   networkInterfaceWithSubscriptions , \n     initialState :   {}, \n   }); \n   return   clientGraphql ;  }  /* End of File: makeApolloClient.js */    Apollo Client is a (currently) JavaScript-only networking interface that provides a fully-featured\ncaching GraphQL client for any server or UI framework. It's an easy-to-use GraphQL\u00a0networking client\nthat works with HTTP and web socket requests. We use it at Scaphold to power our web apps, and many\nof the examples in  our GitHub . But you can also use it for your\nReact Native apps as well to address mobile needs. They are coming out with support for native mobile\niOS and Android clients as well. You can read more about it  here .  The Scaphold GraphiQL page has already implemented the subscription protocol for you. The good news is that it is really easy to set this up in your own application. Here is how.  1)  Download Apollo Client from npm!  (Apollo Client works pretty much the same whether you are building a React, AngularJS, or vanilla JavaScript applications)    npm install apollo-client graphql-tag --save    If using React also  npm install react-apollo --save    If using Angular2 also  npm install angular2-apollo --save    2)  Configure the Apollo Client network layer to work with websockets.  To do this we can use the following two code snippets:  The  addGraphQLSubscriptions  function retrofits the Apollo Client network interface with the subscribe and unsubscribe methods that we can use from our application code.  The  makeApolloClient  function then creates a new Apollo Client instance, applies the subscription methods, and adds a peice of authentication middleware before returning the client for use in our application.  This is all we need to do to configure our Apollo Client instance for GraphQL Subscriptions.", 
            "title": "Subscriptions With Apollo Client"
        }, 
        {
            "location": "/realtime/subscriptions-react/", 
            "text": "Subscriptions With React\n\n\n\n\nCondensed example from our Slackr app (JavaScript only)\n\n\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \ngraphql\n,\n \ncompose\n \n}\n \nfrom\n \nreact-apollo\n;\n\n\nimport\n \ngql\n \nfrom\n \ngraphql-tag\n;\n\n\n\nconst\n \nChannelMessagesQuery\n \n=\n \ngql\n`\n\n\nquery GetPublicChannels($channelId: ID!, $messageOrder: [MessageOrderByArgs]) {\n\n\n  getChannel(id: $channelId) {\n\n\n    id\n\n\n    name\n\n\n    messages(last: 50, orderBy: $messageOrder) {\n\n\n      edges {\n\n\n        node {\n\n\n          id\n\n\n          content\n\n\n          createdAt\n\n\n          author {\n\n\n            id\n\n\n            username\n\n\n            nickname\n\n\n            picture\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n}\n\n\n`\n;\n\n\n\nclass\n \nMessages\n \nextends\n \nReact\n.\nComponent\n \n{\n\n\n    \n...\n\n\n    \ncomponentWillReceiveProps\n(\nnewProps\n)\n \n{\n\n        \nif\n \n(\n\n            \n!\nnewProps\n.\ndata\n.\nloading\n \n\n            \nnewProps\n.\ndata\n.\ngetChannel\n\n        \n)\n \n{\n\n            \nif\n \n(\n\n                \n!\nthis\n.\nprops\n.\ndata\n.\ngetChannel\n \n||\n\n                \nnewProps\n.\ndata\n.\ngetChannel\n.\nid\n \n!==\n \nthis\n.\nprops\n.\ndata\n.\ngetChannel\n.\nid\n\n            \n)\n \n{\n\n                \n// If we change channels, subscribe to the new channel\n\n                \nthis\n.\nsubscribeToNewMessages\n();\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n    \n/*\n\n\n    *   Initiates the subscription and specifies how new data should be merged\n\n\n    *   into the cache using the updateQuery method.\n\n\n    */\n\n    \nsubscribeToNewMessages\n()\n \n{\n\n        \nthis\n.\nsubscription\n \n=\n \nthis\n.\nprops\n.\ndata\n.\nsubscribeToMore\n({\n\n            \ndocument\n:\n \ngql\n`\n\n\n                subscription newMessages($subscriptionFilter:MessageSubscriptionFilter) {\n\n\n                    subscribeToMessage(mutations:[createMessage], filter: $subscriptionFilter) {\n\n\n                        value {\n\n\n                            id\n\n\n                            content\n\n\n                            createdAt\n\n\n                            author {\n\n\n                                id\n\n\n                                username\n\n\n                                nickname\n\n\n                                picture\n\n\n                            }\n\n\n                        }\n\n\n                    }\n\n\n                }\n\n\n            `\n,\n\n            \nvariables\n:\n \n{\n\n                \nsubscriptionFilter\n:\n \n{\n\n                    \nchannelId\n:\n \n{\n\n                        \n// We\nre using react-router and grabbing the channelId from the url\n\n                        \n// to designate which channel to subscribe to\n\n                        \neq\n:\n \nthis\n.\nprops\n.\nparams\n \n?\n \nthis\n.\nprops\n.\nparams\n.\nchannelId\n \n:\n \nnull\n\n                    \n}\n\n                \n}\n\n            \n},\n\n\n            \n/*\n\n\n            *    Update query specifies how the new data should be merged\n\n\n            *    with our previous results. Note how the structure of the\n\n\n            *    object we return here directly matches the structure of\n\n\n            *    the GetPublicChannels query.\n\n\n            */\n\n            \nupdateQuery\n:\n \n(\nprev\n,\n \n{\n \nsubscriptionData\n \n})\n \n=\n \n{\n\n                \nconst\n \nnewEdges\n \n=\n \n[\n\n                    \n...\nprev\n.\ngetChannel\n.\nmessages\n.\nedges\n,\n\n                    \n{\n\n                        \nnode\n:\n \n{\n\n                            \n...\nsubscriptionData\n.\ndata\n.\nsubscribeToMessage\n.\nvalue\n,\n\n                        \n}\n\n                    \n}\n\n                \n];\n\n                \nreturn\n \n{\n\n                    \ngetChannel\n:\n \n{\n\n                        \nmessages\n:\n \n{\n\n                            \nedges\n:\n \nnewEdges\n,\n\n                        \n}\n\n                    \n}\n\n                \n};\n\n            \n},\n\n        \n});\n\n    \n}\n\n\n    \n...\n\n\n}\n\n\n\nconst\n \nMessagesWithData\n \n=\n \ncompose\n(\n\n  \ngraphql\n(\nChannelMessagesQuery\n,\n \n{\n\n    \noptions\n:\n \n(\nprops\n)\n \n=\n \n{\n\n      \nconst\n \nchannelId\n \n=\n \nprops\n.\nparams\n \n?\n \nprops\n.\nparams\n.\nchannelId\n \n:\n \nnull\n;\n\n      \nreturn\n \n{\n\n        \nreturnPartialData\n:\n \ntrue\n,\n\n        \nvariables\n:\n \n{\n\n          \nchannelId\n,\n\n          \nmessageOrder\n:\n \n[\n\n            \n{\n\n              \nfield\n:\n \ncreatedAt\n,\n\n              \ndirection\n:\n \nASC\n\n            \n}\n\n          \n],\n\n        \n},\n\n      \n};\n\n    \n},\n\n  \n}),\n\n  \n...\n \n// We compose a few more queries in the actual app.\n\n\n)(\nMessages\n);\n\n\n\nexport\n \ndefault\n \nMessagesWithData\n;\n\n\n\n\n\n\n\nLet's look at a more real world example using React. Apollo comes packed with really nice React bindings\nthat we can use to simplify the process of subscribing to data and merging new data into the client-side cache.\n\n\nTake a minute to look over this file. Apollo does a great job allowing us to use real-time subscriptions alongside traditional queries and mutations. The combination of \nsubscribeToMore\n and \nupdateQuery\n offer a powerful set of tools to keep our UI up to date when dealing with real-time data!\n\n\nSee the complete code on GitHub\n\n\nThe \nreturnPartialData: true\n option is important. When you want to use \nsubscribeToMore\n to merge results into the result of a normal query it is necessary to specify this.\n\n\nA few things are going on here. To make sense of what is happening, lets start from the logical beginning which actually occurs at the end of the file. See this line \nconst MessagesWithData = compose(graphql(ChannelMessagesQuery, ...));\n. This is the standard way to use Apollo to connect a react component with data from a GraphQL query. The \ngraphql\n function will wrap our component in a higher-order component that grabs our data and makes it available to our component via its \nprops\n. In this example, we will be able to access our \nChannel\n data from our component with \nthis.props.data.getChannel\n as soon as it is fetched.\n\n\nOkay so we have connected our component with a regular old GraphQL query, but how do we make it real-time? The key is the method \nsubscribeToMore\n.  Look at our \nsubscribeToNewMessages\n method. Apollo's \ngraphql\n function fits our component with the data prop that exposes the \nsubscribeToMore\n method. We use this method to attach a subscription query which then calls the \nupdateQuery\n method we pass in every time a new peice of data is pushed from the server. The object we return from \nupdateQuery\n is then merged with our previous results and persisted in the client side cache. This way, \nthis.props.data.getChannel...\n is always kept up to date and we can use it like normal to render our UI.", 
            "title": "Subscriptions With React"
        }, 
        {
            "location": "/realtime/subscriptions-react/#subscriptions-with-react", 
            "text": "Condensed example from our Slackr app (JavaScript only)     1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131 import   React   from   react ;  import   {   graphql ,   compose   }   from   react-apollo ;  import   gql   from   graphql-tag ;  const   ChannelMessagesQuery   =   gql `  query GetPublicChannels($channelId: ID!, $messageOrder: [MessageOrderByArgs]) {    getChannel(id: $channelId) {      id      name      messages(last: 50, orderBy: $messageOrder) {        edges {          node {            id            content            createdAt            author {              id              username              nickname              picture            }          }        }      }    }  }  ` ;  class   Messages   extends   React . Component   { \n\n     ... \n\n     componentWillReceiveProps ( newProps )   { \n         if   ( \n             ! newProps . data . loading   \n             newProps . data . getChannel \n         )   { \n             if   ( \n                 ! this . props . data . getChannel   || \n                 newProps . data . getChannel . id   !==   this . props . data . getChannel . id \n             )   { \n                 // If we change channels, subscribe to the new channel \n                 this . subscribeToNewMessages (); \n             } \n         } \n     } \n\n     /*      *   Initiates the subscription and specifies how new data should be merged      *   into the cache using the updateQuery method.      */ \n     subscribeToNewMessages ()   { \n         this . subscription   =   this . props . data . subscribeToMore ({ \n             document :   gql `                  subscription newMessages($subscriptionFilter:MessageSubscriptionFilter) {                      subscribeToMessage(mutations:[createMessage], filter: $subscriptionFilter) {                          value {                              id                              content                              createdAt                              author {                                  id                                  username                                  nickname                                  picture                              }                          }                      }                  }              ` , \n             variables :   { \n                 subscriptionFilter :   { \n                     channelId :   { \n                         // We re using react-router and grabbing the channelId from the url \n                         // to designate which channel to subscribe to \n                         eq :   this . props . params   ?   this . props . params . channelId   :   null \n                     } \n                 } \n             }, \n\n             /*              *    Update query specifies how the new data should be merged              *    with our previous results. Note how the structure of the              *    object we return here directly matches the structure of              *    the GetPublicChannels query.              */ \n             updateQuery :   ( prev ,   {   subscriptionData   })   =   { \n                 const   newEdges   =   [ \n                     ... prev . getChannel . messages . edges , \n                     { \n                         node :   { \n                             ... subscriptionData . data . subscribeToMessage . value , \n                         } \n                     } \n                 ]; \n                 return   { \n                     getChannel :   { \n                         messages :   { \n                             edges :   newEdges , \n                         } \n                     } \n                 }; \n             }, \n         }); \n     } \n\n     ...  }  const   MessagesWithData   =   compose ( \n   graphql ( ChannelMessagesQuery ,   { \n     options :   ( props )   =   { \n       const   channelId   =   props . params   ?   props . params . channelId   :   null ; \n       return   { \n         returnPartialData :   true , \n         variables :   { \n           channelId , \n           messageOrder :   [ \n             { \n               field :   createdAt , \n               direction :   ASC \n             } \n           ], \n         }, \n       }; \n     }, \n   }), \n   ...   // We compose a few more queries in the actual app.  )( Messages );  export   default   MessagesWithData ;    Let's look at a more real world example using React. Apollo comes packed with really nice React bindings\nthat we can use to simplify the process of subscribing to data and merging new data into the client-side cache.  Take a minute to look over this file. Apollo does a great job allowing us to use real-time subscriptions alongside traditional queries and mutations. The combination of  subscribeToMore  and  updateQuery  offer a powerful set of tools to keep our UI up to date when dealing with real-time data!  See the complete code on GitHub  The  returnPartialData: true  option is important. When you want to use  subscribeToMore  to merge results into the result of a normal query it is necessary to specify this.  A few things are going on here. To make sense of what is happening, lets start from the logical beginning which actually occurs at the end of the file. See this line  const MessagesWithData = compose(graphql(ChannelMessagesQuery, ...)); . This is the standard way to use Apollo to connect a react component with data from a GraphQL query. The  graphql  function will wrap our component in a higher-order component that grabs our data and makes it available to our component via its  props . In this example, we will be able to access our  Channel  data from our component with  this.props.data.getChannel  as soon as it is fetched.  Okay so we have connected our component with a regular old GraphQL query, but how do we make it real-time? The key is the method  subscribeToMore .  Look at our  subscribeToNewMessages  method. Apollo's  graphql  function fits our component with the data prop that exposes the  subscribeToMore  method. We use this method to attach a subscription query which then calls the  updateQuery  method we pass in every time a new peice of data is pushed from the server. The object we return from  updateQuery  is then merged with our previous results and persisted in the client side cache. This way,  this.props.data.getChannel...  is always kept up to date and we can use it like normal to render our UI.", 
            "title": "Subscriptions With React"
        }, 
        {
            "location": "/realtime/slackr-chat-app/", 
            "text": "The Full Slackr Tutorial\n\n\nFollow along as we build a real-time chat application called Slackr. We will cover subscriptions in depth\nand show you how to quickly make real-time apps with Apollo Client It covers a lot of material\nand has a full example app to boot!\n\n\nHow to Build real-time Apps with GraphQL Subscriptions\n\n\nSlackr Starter Kit\n\n\nCheck out the \nSlackr Starter Kit on Github\n.\nUse it to jump start your next real-time application!", 
            "title": "Build Slack Tutorial"
        }, 
        {
            "location": "/realtime/slackr-chat-app/#the-full-slackr-tutorial", 
            "text": "Follow along as we build a real-time chat application called Slackr. We will cover subscriptions in depth\nand show you how to quickly make real-time apps with Apollo Client It covers a lot of material\nand has a full example app to boot!  How to Build real-time Apps with GraphQL Subscriptions  Slackr Starter Kit  Check out the  Slackr Starter Kit on Github .\nUse it to jump start your next real-time application!", 
            "title": "The Full Slackr Tutorial"
        }, 
        {
            "location": "/custom-logic/", 
            "text": "What is Logic?\n\n\nLogic enables you to extend your API with business logic hosted on your\nown infrastructure. Different apps have different workflows and logic lets you customize Scaphold to fit virtually any need. You can host your logic on-prem or in the cloud as long as its accessible over the internet and you can even authenticate requests with custom headers. If your looking for the quickest way to start, we recommend\n\nAWS Lambda\n,\n\nAzure Functions\n, or\n\nWebtask.io\n.\n\n\nOur logic system is based on the concept of\n\nfunction composition\n.\nComposition lets us combine small microservices to create extremely powerful workflows. Let's take a look at how they work.", 
            "title": "Introduction"
        }, 
        {
            "location": "/custom-logic/#what-is-logic", 
            "text": "Logic enables you to extend your API with business logic hosted on your\nown infrastructure. Different apps have different workflows and logic lets you customize Scaphold to fit virtually any need. You can host your logic on-prem or in the cloud as long as its accessible over the internet and you can even authenticate requests with custom headers. If your looking for the quickest way to start, we recommend AWS Lambda , Azure Functions , or Webtask.io . \nOur logic system is based on the concept of function composition .\nComposition lets us combine small microservices to create extremely powerful workflows. Let's take a look at how they work.", 
            "title": "What is Logic?"
        }, 
        {
            "location": "/custom-logic/composition/", 
            "text": "Function Composition\n\n\nFunction composition is a technique that combines simple functions into more complicated ones. At Scaphold, we use function composition to create modular, testable, and maintainable GraphQL resolvers. Logic allows you to do the same.\n\n\n\n\nLet's walk through an example of how you might build an app like slack. Let's say a new user was invited to create an account and to join a particular team. This would take a couple of steps.\n\n\n\n  \nA user signs up and includes the name of the team.\n\n  \nBefore the user is created we validate the user's email then authorize that they can join the team.\n\n  \nThe user object is persisted to your DB hosted on Scaphold.\n\n  \nAfter the user is created, we use the generated ID to add the user to the Many-To-Many connection with the team.\n\n  \nThe new user is returned to the client along with the new connection to the team.\n\n  \nAfter the payload was delivered to the client, we asynchronously send push notifications to everyone in the team informing that a new user has joined.\n\n\n\n\n\n\n\nComplex workflows like this were exactly why we built Logic. Let's break down how we would use logic to build it.", 
            "title": "Function Composition"
        }, 
        {
            "location": "/custom-logic/composition/#function-composition", 
            "text": "Function composition is a technique that combines simple functions into more complicated ones. At Scaphold, we use function composition to create modular, testable, and maintainable GraphQL resolvers. Logic allows you to do the same.   Let's walk through an example of how you might build an app like slack. Let's say a new user was invited to create an account and to join a particular team. This would take a couple of steps.  \n   A user signs up and includes the name of the team. \n   Before the user is created we validate the user's email then authorize that they can join the team. \n   The user object is persisted to your DB hosted on Scaphold. \n   After the user is created, we use the generated ID to add the user to the Many-To-Many connection with the team. \n   The new user is returned to the client along with the new connection to the team. \n   After the payload was delivered to the client, we asynchronously send push notifications to everyone in the team informing that a new user has joined.    Complex workflows like this were exactly why we built Logic. Let's break down how we would use logic to build it.", 
            "title": "Function Composition"
        }, 
        {
            "location": "/custom-logic/pre-operations/", 
            "text": "Pre Operations\n\n\nUse pre-operation functions to validate and manipulate input before\nobjects are persisted to the database. You can add as many functions to a mutation as you want.\n\n\nWe will compose your logic functions such that output of one function is passed in as the input to the next function. For example let's go over a flow assuming that the \ncreateUser\n mutation was called with these variables:\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n  \ninput\n:\n \n{\n\n    \nusername\n:\n \nstewart@slack.com\n,\n\n    \npassword\n:\n \nsupersecret\n,\n\n    \nteamReferral\n:\n \nSlackAdmins\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe Request Body\n\n\nAssuming the same input as before, the first microservice in your workflow would receive a request with the following body:\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n  \ninput\n:\n \n{\n\n    \nusername\n:\n \nstewart@slack.com\n,\n\n    \npassword\n:\n \nsupersecret\n,\n\n    \nteamReferral\n:\n \nSlackAdmins\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nAt any step you can throw an http error to invalidate an input and we will propagate the error down to the client. If you want to manipulate the input you return an object under the \ninput\n key in the http response. Whatever object you return in your http response will be passed on to the next function. This allows you to both manipulate the input as well as propagate metadata through your functions. After your last pre-operation function, we will take the object under the \ninput\n key and pass it to the operation phase to be persisted.\n\n\nManipulate Input and Pass Metadata\n\n\nIf this were our original input\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n  \ninput\n:\n \n{\n\n    \nusername\n:\n \nstewart@slack.com\n,\n\n    \npassword\n:\n \nsupersecret\n,\n\n    \nteamReferral\n:\n \nSlackAdmins\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nand our first function returned this payload:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n\n  \ninput\n:\n \n{\n\n    \nusername\n:\n \nstewart@slack.com\n,\n\n    \npassword\n:\n \nsupersecret\n,\n\n    \nteamReferral\n:\n \nSlackAdmins\n,\n\n    \nemailVerified\n:\n \ntrue\n\n  \n},\n\n  \nemailMetadata\n:\n \n{\n\n    \ncompany\n:\n \nSlack, Inc.\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThen the next function in the composition would receive this body:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n\n  \ninput\n:\n \n{\n\n    \nusername\n:\n \nstewart@slack.com\n,\n\n    \npassword\n:\n \nsupersecret\n,\n\n    \nteamReferral\n:\n \nSlackAdmins\n,\n\n    \nemailVerified\n:\n \ntrue\n\n  \n},\n\n  \nemailMetadata\n:\n \n{\n\n    \ncompany\n:\n \nSlack, Inc.\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nPassing Input to the Operation Phase\n\n\nAfter the last pre-operation function, Scaphold will pass the object under the \ninput\n key on to the operation phase where it will be persisted. Keep this in mind as the object under\nthe input key should adhere to the mutation's input type. e.g. if we were calling the \ncreateUser\n mutation the object under the \ninput\n key should adhere to the \nCreateUserInput\n type.", 
            "title": "Pre Operations"
        }, 
        {
            "location": "/custom-logic/pre-operations/#pre-operations", 
            "text": "Use pre-operation functions to validate and manipulate input before\nobjects are persisted to the database. You can add as many functions to a mutation as you want.  We will compose your logic functions such that output of one function is passed in as the input to the next function. For example let's go over a flow assuming that the  createUser  mutation was called with these variables:  1\n2\n3\n4\n5\n6\n7 { \n   input :   { \n     username :   stewart@slack.com , \n     password :   supersecret , \n     teamReferral :   SlackAdmins \n   }  }", 
            "title": "Pre Operations"
        }, 
        {
            "location": "/custom-logic/pre-operations/#the-request-body", 
            "text": "Assuming the same input as before, the first microservice in your workflow would receive a request with the following body:  1\n2\n3\n4\n5\n6\n7 { \n   input :   { \n     username :   stewart@slack.com , \n     password :   supersecret , \n     teamReferral :   SlackAdmins \n   }  }    At any step you can throw an http error to invalidate an input and we will propagate the error down to the client. If you want to manipulate the input you return an object under the  input  key in the http response. Whatever object you return in your http response will be passed on to the next function. This allows you to both manipulate the input as well as propagate metadata through your functions. After your last pre-operation function, we will take the object under the  input  key and pass it to the operation phase to be persisted.", 
            "title": "The Request Body"
        }, 
        {
            "location": "/custom-logic/pre-operations/#manipulate-input-and-pass-metadata", 
            "text": "If this were our original input  1\n2\n3\n4\n5\n6\n7 { \n   input :   { \n     username :   stewart@slack.com , \n     password :   supersecret , \n     teamReferral :   SlackAdmins \n   }  }    and our first function returned this payload:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 { \n   input :   { \n     username :   stewart@slack.com , \n     password :   supersecret , \n     teamReferral :   SlackAdmins , \n     emailVerified :   true \n   }, \n   emailMetadata :   { \n     company :   Slack, Inc. \n   }  }    Then the next function in the composition would receive this body:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 { \n   input :   { \n     username :   stewart@slack.com , \n     password :   supersecret , \n     teamReferral :   SlackAdmins , \n     emailVerified :   true \n   }, \n   emailMetadata :   { \n     company :   Slack, Inc. \n   }  }", 
            "title": "Manipulate Input and Pass Metadata"
        }, 
        {
            "location": "/custom-logic/pre-operations/#passing-input-to-the-operation-phase", 
            "text": "After the last pre-operation function, Scaphold will pass the object under the  input  key on to the operation phase where it will be persisted. Keep this in mind as the object under\nthe input key should adhere to the mutation's input type. e.g. if we were calling the  createUser  mutation the object under the  input  key should adhere to the  CreateUserInput  type.", 
            "title": "Passing Input to the Operation Phase"
        }, 
        {
            "location": "/custom-logic/operation-phase/", 
            "text": "The Operation Phase\n\n\nAfter all of your pre-operation functions have finished, we take the input and persist it to the storage layer.\n\n\nThe operation phase is where Scaphold does everything it needs to persist the object. The operation\nphase often involves saving the object to the database, uploading files to blob storage, and firing\nevents for subscriptions. The operation phase will also sometime involve integrations. For example,\nif you have turned on the Algolia integration, this phase handles indexing the object in your Algolia\naccount for you.", 
            "title": "Operation Phase"
        }, 
        {
            "location": "/custom-logic/operation-phase/#the-operation-phase", 
            "text": "After all of your pre-operation functions have finished, we take the input and persist it to the storage layer.  The operation phase is where Scaphold does everything it needs to persist the object. The operation\nphase often involves saving the object to the database, uploading files to blob storage, and firing\nevents for subscriptions. The operation phase will also sometime involve integrations. For example,\nif you have turned on the Algolia integration, this phase handles indexing the object in your Algolia\naccount for you.", 
            "title": "The Operation Phase"
        }, 
        {
            "location": "/custom-logic/post-operations/", 
            "text": "Post-operations behave very similarly to pre-operations with one exception. When we call out to post-operation functions, we include the result of the operation under the \npayload\n key. Post operations also define a payload selection set that they use to selectively grab fields from the mutation payload. They will also receive the metadata added by the functions before it in the chain (included the metadata from pre-operation functions).\n\n\nUsing our same example, if our first post-operation function had this selection set\n\n\n1\n2\n3\n4\n5\n{\n  changedUser {\n    id teamReferral\n  }\n}\n\n\n\n\n\n\nThen the first post-operation function would receive a request body like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n\n  \npayload\n:\n \n{\n\n    \nchangedUser\n:\n \n{\n\n      \nid\n:\n \nxxxxxxxxx\n,\n\n      \nteamReferral\n:\n \nSlackAdmins\n,\n\n    \n}\n\n  \n},\n\n  \nemailMetadata\n:\n \n{\n\n    \ncompany\n:\n \nSlack, Inc.\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNote: You cannot manipulate the payload directly but you can issue mutations as well\nas attach metadata. The post-operation functions are particularly useful for managing the\nconnections of newly created objects.\n\n\nManaging Connections in Post Operations\n\n\nFor our slack app, we said we wanted to have the user automatically join the team as soon as the user was created. To keep our frontend efficient, we should be able to grab both the newly created user as well as the team in a single call from the mutation payload. For example look\nat the query below.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nmutation CreateUser($user: CreateUserInput!) {\n  createUser(input:$user) {\n    changedUser {\n      id\n      user\n      teams {\n        edges {\n          node {\n            id\n            name\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nWithout logic, this mutation would return an empty array of edges after the \ncreateUser\n mutation. To fix this, we would add a post-operation logic function that grabs the newly created user id, searches for the team with the name SlackAdmins and then issues a \naddToUserTeamsConnection\n mutation to associate the objects. This happens synchronously so by the time our servers return the payload will include an edge for the new connection.", 
            "title": "Post Operations"
        }, 
        {
            "location": "/custom-logic/post-operations/#managing-connections-in-post-operations", 
            "text": "For our slack app, we said we wanted to have the user automatically join the team as soon as the user was created. To keep our frontend efficient, we should be able to grab both the newly created user as well as the team in a single call from the mutation payload. For example look\nat the query below.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 mutation CreateUser($user: CreateUserInput!) {\n  createUser(input:$user) {\n    changedUser {\n      id\n      user\n      teams {\n        edges {\n          node {\n            id\n            name\n          }\n        }\n      }\n    }\n  }\n}   Without logic, this mutation would return an empty array of edges after the  createUser  mutation. To fix this, we would add a post-operation logic function that grabs the newly created user id, searches for the team with the name SlackAdmins and then issues a  addToUserTeamsConnection  mutation to associate the objects. This happens synchronously so by the time our servers return the payload will include an edge for the new connection.", 
            "title": "Managing Connections in Post Operations"
        }, 
        {
            "location": "/custom-logic/async-operations/", 
            "text": "Async Operations\n\n\nAfter the final post-operation function finishes, scaphold will immediately return the result to the client that made the request. This is great and keeps your APIs snappy for a friendly user experience. However, sometimes you have tasks that are either long-running or are completely independent of the client app. In our example, we wanted to send push notifications to everyone on the team as soon as the new member joins. This operation would involve paginating through a potentially long list of users and could take an indefinite amount of time.\n\n\nFor these situations use async functions! Async functions behave exactly the same as post-operation functions except Scaphold will not wait for a result after calling out to them. This makes them ideal for long standing tasks and other actions like logging.", 
            "title": "Async Operations"
        }, 
        {
            "location": "/custom-logic/async-operations/#async-operations", 
            "text": "After the final post-operation function finishes, scaphold will immediately return the result to the client that made the request. This is great and keeps your APIs snappy for a friendly user experience. However, sometimes you have tasks that are either long-running or are completely independent of the client app. In our example, we wanted to send push notifications to everyone on the team as soon as the new member joins. This operation would involve paginating through a potentially long list of users and could take an indefinite amount of time.  For these situations use async functions! Async functions behave exactly the same as post-operation functions except Scaphold will not wait for a result after calling out to them. This makes them ideal for long standing tasks and other actions like logging.", 
            "title": "Async Operations"
        }, 
        {
            "location": "/custom-logic/logs/", 
            "text": "Logs \n Examples\n\n\nThat wraps up our Logic tutorial! As you start using Logic, please not that you can see logs for each of your logic functions using the 'View Logs' button in the table dropdown when you click on a Pre or Post operation buttons. You can also easily enable and disable functions at any time.\n\n\nWe hope you enjoy Logic and we'd love to hear your feedback! As a final ode to our discussion of how you can use logic to help build Slack, we'd love for you to \njoin our Slack\n. It's an awesome community of people building cool applications with GraphQL and we'd love to see you there!\n\n\nExample Functions on Github\n\n\nFor example logic functions check out our github page: \nScaphold Logic Examples", 
            "title": "Logs & Examples"
        }, 
        {
            "location": "/custom-logic/logs/#logs-examples", 
            "text": "That wraps up our Logic tutorial! As you start using Logic, please not that you can see logs for each of your logic functions using the 'View Logs' button in the table dropdown when you click on a Pre or Post operation buttons. You can also easily enable and disable functions at any time.  We hope you enjoy Logic and we'd love to hear your feedback! As a final ode to our discussion of how you can use logic to help build Slack, we'd love for you to  join our Slack . It's an awesome community of people building cool applications with GraphQL and we'd love to see you there!", 
            "title": "Logs &amp; Examples"
        }, 
        {
            "location": "/custom-logic/logs/#example-functions-on-github", 
            "text": "For example logic functions check out our github page:  Scaphold Logic Examples", 
            "title": "Example Functions on Github"
        }, 
        {
            "location": "/persisted-queries/", 
            "text": "Persisted Queries\n\n\n\n\nTraditional GraphQL Request\n\n\n\n\n1\n2\n3\n4\n{\n\n  \nquery\n:\n \nquery getUser($id: ID!) { getUser(id: $id) { id username } }\n,\n\n  \nvariables\n:\n \n{\n \nid\n:\n \n123\n \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nGraphQL Request with Persisted Query\n\n\n\n\n1\n2\n3\n4\n{\n\n  \nid\n:\n \n1\n,\n\n  \nvariables\n:\n \n{\n \nid\n:\n \n123\n \n}\n\n\n}\n\n\n\n\n\n\n\nPersisted queries let you store queries on our servers so that your app doesn't have to send\nthe same query in each request. The immediate benefits of this are query whitelisting\nand reduced bandwidth usage. Mobile devices with limited connectivity benefit even more\nfrom persisted queries.", 
            "title": "Introduction"
        }, 
        {
            "location": "/persisted-queries/#persisted-queries", 
            "text": "Traditional GraphQL Request   1\n2\n3\n4 { \n   query :   query getUser($id: ID!) { getUser(id: $id) { id username } } , \n   variables :   {   id :   123   }  }     GraphQL Request with Persisted Query   1\n2\n3\n4 { \n   id :   1 , \n   variables :   {   id :   123   }  }    Persisted queries let you store queries on our servers so that your app doesn't have to send\nthe same query in each request. The immediate benefits of this are query whitelisting\nand reduced bandwidth usage. Mobile devices with limited connectivity benefit even more\nfrom persisted queries.", 
            "title": "Persisted Queries"
        }, 
        {
            "location": "/persisted-queries/getting-started/", 
            "text": "How Persisted Queries Work\n\n\nA traditional GraphQL request includes a request body that looks like the one to the right. This\nexample is relatively lightweight, but you can imagine that queries can get large quickly. When\nyou are building large applications, that bandwidth usage can add up and reducing it can\nhave very real impacts on your application's performance.\nThe goal of persisted queries is to transform the first query into the second query.\n\n\nTo make this work we need to create a mapping between the \nid\n \n1\n and the query\n\nquery getUser($id: ID!) { getUser(id: $id) { id username } }\n.\n\n\nMappings have the form\n\n\n{ [graphql-query]: \n ID \n }\n\n\nFor example, the mapping for our query to the right would look like this:\n\n\n{ \"query getUser($id: ID!) { getUser(id: $id) { id username } }\": 1 }\n\n\nOnce you create the mapping,\nyou can upload it to your server and then make requests using the query id instead of the full\nquery text. Scaphold makes it easy for your create and upload this mapping so you can\nstart reaping the benefits of persisted queries.\n\n\nGetting Started\n\n\nThe first step is to create the mapping from our graphql queries to their ids. To do this we\nwill use the \npersistgraphql\n npm package. \npersistgraphql\n expects that you store your\nqueries as \n.graphql\n files in your source. If you aren't already doing this, the first step\nis to move your queries out to their own \n.graphql\n files and then \nimport\n those queries from your\ncomponents.\n\n\nOnce you have your queries separated out into their own files then run these commands:\n\n\n1) \nnpm install -g persistgraphql\n\n\n2) \npersistgraphql \n projectdir \n\n\n3) This will generate an \nextracted_queries.json\n file that you will upload to Scaphold.\n\n\n\nYou can also point `persistgraphql` to a single `.graphql` file. Pointing it to a directory will\nrecursively pull queries out of every `.graphql` file.\n\n\n\n\nUploading Your Queries to Scaphold\n\n\nUploading your \nextracted_queries.json\n file to Scaphold is easy. Go to the GraphiQL tab in your\n\nScaphold\n portal and click \nPersisted Queries\n in the page header. This\nwill open a side panel where you can drop your \nextracted_queries.json\n file.\nWe will automatically store this mapping so our servers know what query to call for a\nparticular query id.\n\n\n\nWe automatically handle caching your queries in redis so you see the full speed benefits.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/persisted-queries/getting-started/#how-persisted-queries-work", 
            "text": "A traditional GraphQL request includes a request body that looks like the one to the right. This\nexample is relatively lightweight, but you can imagine that queries can get large quickly. When\nyou are building large applications, that bandwidth usage can add up and reducing it can\nhave very real impacts on your application's performance.\nThe goal of persisted queries is to transform the first query into the second query.  To make this work we need to create a mapping between the  id   1  and the query query getUser($id: ID!) { getUser(id: $id) { id username } } .  Mappings have the form  { [graphql-query]:   ID   }  For example, the mapping for our query to the right would look like this:  { \"query getUser($id: ID!) { getUser(id: $id) { id username } }\": 1 }  Once you create the mapping,\nyou can upload it to your server and then make requests using the query id instead of the full\nquery text. Scaphold makes it easy for your create and upload this mapping so you can\nstart reaping the benefits of persisted queries.", 
            "title": "How Persisted Queries Work"
        }, 
        {
            "location": "/persisted-queries/getting-started/#getting-started", 
            "text": "The first step is to create the mapping from our graphql queries to their ids. To do this we\nwill use the  persistgraphql  npm package.  persistgraphql  expects that you store your\nqueries as  .graphql  files in your source. If you aren't already doing this, the first step\nis to move your queries out to their own  .graphql  files and then  import  those queries from your\ncomponents.  Once you have your queries separated out into their own files then run these commands:  1)  npm install -g persistgraphql  2)  persistgraphql   projectdir   3) This will generate an  extracted_queries.json  file that you will upload to Scaphold.  \nYou can also point `persistgraphql` to a single `.graphql` file. Pointing it to a directory will\nrecursively pull queries out of every `.graphql` file.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/persisted-queries/getting-started/#uploading-your-queries-to-scaphold", 
            "text": "Uploading your  extracted_queries.json  file to Scaphold is easy. Go to the GraphiQL tab in your Scaphold  portal and click  Persisted Queries  in the page header. This\nwill open a side panel where you can drop your  extracted_queries.json  file.\nWe will automatically store this mapping so our servers know what query to call for a\nparticular query id.  \nWe automatically handle caching your queries in redis so you see the full speed benefits.", 
            "title": "Uploading Your Queries to Scaphold"
        }, 
        {
            "location": "/persisted-queries/querying-from-client/", 
            "text": "Add Persisted Queries To Apollo Client\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nimport\n \nqueryMap\n \nfrom\n \n\u2018\n.\n/\nextracted_queries\n.\njson\n\u2019\n;\n\n\nimport\n \n{\n \nPersistedQueryNetworkInterface\n \n}\n \nfrom\n \n\u2018\npersistgraphql\n\u2019\n;\n\n\nconst\n \nnetworkInterface\n \n=\n \nnew\n \nPersistedQueryNetworkInterface\n({\n\n  \nqueryMap\n,\n\n  \nuri\n:\n \napiUrl\n,\n\n  \nopts\n:\n \n{\n\n    \nheaders\n:\n \n{\n\n      \nAuthorization\n:\n \n \nscaphold\n \nauth\n \ntoken\n \n\n    \n},\n\n  \n},\n\n\n});\n\n\nconst\n \nclient\n \n=\n \nnew\n \nApolloClient\n({\n\n  \nnetworkInterface\n,\n\n\n});\n\n\n\n\n\n\n\nApollo Client comes with built in support for persisted queries. To enable it replace your\nnetwork interface with one that looks like this. This will automatically replace your query text\nwith the associated query id without any changes to your code. Scaphold will handle replacing\nthe id with the query text on the server.\n\n\nUsing Persisted Queries Without Apollo Client\n\n\nApollo Client makes it easy to use persisted queries but you're welcome to manage the queries\nyourself. All you need to do is replace the \n\"query\"\n property in each of your requests with\nthe associated \n\"id\"\n. Keep in mind though, that it's up to you to make sure that you have updated\nthe most recent version of your queries to our servers.\n\n\n\nSee the 'How Persisted Queries Work' section above for an example request body.", 
            "title": "Querying From Client"
        }, 
        {
            "location": "/persisted-queries/querying-from-client/#add-persisted-queries-to-apollo-client", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 import   queryMap   from   \u2018 . / extracted_queries . json \u2019 ;  import   {   PersistedQueryNetworkInterface   }   from   \u2018 persistgraphql \u2019 ;  const   networkInterface   =   new   PersistedQueryNetworkInterface ({ \n   queryMap , \n   uri :   apiUrl , \n   opts :   { \n     headers :   { \n       Authorization :     scaphold   auth   token   \n     }, \n   },  });  const   client   =   new   ApolloClient ({ \n   networkInterface ,  });    Apollo Client comes with built in support for persisted queries. To enable it replace your\nnetwork interface with one that looks like this. This will automatically replace your query text\nwith the associated query id without any changes to your code. Scaphold will handle replacing\nthe id with the query text on the server.", 
            "title": "Add Persisted Queries To Apollo Client"
        }, 
        {
            "location": "/persisted-queries/querying-from-client/#using-persisted-queries-without-apollo-client", 
            "text": "Apollo Client makes it easy to use persisted queries but you're welcome to manage the queries\nyourself. All you need to do is replace the  \"query\"  property in each of your requests with\nthe associated  \"id\" . Keep in mind though, that it's up to you to make sure that you have updated\nthe most recent version of your queries to our servers.  \nSee the 'How Persisted Queries Work' section above for an example request body.", 
            "title": "Using Persisted Queries Without Apollo Client"
        }, 
        {
            "location": "/files/", 
            "text": "Files\n\n\n\n\n\n  All Scaphold APIs come with blob storage by default and all paid apps will be served files through a globally distributed CDN.\n\n\n\n\n\nFile support in Scaphold is cooked into your schema. That means that any type that implements the \nBlob\n\ninterface can be associated with a file stored in our distributed blob storage. When you create\nan app, we start you off with both the \nBlob\n interface as well as a \nFile\n type. The \nFile\n type implements\n\nBlob\n and \nNode\n and thus can both be connected to other types in your schema via Connection fields as well\nas handle file uploads and downloads.", 
            "title": "Introduction"
        }, 
        {
            "location": "/files/#files", 
            "text": "All Scaphold APIs come with blob storage by default and all paid apps will be served files through a globally distributed CDN.   File support in Scaphold is cooked into your schema. That means that any type that implements the  Blob \ninterface can be associated with a file stored in our distributed blob storage. When you create\nan app, we start you off with both the  Blob  interface as well as a  File  type. The  File  type implements Blob  and  Node  and thus can both be connected to other types in your schema via Connection fields as well\nas handle file uploads and downloads.", 
            "title": "Files"
        }, 
        {
            "location": "/files/uploading/", 
            "text": "Uploading Files\n\n\n\n\nExample file upload\nMark Zuckerberg's user ID: \nVXNlcjoxMA==\n\n\n\n\n1\n2\n3\n4\n5\ncurl -v https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type:multipart/form-data\n \n\\\n\n  -F \nquery=mutation CreateFile($input: CreateFileInput!) { createFile(input: $input) { changedFile { id name blobMimeType blobUrl user { id username } } } }\n \n\\\n\n  -F \nvariables={ \ninput\n: { \nname\n: \nProfile Picture\n, \nuserId\n: \nVXNlcjoxMA==\n, \nblobFieldName\n: \nmyBlobField\n } };type=application/json\n \n\\\n\n  -F \nmyBlobField\n=\n@mark-zuckerberg.jpg\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n// You must also install these npm modules:\n\n\n// npm install --save form-data\n\n\n// npm install --save node-fetch\n\n\n\nvar\n \nfetch\n \n=\n \nrequire\n(\nnode-fetch\n);\n\n\nvar\n \nFormData\n \n=\n \nrequire\n(\nform-data\n);\n\n\nvar\n \nfs\n \n=\n \nrequire\n(\nfs\n);\n\n\n\nvar\n \nform\n \n=\n \nnew\n \nFormData\n();\n\n\nform\n.\nappend\n(\nquery\n,\n \n`\n\n\n  mutation CreateFile($input: CreateFileInput!) {\n\n\n    createFile(input: $input) {\n\n\n      changedFile {\n\n\n        id\n\n\n        name\n\n\n        blobMimeType\n\n\n        blobUrl\n\n\n        user {\n\n\n          id\n\n\n          username\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n`\n);\n\n\nform\n.\nappend\n(\nvariables\n,\n \nJSON\n.\nstringify\n({\n\n  \ninput\n:\n \n{\n\n    \nname\n:\n \nMark Zuck Profile Picture\n,\n\n    \nuserId\n:\n \nVXNlcjoxMA==\n,\n\n    \nblobFieldName\n:\n \nmyBlobField\n\n  \n}\n\n\n}));\n\n\n// The file\ns key matches the value of the field `blobFieldName` in the variables\n\n\nform\n.\nappend\n(\nmyBlobField\n,\n \nfs\n.\ncreateReadStream\n(\n./mark-zuckerberg.jpg\n));\n\n\n\nfetch\n(\nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n \n{\n\n  \nmethod\n:\n \nPOST\n,\n\n  \nbody\n:\n \nform\n\n\n}).\nthen\n(\nfunction\n(\nres\n)\n \n{\n\n  \nreturn\n \nres\n.\ntext\n();\n\n\n}).\nthen\n(\nfunction\n(\nbody\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nbody\n);\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n{\n\n  \ndata\n:\n \n{\n\n    \ncreateFile\n:\n \n{\n\n      \nchangedFile\n:\n \n{\n\n        \nid\n:\n \nRmlsZTo5\n,\n\n        \nname\n:\n \nMark Zuck\ns Profile Picture\n,\n\n        \nblobMimeType\n:\n \nimage/jpeg\n,\n\n        \nblobUrl\n:\n \nhttps://s3-us-west-2.amazonaws.com/production.us-west-2.scaphold.v2.customer/44be086f-bf33-4997-8136-9c01d99a88c4/data/2fb4b11d-cef9-465d-9ad6-e3d8b693f121/2b86488a-7114-4071-9e30-157855475eb7?AWSAccessKeyId=AKIAJIC3JY2ICINJH2OQ\nExpires=1481686711\nSignature=pa4QbkPCk%2BXlgSrKBWcRKsEckSs%3D\n,\n\n        \nuser\n:\n \n{\n\n          \nid\n:\n \nVXNlcjoxMA==\n,\n\n          \nusername\n:\n \nMark Zuckerberg\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nIf you are using react-native use this\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n// You must also install these npm modules:\n\n\n// npm install --save react-native-fetch-blob\n\n\n// react-native link react-native-fetch-blob\n\n\nimport\n \nRNFetchBlob\n \nfrom\n \nreact-native-fetch-blob\n;\n\n\n\nRNFetchBlob\n.\nfetch\n(\n\n  \nPOST\n,\n\n  \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \n{\n\n    \nAuthorization\n \n:\n \nBearer \n \n+\n \nscapholdAuthToken\n,\n\n    \nContent-Type\n \n:\n \nmultipart/form-data\n,\n\n  \n},\n\n  \n[\n\n    \n{\n\n      \nname\n \n:\n \nquery\n,\n\n      \ndata\n \n:\n \n`\n\n\n        mutation CreateFile($input: CreateFileInput!) {\n\n\n          createFile(input: $input) {\n\n\n            changedFile {\n\n\n              id\n\n\n              blobMimeType\n\n\n              blobUrl\n\n\n              user {\n\n\n                id\n\n\n              }\n\n\n            }\n\n\n          }\n\n\n        }\n\n\n      `\n\n    \n},\n\n    \n{\n\n      \nname\n \n:\n \nvariables\n,\n\n      \ndata\n \n:\n \nJSON\n.\nstringify\n({\n\n        \ninput\n:\n \n{\n\n          \nname\n:\n \nMark Zuck Profile Picture\n,\n\n          \nuserId\n:\n \nVXNlcjoxMA==\n,\n\n          \nblobFieldName\n:\n \nmyBlobField\n\n        \n}\n\n      \n})\n\n    \n},\n\n    \n{\n\n      \nname\n \n:\n \nmyBlobField\n,\n\n      \nfilename\n \n:\n \nprofile\n,\n\n      \ndata\n:\n \nRNFetchBlob\n.\nwrap\n(\nfilePath\n),\n\n    \n},\n\n  \n]\n\n\n);\n\n\n\n\n\n\n\nUploading files is simple. All you need to do is attach the file to a multipart/form-data request\nand point to it using the \nblobFieldName\n attribute in the \nBlob\n implemented type's input object.\n\n\nAll types that implement \nBlob\n will receive an additional input field called \nblobFieldName\n.", 
            "title": "Uploading"
        }, 
        {
            "location": "/files/uploading/#uploading-files", 
            "text": "Example file upload\nMark Zuckerberg's user ID:  VXNlcjoxMA==   1\n2\n3\n4\n5 curl -v https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type:multipart/form-data   \\ \n  -F  query=mutation CreateFile($input: CreateFileInput!) { createFile(input: $input) { changedFile { id name blobMimeType blobUrl user { id username } } } }   \\ \n  -F  variables={  input : {  name :  Profile Picture ,  userId :  VXNlcjoxMA== ,  blobFieldName :  myBlobField  } };type=application/json   \\ \n  -F  myBlobField = @mark-zuckerberg.jpg    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 // You must also install these npm modules:  // npm install --save form-data  // npm install --save node-fetch  var   fetch   =   require ( node-fetch );  var   FormData   =   require ( form-data );  var   fs   =   require ( fs );  var   form   =   new   FormData ();  form . append ( query ,   `    mutation CreateFile($input: CreateFileInput!) {      createFile(input: $input) {        changedFile {          id          name          blobMimeType          blobUrl          user {            id            username          }        }      }    }  ` );  form . append ( variables ,   JSON . stringify ({ \n   input :   { \n     name :   Mark Zuck Profile Picture , \n     userId :   VXNlcjoxMA== , \n     blobFieldName :   myBlobField \n   }  }));  // The file s key matches the value of the field `blobFieldName` in the variables  form . append ( myBlobField ,   fs . createReadStream ( ./mark-zuckerberg.jpg ));  fetch ( https://us-west-2.api.scaphold.io/graphql/scaphold-graphql ,   { \n   method :   POST , \n   body :   form  }). then ( function ( res )   { \n   return   res . text ();  }). then ( function ( body )   { \n   console . log ( body );  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 { \n   data :   { \n     createFile :   { \n       changedFile :   { \n         id :   RmlsZTo5 , \n         name :   Mark Zuck s Profile Picture , \n         blobMimeType :   image/jpeg , \n         blobUrl :   https://s3-us-west-2.amazonaws.com/production.us-west-2.scaphold.v2.customer/44be086f-bf33-4997-8136-9c01d99a88c4/data/2fb4b11d-cef9-465d-9ad6-e3d8b693f121/2b86488a-7114-4071-9e30-157855475eb7?AWSAccessKeyId=AKIAJIC3JY2ICINJH2OQ Expires=1481686711 Signature=pa4QbkPCk%2BXlgSrKBWcRKsEckSs%3D , \n         user :   { \n           id :   VXNlcjoxMA== , \n           username :   Mark Zuckerberg \n         } \n       } \n     } \n   }  }     If you are using react-native use this    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47 // You must also install these npm modules:  // npm install --save react-native-fetch-blob  // react-native link react-native-fetch-blob  import   RNFetchBlob   from   react-native-fetch-blob ;  RNFetchBlob . fetch ( \n   POST , \n   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   { \n     Authorization   :   Bearer    +   scapholdAuthToken , \n     Content-Type   :   multipart/form-data , \n   }, \n   [ \n     { \n       name   :   query , \n       data   :   `          mutation CreateFile($input: CreateFileInput!) {            createFile(input: $input) {              changedFile {                id                blobMimeType                blobUrl                user {                  id                }              }            }          }        ` \n     }, \n     { \n       name   :   variables , \n       data   :   JSON . stringify ({ \n         input :   { \n           name :   Mark Zuck Profile Picture , \n           userId :   VXNlcjoxMA== , \n           blobFieldName :   myBlobField \n         } \n       }) \n     }, \n     { \n       name   :   myBlobField , \n       filename   :   profile , \n       data :   RNFetchBlob . wrap ( filePath ), \n     }, \n   ]  );    Uploading files is simple. All you need to do is attach the file to a multipart/form-data request\nand point to it using the  blobFieldName  attribute in the  Blob  implemented type's input object.  All types that implement  Blob  will receive an additional input field called  blobFieldName .", 
            "title": "Uploading Files"
        }, 
        {
            "location": "/files/querying/", 
            "text": "Querying Files\n\n\n\n\nExample of querying for a file\nFile ID: \nRmlsZTo5\n\n\n\n\n1\n2\n3\n4\ncurl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql \n\\\n\n  -H \nContent-Type: application/json\n \n\\\n\n  -d \n{ \nquery\n: \nquery GetFile { getFile(id: \\\nRmlsZTo5\\\n) { id name blobMimeType blobUrl user { id username } } }\n,\n\n\n    \nvariables\n: {} }\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nvar\n \nrequest\n \n=\n \nrequire\n(\nrequest\n);\n\n\n\nvar\n \ndata\n \n=\n \n{\n\n  \nquery\n:\n \n`\n\n\n    query GetFile {\n\n\n      getFile(id: \nRmlsZTo5\n) {\n\n\n        id\n\n\n        name\n\n\n        blobMimeType\n\n\n        blobUrl\n\n\n        user {\n\n\n          id\n\n\n          username\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  `\n,\n\n  \nvariables\n:\n \n{}\n\n\n}\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \nfunction\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n    \nconsole\n.\nlog\n(\nresponse\n.\nstatusCode\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nThe above command returns an object structured like this:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n{\n\n  \ndata\n:\n \n{\n\n    \ngetFile\n:\n \n{\n\n      \nid\n:\n \nRmlsZTo5\n,\n\n      \nname\n:\n \nMark Zuck\ns Profile Picture\n,\n\n      \nblobMimeType\n:\n \nimage/jpeg\n,\n\n      \nblobUrl\n:\n \nhttps://s3-us-west-2.amazonaws.com/production.us-west-2.scaphold.v2.customer/44be086f-bf33-4997-8136-9c01d99a88c4/data/2fb4b11d-cef9-465d-9ad6-e3d8b693f121/2b86488a-7114-4071-9e30-157855475eb7?AWSAccessKeyId=AKIAJIC3JY2ICINJH2OQ\nExpires=1481690209\nSignature=icwTcNl%2B%2BTwQy8Ar6jLuquztwu0%3D\n,\n\n      \nuser\n:\n \n{\n\n        \nid\n:\n \nVXNlcjoxMA==\n,\n\n        \nusername\n:\n \nMark Zuckerberg\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nQuerying files acts the same as other types. All types that implement \nBlob\n have a field \nblobUrl\n and \nblobMimeType\n\nthat are automatically managed by Scaphold. The \nblobUrl\n is a pre-signed URL that points to your file in a private\nblob store hosted on Amazon S3. If youre app is on a paid tier, all pre-signed URLs will be served by\na globally distributed CDN hosted by Amazon CloudFront.", 
            "title": "Querying"
        }, 
        {
            "location": "/files/querying/#querying-files", 
            "text": "Example of querying for a file\nFile ID:  RmlsZTo5   1\n2\n3\n4 curl -X POST https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  \\ \n  -H  Content-Type: application/json   \\ \n  -d  {  query :  query GetFile { getFile(id: \\ RmlsZTo5\\ ) { id name blobMimeType blobUrl user { id username } } } ,       variables : {} }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 var   request   =   require ( request );  var   data   =   { \n   query :   `      query GetFile {        getFile(id:  RmlsZTo5 ) {          id          name          blobMimeType          blobUrl          user {            id            username          }        }      }    ` , \n   variables :   {}  }  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/scaphold-graphql , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   function ( error ,   response ,   body )   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n     console . log ( response . statusCode ); \n   }  });     The above command returns an object structured like this:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 { \n   data :   { \n     getFile :   { \n       id :   RmlsZTo5 , \n       name :   Mark Zuck s Profile Picture , \n       blobMimeType :   image/jpeg , \n       blobUrl :   https://s3-us-west-2.amazonaws.com/production.us-west-2.scaphold.v2.customer/44be086f-bf33-4997-8136-9c01d99a88c4/data/2fb4b11d-cef9-465d-9ad6-e3d8b693f121/2b86488a-7114-4071-9e30-157855475eb7?AWSAccessKeyId=AKIAJIC3JY2ICINJH2OQ Expires=1481690209 Signature=icwTcNl%2B%2BTwQy8Ar6jLuquztwu0%3D , \n       user :   { \n         id :   VXNlcjoxMA== , \n         username :   Mark Zuckerberg \n       } \n     } \n   }  }    Querying files acts the same as other types. All types that implement  Blob  have a field  blobUrl  and  blobMimeType \nthat are automatically managed by Scaphold. The  blobUrl  is a pre-signed URL that points to your file in a private\nblob store hosted on Amazon S3. If youre app is on a paid tier, all pre-signed URLs will be served by\na globally distributed CDN hosted by Amazon CloudFront.", 
            "title": "Querying Files"
        }, 
        {
            "location": "/integrations/", 
            "text": "Integrations\n\n\n\n\n\n  \nTip\n: To understand how many of these integrations work in detail, and what new queries and mutations your API will have after enabling a particular integration, you can \nclick on an integration panel\n in the Integrations Portal to find out.\n\n\n\n\n\nUse Scaphold's integration infrastructure to tie third-party services into your API. When you add an integration, we will automatically update your API with new functionality.\nIntegrations range in purpose. Want notifications? Add iOS Push. Want payments? Integrate Stripe. Need social auth? Add it with Auth0. Our collection of integrations is always expanding so please let us know if you have any specific requests.\n\n\nIntegrations come in many shapes and sizes. Some integrations like Slack and Webhooks are powered by events in your API while others like Mailgun will expose their functionality by adding queries and mutations to your GraphQL API.\n\n\nWe've got some exciting new integrations coming out soon! Please \nlet us know\n if you have any specific requests.", 
            "title": "Introduction"
        }, 
        {
            "location": "/integrations/#integrations", 
            "text": "Tip : To understand how many of these integrations work in detail, and what new queries and mutations your API will have after enabling a particular integration, you can  click on an integration panel  in the Integrations Portal to find out.   Use Scaphold's integration infrastructure to tie third-party services into your API. When you add an integration, we will automatically update your API with new functionality.\nIntegrations range in purpose. Want notifications? Add iOS Push. Want payments? Integrate Stripe. Need social auth? Add it with Auth0. Our collection of integrations is always expanding so please let us know if you have any specific requests.  Integrations come in many shapes and sizes. Some integrations like Slack and Webhooks are powered by events in your API while others like Mailgun will expose their functionality by adding queries and mutations to your GraphQL API.  We've got some exciting new integrations coming out soon! Please  let us know  if you have any specific requests.", 
            "title": "Integrations"
        }, 
        {
            "location": "/integrations/email/", 
            "text": "Email\n\n\nUse \nMailgun\n to send and manage email from within your application. Bind emails to events to automate your workflow.\n\n\n\n\nCreate a free \nMailgun\n account.\n\n\nAdd the Mailgun integration and enter your API key and domain name in Scaphold's Integrations Portal.\n\n\nStart sending emails and managing mailing lists from your Scaphold API!", 
            "title": "Email"
        }, 
        {
            "location": "/integrations/email/#email", 
            "text": "Use  Mailgun  to send and manage email from within your application. Bind emails to events to automate your workflow.   Create a free  Mailgun  account.  Add the Mailgun integration and enter your API key and domain name in Scaphold's Integrations Portal.  Start sending emails and managing mailing lists from your Scaphold API!", 
            "title": "Email"
        }, 
        {
            "location": "/integrations/monitoring/", 
            "text": "Monitoring\n\n\nUse \nApollo Optics\n to add in-depth analytics for your API to understand how to optimize your queries.\n\n\n\n\nCreate an \nApollo Optics\n account.\n\n\nAdd the Apollo Optics integration and enter your API key in Scaphold's Integration Portal.\n\n\n\n\nEvery request you make will send information about how your data is being fetche, so you can view the performance of your all your requests through the comprehensive Optics dashboard.", 
            "title": "Monitoring"
        }, 
        {
            "location": "/integrations/monitoring/#monitoring", 
            "text": "Use  Apollo Optics  to add in-depth analytics for your API to understand how to optimize your queries.   Create an  Apollo Optics  account.  Add the Apollo Optics integration and enter your API key in Scaphold's Integration Portal.   Every request you make will send information about how your data is being fetche, so you can view the performance of your all your requests through the comprehensive Optics dashboard.", 
            "title": "Monitoring"
        }, 
        {
            "location": "/integrations/passwordless/", 
            "text": "Passwordless Auth\n\n\n\n\nWe've built a little playground for you to test out passwordless auth using Twitter Digits in an iOS app.\n\nView on GitHub\n\n\nPlease reference this example if you're unfamiliar with how to obtain OAuth Echo Headers: \nSample Code\n\n\n\n\nUse \nTwitter Digits\n to extend your app's authentication capabilities, and log in your users with passwordless authentication using their phone number.\n\n\n\n\n\n\nCreate a free Twitter Digits account online using \nFabric\n. This is the account management platform that Twitter uses to manage your Twitter integrations for your apps.\n\n\n\n\n\n\nOnce you've done so and installed Digits to your app, follow the steps on the \nDigits Sandbox\n to configure your native app to test out the functionality in debug mode.\n\n\n\n\n\n\nWhen you have this set up, you'll need to obtain \nOAuth Echo Headers\n:\n\n\n1\nimg src=\nimages/integrations/Digits_Oauth_Echo_Headers.png\n alt=\nDigits OAuth Echo Headers\n\n\n\n\n\n\n\n\n\n\n\nNow you can make a request with these header values with the \nnew mutation called\n \nloginUserWithDigits\n that will allow you to log in a user with this integration.\n\n\n1\n2\n3\n4\n5\nIt will return a **JWT token that you need to include in your future requests** as the bearer token for your Authorization header so that we can authenticate this particular logged in user.\n\nThis works across authentication mechanisms on Scaphold, so you can link any number of social or passwordless authentication flows.\n\n\nimg src=\nimages/integrations/Login_User_With_Digits.png\n alt=\nloginUserWithDigits mutation.\n /", 
            "title": "Passwordless Auth"
        }, 
        {
            "location": "/integrations/passwordless/#passwordless-auth", 
            "text": "We've built a little playground for you to test out passwordless auth using Twitter Digits in an iOS app. View on GitHub  Please reference this example if you're unfamiliar with how to obtain OAuth Echo Headers:  Sample Code   Use  Twitter Digits  to extend your app's authentication capabilities, and log in your users with passwordless authentication using their phone number.    Create a free Twitter Digits account online using  Fabric . This is the account management platform that Twitter uses to manage your Twitter integrations for your apps.    Once you've done so and installed Digits to your app, follow the steps on the  Digits Sandbox  to configure your native app to test out the functionality in debug mode.    When you have this set up, you'll need to obtain  OAuth Echo Headers :  1 img src= images/integrations/Digits_Oauth_Echo_Headers.png  alt= Digits OAuth Echo Headers      Now you can make a request with these header values with the  new mutation called   loginUserWithDigits  that will allow you to log in a user with this integration.  1\n2\n3\n4\n5 It will return a **JWT token that you need to include in your future requests** as the bearer token for your Authorization header so that we can authenticate this particular logged in user.\n\nThis works across authentication mechanisms on Scaphold, so you can link any number of social or passwordless authentication flows. img src= images/integrations/Login_User_With_Digits.png  alt= loginUserWithDigits mutation.  /", 
            "title": "Passwordless Auth"
        }, 
        {
            "location": "/integrations/push/", 
            "text": "Push Notifications\n\n\nAdd \niOS\n or \nAndroid\n push notifications in an instant.\n\n\n\n\nFollow these tutorials to get set up on each platform:\n\n\niOS\n\n\nAndroid\n\n\n\n\n\n\nAdd the push integration for the platform of your choice and upload the appropriate keys through our \nIntegrations Portal\n.\n\n\nImmediately get access to iOS or Android push notifications via your app's GraphQL API.\n\n\n\n\nOnce you've set up your integration, you can start managing device tokens across platforms and send push notification messages to valid device tokens and channels.\n\n\nFollow along with \nthis guide on how to send push notifications with your GraphQL API\n\nso you can start sending push notifications right away.\n\n\nWe've also set up a couple boilerplates for you to help you get started on each platform:\n\n\n\n\n\n\niOS\n\n\n\n\n\n\nAndroid", 
            "title": "Push Notifications"
        }, 
        {
            "location": "/integrations/push/#push-notifications", 
            "text": "Add  iOS  or  Android  push notifications in an instant.   Follow these tutorials to get set up on each platform:  iOS  Android    Add the push integration for the platform of your choice and upload the appropriate keys through our  Integrations Portal .  Immediately get access to iOS or Android push notifications via your app's GraphQL API.   Once you've set up your integration, you can start managing device tokens across platforms and send push notification messages to valid device tokens and channels.  Follow along with  this guide on how to send push notifications with your GraphQL API \nso you can start sending push notifications right away.  We've also set up a couple boilerplates for you to help you get started on each platform:    iOS    Android", 
            "title": "Push Notifications"
        }, 
        {
            "location": "/integrations/search/setup/", 
            "text": "Search\n\n\nSee the full tutorial\n\n\nSetup the Algolia integration\n\n\nThe Algolia integration lets you instantly add search capabilities to your API. As soon as you enable the integration and select the types\nthat you would like indexed, we immediately push your data to Algolia. Scaphold will then make sure that your data held on our servers\nis kept in sync with your data on algolia.\n\n\n\n\nCreate a free \nAlgolia\n account. This will help you manage your search indices and monitor your usage. Once you've created your account, you'll receive an Application ID and an API Key.\n\n\n\n\n\n        You can share a single algolia account for multiple apps. Each index we create for you is unique to the app and type being indexed.\n\n\n\n\n\n\nConfigure \nAlgolia\n in Scaphold from the \nIntegrations Portal\n and select the checkboxes in the popup to index data of that particular type.\n\n\n\n\n\n\n\n\n\n\nAs soon as you enable search on a particular type, Scaphold will automatically index each object in your API\nas well as ensure that each create, update, and delete mutation is mirrored to Algolia. This makes id dead simple to combine\nthe best of Algolia with the best of GraphQL and Scaphold.\n\n\n\n\n\n\nYou can use the Algolia portal to fine tune your indexes to improve the search experience for your apps.", 
            "title": "Setup"
        }, 
        {
            "location": "/integrations/search/setup/#search", 
            "text": "See the full tutorial", 
            "title": "Search"
        }, 
        {
            "location": "/integrations/search/setup/#setup-the-algolia-integration", 
            "text": "The Algolia integration lets you instantly add search capabilities to your API. As soon as you enable the integration and select the types\nthat you would like indexed, we immediately push your data to Algolia. Scaphold will then make sure that your data held on our servers\nis kept in sync with your data on algolia.   Create a free  Algolia  account. This will help you manage your search indices and monitor your usage. Once you've created your account, you'll receive an Application ID and an API Key.   \n        You can share a single algolia account for multiple apps. Each index we create for you is unique to the app and type being indexed.   Configure  Algolia  in Scaphold from the  Integrations Portal  and select the checkboxes in the popup to index data of that particular type.      As soon as you enable search on a particular type, Scaphold will automatically index each object in your API\nas well as ensure that each create, update, and delete mutation is mirrored to Algolia. This makes id dead simple to combine\nthe best of Algolia with the best of GraphQL and Scaphold.    You can use the Algolia portal to fine tune your indexes to improve the search experience for your apps.", 
            "title": "Setup the Algolia integration"
        }, 
        {
            "location": "/integrations/search/querying/", 
            "text": "Querying Algolia\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nquery SearchNotes($searchTerm: String!) {\n  viewer {\n    searchAlgoliaNotes(query: $searchTerm, hitsPerPage: 10) {\n      nbHits       # how many hits\n      nbPages      # how many pages\n      page         # the current page\n      hits {\n        objectID\n        _highlightResult       # useful for clientside auto-suggest\n        node {                 # the Note object.\n          id\n          content\n          author {             # we can still traverse connections\n            id                 # even though `User` is not indexed.\n            username\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nQuerying Algolia through your Scaphold API is super simple. For every type that you index you will receive a \nsearchAlgoliaX\n query under the \nviewer\n in your API.\n\n\nFor example, lets say we were building a note taking app like Evernote. A bare bones version of our app might include the types \nUser\n and \nNote\n. In order to enable our users to search notes, we would turn on the Algolia integration and choose the \nNote\n type to be indexed. As soon as we turn on Algolia for the \nNote\n type we would be able to issue a query like that seen to the right.\n\n\n\n\nNote how we are asking for the note's author despite not indexing our \nUser\n type. When you let\nScaphold manage your search data we are able to combine search with the connection in your GraphQL schema.\n\n\n\n\nThese commands will be the same as before; however you now have a \nnew query for each indexed type under Viewer\n that will allow you to search for query terms along with optional parameters.", 
            "title": "Querying"
        }, 
        {
            "location": "/integrations/search/querying/#querying-algolia", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 query SearchNotes($searchTerm: String!) {\n  viewer {\n    searchAlgoliaNotes(query: $searchTerm, hitsPerPage: 10) {\n      nbHits       # how many hits\n      nbPages      # how many pages\n      page         # the current page\n      hits {\n        objectID\n        _highlightResult       # useful for clientside auto-suggest\n        node {                 # the Note object.\n          id\n          content\n          author {             # we can still traverse connections\n            id                 # even though `User` is not indexed.\n            username\n          }\n        }\n      }\n    }\n  }\n}   Querying Algolia through your Scaphold API is super simple. For every type that you index you will receive a  searchAlgoliaX  query under the  viewer  in your API.  For example, lets say we were building a note taking app like Evernote. A bare bones version of our app might include the types  User  and  Note . In order to enable our users to search notes, we would turn on the Algolia integration and choose the  Note  type to be indexed. As soon as we turn on Algolia for the  Note  type we would be able to issue a query like that seen to the right.   Note how we are asking for the note's author despite not indexing our  User  type. When you let\nScaphold manage your search data we are able to combine search with the connection in your GraphQL schema.   These commands will be the same as before; however you now have a  new query for each indexed type under Viewer  that will allow you to search for query terms along with optional parameters.", 
            "title": "Querying Algolia"
        }, 
        {
            "location": "/integrations/social/setup/", 
            "text": "Social Auth\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# Quick start. Use Auth0 Lock or native SDKs and an Auth0 client SDK to create an idToken.\n# Then use the loginWithAuth0 mutation to create/associate social tokens with scaphold users.\n\nmutation Login($token:LoginUserWithAuth0Input!) {\n  loginUserWithAuth0(input:$token) {\n    user {\n      id\n      username\n      createdAt\n    }\n  }\n}\n\n# Variables\n{\n  \ntoken\n: {\n    \nidToken\n:  \nidToken\n\n  }\n}\n\n\n\n\n\n\nUse \nAuth0\n to extend your app's login and registration flow painlessly through your favorite social authentication services.\n\n\nSetup\n\n\n\n\n\n\nCreate a free \nAuth0\n account. This will help you manage your app credentials like client IDs and secrets for your OAuth providers. By connecting your apps on your social accounts like Facebook, Google, and Twitter, you'll then have the correct account credentials to utilize these services for your authentication flow.\n\n\n1\nimg src=\nimages/integrations/Configure_Auth0_Account.png\n alt=\nConfigure your Auth0 apps.\n\n\n\n\n\n\n\n\n\n\n\nConfigure Auth0 in Scaphold from the \nIntegrations Portal\n to include the OAuth providers that you plan to use for your app. This will enable 3 new mutations \nloginUserWithAuth0\n, \nloginWithAuth0Lock\n, and \nloginWithAuth0Social\n that you can use to authenticate users.\n\n\n\n\n\n\nNote\n If you are using Auth0 Lock then use \nloginWithAuth0\n not \nloginWithAuth0Lock\n. \nloginWithAuth0\n is a simpler workflow and \nloginWithAuth0Lock\n only remains for backwards compatibility and will be deprecated.", 
            "title": "Setup"
        }, 
        {
            "location": "/integrations/social/setup/#social-auth", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 # Quick start. Use Auth0 Lock or native SDKs and an Auth0 client SDK to create an idToken.\n# Then use the loginWithAuth0 mutation to create/associate social tokens with scaphold users.\n\nmutation Login($token:LoginUserWithAuth0Input!) {\n  loginUserWithAuth0(input:$token) {\n    user {\n      id\n      username\n      createdAt\n    }\n  }\n}\n\n# Variables\n{\n   token : {\n     idToken :   idToken \n  }\n}   Use  Auth0  to extend your app's login and registration flow painlessly through your favorite social authentication services.", 
            "title": "Social Auth"
        }, 
        {
            "location": "/integrations/social/setup/#setup", 
            "text": "Create a free  Auth0  account. This will help you manage your app credentials like client IDs and secrets for your OAuth providers. By connecting your apps on your social accounts like Facebook, Google, and Twitter, you'll then have the correct account credentials to utilize these services for your authentication flow.  1 img src= images/integrations/Configure_Auth0_Account.png  alt= Configure your Auth0 apps.      Configure Auth0 in Scaphold from the  Integrations Portal  to include the OAuth providers that you plan to use for your app. This will enable 3 new mutations  loginUserWithAuth0 ,  loginWithAuth0Lock , and  loginWithAuth0Social  that you can use to authenticate users.    Note  If you are using Auth0 Lock then use  loginWithAuth0  not  loginWithAuth0Lock .  loginWithAuth0  is a simpler workflow and  loginWithAuth0Lock  only remains for backwards compatibility and will be deprecated.", 
            "title": "Setup"
        }, 
        {
            "location": "/integrations/social/login-with-native/", 
            "text": "Login using native SDKs\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n# The loginWithAuth0Social mutation is a helper that you can use directly with native social SDKs.\n# I.E. you do not need to use an Auth0 SDK to generate an idToken.\n# You can also use an Auth0 SDK and the `loginWithAuth0` mutation but this requires one more step on your side.\n\nmutation Login($token:LoginUserWithAuth0SocialInput!) {\n  loginUserWithAuth0Social(input:$token) {\n    token\n    user {\n      id\n      username\n    }\n  }\n}\n\n\n\n\n\n\nIf you are using a native social SDK such as the \nFacebook SDK for React Native\n, use the SDK to generate an access token\nand then use the \nloginUserWithAuth0Social\n mutation to link the FB account with your scaphold user.\n\n\nAfter Scaphold verifies the access token with the OAuth provider (i.e. Facebook), we'll pass back the \nJSON Web Token (JWT)\n that you can add to your authorization header for future requests.\nScaphold looks for a token under the \nAuthorization\n key with the format \nBearer \ntoken\n in your request headers and uses that to authenticate the user. It looks like this:\n\n\n\n\n\n\nThe preferred way of logging in with Auth0 Lock is to use the \nloginWithAuth0\n mutation. For backwards compatibility,\nthe \nloginWithAuth0Lock\n mutation will remain but \nloginWithAuth0\n is easier to use.\n\n\nTo use \nloginWithAuth0Lock\n make sure you have installed Lock version \n^10.9.1\n. Auth0 introduced\na few non-backwards compatible changes to their API in the beginning of 2017. It must have been\na new years resolution..\n\n\n\n\nIn addition, if you're logged in and make a request to any of the \nloginUserWithAuth0\n mutations but with a different social provider (i.e. Google),\nScaphold will link your two accounts together. Now, you'll have access to both Facebook and Google information using Facebook's and Google's account credentials.\n\n\n\n\n\n  **UPDATE:** Mutation name is now called `loginUserWithAuthOSocial`", 
            "title": "Login With Native SDKs"
        }, 
        {
            "location": "/integrations/social/login-with-native/#login-using-native-sdks", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 # The loginWithAuth0Social mutation is a helper that you can use directly with native social SDKs.\n# I.E. you do not need to use an Auth0 SDK to generate an idToken.\n# You can also use an Auth0 SDK and the `loginWithAuth0` mutation but this requires one more step on your side.\n\nmutation Login($token:LoginUserWithAuth0SocialInput!) {\n  loginUserWithAuth0Social(input:$token) {\n    token\n    user {\n      id\n      username\n    }\n  }\n}   If you are using a native social SDK such as the  Facebook SDK for React Native , use the SDK to generate an access token\nand then use the  loginUserWithAuth0Social  mutation to link the FB account with your scaphold user.  After Scaphold verifies the access token with the OAuth provider (i.e. Facebook), we'll pass back the  JSON Web Token (JWT)  that you can add to your authorization header for future requests.\nScaphold looks for a token under the  Authorization  key with the format  Bearer  token  in your request headers and uses that to authenticate the user. It looks like this:    The preferred way of logging in with Auth0 Lock is to use the  loginWithAuth0  mutation. For backwards compatibility,\nthe  loginWithAuth0Lock  mutation will remain but  loginWithAuth0  is easier to use.  To use  loginWithAuth0Lock  make sure you have installed Lock version  ^10.9.1 . Auth0 introduced\na few non-backwards compatible changes to their API in the beginning of 2017. It must have been\na new years resolution..   In addition, if you're logged in and make a request to any of the  loginUserWithAuth0  mutations but with a different social provider (i.e. Google),\nScaphold will link your two accounts together. Now, you'll have access to both Facebook and Google information using Facebook's and Google's account credentials.   \n  **UPDATE:** Mutation name is now called `loginUserWithAuthOSocial`", 
            "title": "Login using native SDKs"
        }, 
        {
            "location": "/integrations/social/login-with-auth0/", 
            "text": "Login using Auth0 Lock\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nmutation Login($token:LoginUserWithAuth0Input!) {\n  loginUserWithAuth0(input:$token) {\n    user {\n      id\n      username\n      createdAt\n    }\n  }\n}\n\n# Variables. Pass in the idToken returned by Auth0 Lock.\n{\n  \ntoken\n: {\n    \nidToken\n:  \nidToken\n\n  }\n}\n\n\n\n\n\n\nIf you'd like to use Auth0 Lock as a client-side SDK to manage your authentication, you can do so with the \nloginUserWithAuth0\n mutation. This accepts the idToken returned\nfrom a successful Auth0 Lock login in the profile variable. These work in sync with all other Scaphold basic and social authentication flows so you can manage your users the way you want.", 
            "title": "Login With Auth0"
        }, 
        {
            "location": "/integrations/social/login-with-auth0/#login-using-auth0-lock", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 mutation Login($token:LoginUserWithAuth0Input!) {\n  loginUserWithAuth0(input:$token) {\n    user {\n      id\n      username\n      createdAt\n    }\n  }\n}\n\n# Variables. Pass in the idToken returned by Auth0 Lock.\n{\n   token : {\n     idToken :   idToken \n  }\n}   If you'd like to use Auth0 Lock as a client-side SDK to manage your authentication, you can do so with the  loginUserWithAuth0  mutation. This accepts the idToken returned\nfrom a successful Auth0 Lock login in the profile variable. These work in sync with all other Scaphold basic and social authentication flows so you can manage your users the way you want.", 
            "title": "Login using Auth0 Lock"
        }, 
        {
            "location": "/app-management/alias/", 
            "text": "Aliases\n\n\nSimplify your API URL with an alias!\n\n\nNow when you create an app, you can choose to set an alias. An alias is a unique name for your application that can be used in the URL to access your API.\nFor example, if I set an alias for my app of \nscaphold\n then I could access my application at the url \nhttps://us-west-2.api.scaphold.io/graphql/scaphold\n.\n\n\n\n  Alias names must be 6 characters or greater in length, must contain only lowercase letters, numbers, and dashes, and must not end or begin in a dash.\n\n\n\n\nYou can also change an alias at any time by clicking \nMy API\n at the top of the page.", 
            "title": "Aliases"
        }, 
        {
            "location": "/app-management/alias/#aliases", 
            "text": "Simplify your API URL with an alias!  Now when you create an app, you can choose to set an alias. An alias is a unique name for your application that can be used in the URL to access your API.\nFor example, if I set an alias for my app of  scaphold  then I could access my application at the url  https://us-west-2.api.scaphold.io/graphql/scaphold .  \n  Alias names must be 6 characters or greater in length, must contain only lowercase letters, numbers, and dashes, and must not end or begin in a dash.  You can also change an alias at any time by clicking  My API  at the top of the page.", 
            "title": "Aliases"
        }, 
        {
            "location": "/app-management/analytics/", 
            "text": "Analytics\n\n\nScaphold comes full circle with a comprehensive analytics dashboard so you can always get the latest updates on the performance, growth, and usage of your app in production.\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRequest Counts\n\n\nTotal number of requests broken down by hour\n\n\n\n\n\n\nAverage Response Time\n\n\nMeasures latency (in seconds) in your API broken down by hour\n\n\n\n\n\n\nUser Growth\n\n\nTracks the number of new users that are signing up for your app\n\n\n\n\n\n\nData Throughput\n\n\nAmount of data (in MB) that's being transmitted over the wire to your client apps\n\n\n\n\n\n\nResolvers by Type\n\n\nSorts your GraphQL requests by the associated type to help break down which part of your API is being used the most\n\n\n\n\n\n\nError Counts\n\n\nTotal number of errors broken down by hour\n\n\n\n\n\n\nApplication Logs\n\n\nTable of all the latest logs for your API\n\n\n\n\n\n\n\n\nOur goal is to give you as much transparency as we can into your GraphQL API, so you can make the best app possible. Please email us at \nsupport@scaphold.io\n\nif you have any requests for metrics you\u00a0would like to see that would help you better measure and analyze the success of your app.", 
            "title": "Analytics"
        }, 
        {
            "location": "/app-management/analytics/#analytics", 
            "text": "Scaphold comes full circle with a comprehensive analytics dashboard so you can always get the latest updates on the performance, growth, and usage of your app in production.     Name  Description      Request Counts  Total number of requests broken down by hour    Average Response Time  Measures latency (in seconds) in your API broken down by hour    User Growth  Tracks the number of new users that are signing up for your app    Data Throughput  Amount of data (in MB) that's being transmitted over the wire to your client apps    Resolvers by Type  Sorts your GraphQL requests by the associated type to help break down which part of your API is being used the most    Error Counts  Total number of errors broken down by hour    Application Logs  Table of all the latest logs for your API     Our goal is to give you as much transparency as we can into your GraphQL API, so you can make the best app possible. Please email us at  support@scaphold.io \nif you have any requests for metrics you\u00a0would like to see that would help you better measure and analyze the success of your app.", 
            "title": "Analytics"
        }, 
        {
            "location": "/app-management/export-schema/", 
            "text": "Export Schema\n\n\nExporting your schema can be useful if you want to see what the raw JSON version of your data model looks like.\n\n\nScaphold manages two versions of your schema:\n\n\n\n\n\n\nStandard GraphQL\n: Download a standard version of your GraphQL schema that you can use with any GraphQL server.\n\n\n\n\n\n\nScaphold Schema\n: Save a copy of your up-to-date GraphQL schema that you can use to create an app on Scaphold.", 
            "title": "Export Schema"
        }, 
        {
            "location": "/app-management/export-schema/#export-schema", 
            "text": "Exporting your schema can be useful if you want to see what the raw JSON version of your data model looks like.  Scaphold manages two versions of your schema:    Standard GraphQL : Download a standard version of your GraphQL schema that you can use with any GraphQL server.    Scaphold Schema : Save a copy of your up-to-date GraphQL schema that you can use to create an app on Scaphold.", 
            "title": "Export Schema"
        }, 
        {
            "location": "/app-management/fork-app/", 
            "text": "Fork App\n\n\nForking an app will make an exact copy of the app in a new environment. That means the new app will automatically configure itself to be identical to the\nsource but it will have its own data, schema, and API. This is useful for testing schema changes before making any migrations to your production applications.\nOnce you have tested your changes and manually merged them into your production app you can safely remove the fork.\n\n\nYou can fork an app in 2 ways:\n\n\n\n\n\n\nApps Page \n Underneath each API link\n for each app panel (top-right)\n\n\n\n\n\n\nSettings Page \n Advanced", 
            "title": "Fork App"
        }, 
        {
            "location": "/app-management/fork-app/#fork-app", 
            "text": "Forking an app will make an exact copy of the app in a new environment. That means the new app will automatically configure itself to be identical to the\nsource but it will have its own data, schema, and API. This is useful for testing schema changes before making any migrations to your production applications.\nOnce you have tested your changes and manually merged them into your production app you can safely remove the fork.  You can fork an app in 2 ways:    Apps Page   Underneath each API link  for each app panel (top-right)    Settings Page   Advanced", 
            "title": "Fork App"
        }, 
        {
            "location": "/app-management/teams/", 
            "text": "Teams\n\n\nApp development is always more fun and faster in teams! Which is why we've provided you the ability to collaborate with others on apps.\n\n\nThere are two ways to add a teammate:\n\n\n\n\n\n\nBottom left of the left side panel\n in the app-view.\n\n\n\n\n\n\n\n\nSettings Page \n Team\n\n\n\n\n\n\n\n\nIn addition to adding a teammate, you may also want to remove a teammate. To do so, navigate to the \nSettings Page \n Team\n, click on the bubble under \nTeammates\n\nthat designates the user you wish to remove from this app, and a dropdown will appear that will allow you to remove that user.\n\n\n\n  Transferring ownership of an app is also possible. Keep in mind that this will also transfer the payment method associated with a particular app, since payment methods\n  belong to an individual user account (i.e. The app owner's payment source will always be the one associated with an app's billing).", 
            "title": "Teams"
        }, 
        {
            "location": "/app-management/teams/#teams", 
            "text": "App development is always more fun and faster in teams! Which is why we've provided you the ability to collaborate with others on apps.  There are two ways to add a teammate:    Bottom left of the left side panel  in the app-view.     Settings Page   Team     In addition to adding a teammate, you may also want to remove a teammate. To do so, navigate to the  Settings Page   Team , click on the bubble under  Teammates \nthat designates the user you wish to remove from this app, and a dropdown will appear that will allow you to remove that user.  \n  Transferring ownership of an app is also possible. Keep in mind that this will also transfer the payment method associated with a particular app, since payment methods\n  belong to an individual user account (i.e. The app owner's payment source will always be the one associated with an app's billing).", 
            "title": "Teams"
        }, 
        {
            "location": "/app-management/multi-region/", 
            "text": "Regions\n\n\nScaphold is now deployed in multiple regions and counting! With growing demand for Scaphold's service by developers around the world, we're always open to setting up new infrastructure\nso that your data lives closer to you.\n\n\nCurrently, we're deployed in...\n\n\n\n\n\n\nUS West (Oregon)\n\n\n\n\n\n\nEU West (Ireland)\n\n\n\n\n\n\nMore to come. If you wish to have Scaphold deployed on a data center in your region, please contact us at \nsupport@scaphold.io\n.\n\n\n\n\n\n\nTo switch between regions, select the region you wish to use in the \nheader bar of the Scaphold dashboard\n.\n\n\n\n\n\n  \nTip\n: Your app's GraphQL API will be prefixed with the region that it belongs to (e.g. \nhttps://us-west-2.api.scaphold.io/graphql/scaphold-graphql\n is in the US West region).", 
            "title": "Multi Region"
        }, 
        {
            "location": "/app-management/multi-region/#regions", 
            "text": "Scaphold is now deployed in multiple regions and counting! With growing demand for Scaphold's service by developers around the world, we're always open to setting up new infrastructure\nso that your data lives closer to you.  Currently, we're deployed in...    US West (Oregon)    EU West (Ireland)    More to come. If you wish to have Scaphold deployed on a data center in your region, please contact us at  support@scaphold.io .    To switch between regions, select the region you wish to use in the  header bar of the Scaphold dashboard .   \n   Tip : Your app's GraphQL API will be prefixed with the region that it belongs to (e.g.  https://us-west-2.api.scaphold.io/graphql/scaphold-graphql  is in the US West region).", 
            "title": "Regions"
        }, 
        {
            "location": "/app-management/admin-tokens/", 
            "text": "Admin Tokens\n\n\nWith admin tokens, you have the ability to bypass any permissions that have been set in your API. By setting this as \nAuthorization: Bearer {ADMIN_TOKEN}\n in your header\nlike any other auth token in Scaphold, you become an admin user. This is useful for importing or exporting data, any one-off data management tasks that need to be done, or scheduled jobs.\n\n\nTo create a admin token, navigate to \nSettings Page \n Admin Tokens \n Create\n\n\n\n  Note: Admin tokens never expire, unless you delete them.", 
            "title": "Admin Tokens"
        }, 
        {
            "location": "/app-management/admin-tokens/#admin-tokens", 
            "text": "With admin tokens, you have the ability to bypass any permissions that have been set in your API. By setting this as  Authorization: Bearer {ADMIN_TOKEN}  in your header\nlike any other auth token in Scaphold, you become an admin user. This is useful for importing or exporting data, any one-off data management tasks that need to be done, or scheduled jobs.  To create a admin token, navigate to  Settings Page   Admin Tokens   Create  \n  Note: Admin tokens never expire, unless you delete them.", 
            "title": "Admin Tokens"
        }, 
        {
            "location": "/app-management/token-expiration/", 
            "text": "Token Expiration\n\n\nScaphold gives you full control over how your tokens are managed for authentication. As such, we provide the ability to control the expiration of the JsonWebToken (JWT) measured in seconds\nfrom when it was issued. This refers to the token issued during mutation calls such as \nloginUser\n, or any social auth flow.\n\n\nTo configure the token expiration time, please navigate to \nSettings Page \n Advanced\n\n\n\n  The default value is 1,296,000 seconds (i.e. 15 days, or ~2 weeks).", 
            "title": "Token Expiration"
        }, 
        {
            "location": "/app-management/token-expiration/#token-expiration", 
            "text": "Scaphold gives you full control over how your tokens are managed for authentication. As such, we provide the ability to control the expiration of the JsonWebToken (JWT) measured in seconds\nfrom when it was issued. This refers to the token issued during mutation calls such as  loginUser , or any social auth flow.  To configure the token expiration time, please navigate to  Settings Page   Advanced  \n  The default value is 1,296,000 seconds (i.e. 15 days, or ~2 weeks).", 
            "title": "Token Expiration"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/", 
            "text": "The Case for Subscriptions\n\n\nWhen Facebook open-sourced GraphQL, they described how applications can perform reads with queries, and writes with mutations. However, often times clients want to get pushed updates from the server when data they care about changes. Enter GraphQL Subscriptions. Subscriptions make real-time functionality a first class citizen in GraphQL!\n\n\nSubscriptions offer a clean and efficient way to get pushed updates in realtime. They act in parallel to mutations. Just like how mutations describe the set of actions you can take to change your data, subscriptions define the set of events that you can subscribe to when data changes. In fact, you can think of subscriptions as a way to react to mutations that are performed on your server.\n\n\nFor example, think about a chat application like \nSlack\n. To create a good user experience, our application needs to stay up to date at all times. I.E. when a co-worker sends me a message, I shouldn't have to refresh the page to see the message. A much better solution is to have the server push my chat client the message as soon as it is created. This is how Subscriptions work. When someone creates a message (or in other words issues a mutation), the server immediately pushes the data to every client that is also subscribed to that event.\n\n\nTo build an app like Slack, we need to be able to say:\n\n\n\n\nHey, every time someone posts a new message to a channel I am a member of, tell me!\n\n\n\n\nWith subscriptions we can do this by issuing a query like this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nsubscription SubscribeToNewMessage($messageFilter: MessageWhereArgs) {\n    subscribeToMessage(mutations:[createMessage], filter: $messageFilter) {\n        mutation\n        value {\n            id\n            content\n        }\n    }\n}\n\n\n\n\n\n\nFor now, don't worry too much about the input arguments but just note that we can choose which mutations we would like to subscribe to as well as supply certain filters so that we only get pushed updates for the data we care about.\n\n\nNow, every time another user calls a mutation like this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nmutation CreateMessage($message: CreateMessageInput!) {\n    createMessage(input: $message) {\n        changedMessage {\n            id\n            content\n        }\n    }\n}\n\n\n\n\n\n\nEvery subscribed client will be pushed an update as long as the new message satisfies the filter it used to first subscribe! It's that easy!\n\n\nThis Tutorial (TLDR)\n\n\nThroughout this post, we are going to take a \npractical dive into GraphQL subscriptions and build a simple chat application\n. To do this we will be building a React application in the spirit of Slack that we are going to call \nSlackr\n. Our application will come complete with realtime messaging and social authentication. Although, we will be using React for demonstration purposes, Apollo Client and subscriptions will work with basically any Javascript frontend so I will do my best to keep the code snippets in this post as unopinionated as possible.\n\n\nWe are going to use \nScaphold.io\n as our backend provider because we can get a powerful, realtime GraphQL API in a matter of minutes (less than 4 minutes to be exact) when it could take weeks to build and deploy our own. If you are interested in how subscriptions are implemented on the backend I will be following up this post with a server-side technical review of how we implemented subscriptions on our servers.\n\n\nCheck out slackr!\n\n\n\n\nGet the code on Github\n\n\nIf you would like to follow along, our \nSlackr\n Starter Kit is available on Github\n. We will only be looking at snippets from that repo so take a peek if you'd like to see the whole picture.\n\n\nGetting Started\n\n\nWe're happy to announce that subscriptions are now available for all Scaphold Apps!\n\n\nWe have worked closely with the Apollo Team to remove all the friction from building realtime applications using GraphQL! Here is quick guide on how you can easily start building realtime apps \nfor free\n using Apollo Client and Scaphold.io!\n\n\n1) Go to Scaphold.io and create a free app!\n\n\n2) That's it! You now have a fully featured, realtime GraphQL API ready to power your app!\n\n\nOkay so it really is that easy, but let's make things a little more interesting!\n\n\nLet's create a data model for our Slackr app!\n\n\nDesign our Data Model\n\n\nThis is one area where Scaphold excels over previous realtime BaaS offerings like Firebase. Although Firebase has powerful primitives for building realtime apps, they lack the ability to define powerful data models. Our use of GraphQL allows us to provides the best of both worlds. By leveraging GraphQL, we can provide millisecond subscription latencies for simple queries as well as allow you to define much more complex queries that will be rerun on every update. This can be much more efficient than exising solutions as you can often get all the data you want pushed to you in realtime without having to issue any other requests.\n\n\nLet's try this out by defining the data model for our \nSlackr\n app. Our app will be like a dumbed down version of slack. A user can subscribe to any number of public channels and each channel can contain any number of messages each of which has an author.\n\n\nHere is a simplified version of our data model in GraphQL schema language.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\ntype User {\n    id: ID!\n    username: String!\n    nickname: String\n    picture: String\n    messages: MessageConnection\n    channels: ChannelConnection\n}\n\ntype Message {\n    id: ID!\n    content: String!\n    author: User!\n    channel: Channel!\n}\n\ntype Channel {\n    id: ID!\n    name: String!\n    members: UserConnection\n    messages: MessageConnection\n}\n\n# Note: A Connection is a paginated relation. This allows us to connect\n# arbitrarily large sets of objects with one another\n\n\n\n\n\n\nTo aid you in developing your application's data model, Scaphold comes with a graphical schema designer. As you make changes to your schema, the infrastructure behind the scenes will automatically update to match the new schema. There is a lot you can do with the schema designer including creating Interfaces, Enums, defining permissions, and more. To start, let's just create a few types, add some fields, and create relations between your types via \nConnection\n fields.\n\n\nCreating your schema is easy! Here is me doing it!\n\n\n\n\nThis is what I did\n\n\n1) Using the schema designer, create two new types \nMessage\n and \nChannel\n\n\n2) On the \nChannel\n type add the fields\n\n\n\n\n\n\nname\n with type \nString\n.\n\n\n\n\n\n\nmessages\n with type \nConnection\n, ofType \nMessage\n, reverseName \nchannel\n, and cardinality \nOne to Many\n.\n\n\n\n\n\n\nmembers\n with type \nConnection\n, ofType \nUser\n, reverseName \nchannels\n, and cardinality \nMany To Many\n.\n\n\n\n\n\n\nisPublic\n with type \nBoolean\n and a defaultValue of \nfalse\n.\n\n\n\n\n\n\n3) On the \nMessage\n type, add the fields\n\n\n\n\n\n\ncontent\n with type \nString\n.\n\n\n\n\n\n\nauthor\n with type \nConnection\n, ofType \nUser\n, reverseName \nmessages\n, and cardinality \nMany To One\n with the Many on the Message side.\n\n\n\n\n\n\n4) On the \nUser\n type, add the fields:\n\n\n\n\n\n\nnickname\n with type \nString\n\n\n\n\n\n\npicture\n with type \nString\n\n\n\n\n\n\nThat should do it! As we were poking around and adding types, fields, and relations the infrastrucutre needed to power your app was automatically deployed and configured for your new schema. We have now done all the setup that is necessary to start building our application. To get a feel for what capabilities our new API has in store, let's jump over to GraphiQL to explore our API and prototype some queries.\n\n\nExploring your API in GraphiQL\n\n\nAs we said earlier, Subscriptions are reactions to mutations made elsewhere. Before diving into building our front-end we can play with our new realtime subscriptions using GraphiQL. Here is what it looks like:\n\n\n\n\nWe first issue a subcription query (seen below) and can then watch as changes are pushed to us from the server whenever we create new messages.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nsubscription SubscribeToNewMessage($messageFilter: MessageWhereArgs) {\n    subscribeToNewMessage(mutations:[createMessage], where: $messageFilter) {\n        mutation\n        value {\n            id\n            content\n            author {\n                id\n                username\n            }\n        }\n    }\n}\n\n\n\n\n\n\nNotice that this subscription query is slightly different than the subscription query I showed before. See how we are asking for the nested \nauthor\n id and username? This is a simple example showing the power that comes from combining realtime data with a structured data model. Not only will our client application receive an update within milliseconds of a new \nMessage\n being created but it will also automatically receive the related \nauthor\n of the \nMessage\n without having to issue another request. This is just one example that shows how GraphQL can make your applications not only more efficient but easier to develop.\n\n\nUnder the hood, a websocket connection is being established between our Apollo Client instance and Scaphold's webservers. This connection stays open as long as our subscription is alive and acts as the transport that allows the server to send updates to the client.\n\n\nThe pane that pops out from the right of GraphiQL will show all new messages that satisfy our filter. To see it in action lets call the \ncreateMessage\n mutation to create a new \nMessage\n object.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nmutation CreateMessage($message: CreateMessageInput!) {\n    createMessage(input: $message) {\n        changedMessage {\n            id\n            content\n        }\n    }\n}\n\n\n\n\n\n\nEach time you create a new object that satisfies your subscription filter, you should see a new object appear in the pane to the right! That new message was pushed to us from the server in realtime! Each message should also come with the associated user attached so you can easily present user information alongside the message in your UI!\n\n\nTake some time to play around with your new API! It has a bunch of goodies hidden in it so poke around the doc explorer to see what it has to offer! For starters, we've generated a GraphQL Subscription for each type that you have in your data model.\n\n\nConnecting to your API from your application\n\n\nThe Scaphold GraphiQL page has already implemented the subscription protocol for you. The good news is that it is really easy to set this up in your own application. Here is how.\n\n\n1) Download Apollo Client from npm! (Apollo Client works pretty much the same whether you are building a React, AngularJS, or vanilla JavaScript applications)\n\n\n\n\n\n\nnpm install apollo-client graphql-tag --save\n\n\n\n\n\n\nIf using React also \nnpm install react-apollo --save\n\n\n\n\n\n\nIf using Angular2 also \nnpm install angular2-apollo --save\n\n\n\n\n\n\n2) Configure the Apollo Client network layer to work with websockets. To do this we can use the following two code snippets:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n/*\n \nFile\n:\n \naddGraphQLSubscriptions\n.\njs\n \n*/\n\n\n\nimport\n \n{\n \nprint\n \n}\n \nfrom\n \ngraphql-tag/printer\n;\n\n\n\n//\n \nquick\n \nway\n \nto\n \nadd\n \nthe\n \nsubscribe\n \nand\n \nunsubscribe\n \nfunctions\n \nto\n \nthe\n \nnetwork\n \ninterface\n\n\nexport\n \ndefault\n \nfunction\n \naddGraphQLSubscriptions\n(\nnetworkInterface\n,\n \nwsClient\n)\n \n{\n\n  \nreturn\n \nObject\n.\nassign\n(\nnetworkInterface\n,\n \n{\n\n    \nsubscribe\n(\nrequest\n,\n \nhandler\n)\n \n{\n\n      \nreturn\n \nwsClient\n.\nsubscribe\n({\n\n        \nquery\n:\n \nprint\n(\nrequest\n.\nquery\n),\n\n        \nvariables\n:\n \nrequest\n.\nvariables\n,\n\n      \n},\n \nhandler\n);\n\n    \n},\n\n    \nunsubscribe\n(\nid\n)\n \n{\n\n      \nwsClient\n.\nunsubscribe\n(\nid\n);\n\n    \n},\n\n  \n});\n\n\n}\n\n\n\n/*\n \nEnd\n \nof\n \nfile\n:\n \naddGraphQLSubscriptions\n.\njs\n \n*/\n\n\n\n\n\n\n\nThe \naddGraphQLSubscriptions\n function retrofits the Apollo Client network interface with the subscribe and unsubscribe methods that we can use from our application code.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n/*\n \nFile\n:\n \nmakeApolloClient\n.\njs\n \n*/\n\n\n\nimport\n \naddGraphQLSubscriptions\n \nfrom\n \n./addGraphQLSubscriptions\n;\n\n\nimport\n \nApolloClient\n,\n \n{\n \ncreateNetworkInterface\n \n}\n \nfrom\n \napollo-client\n;\n\n\nimport\n \n{\n \nClient\n \n}\n \nfrom\n \nsubscriptions-transport-ws\n;\n\n\n\n//\n \ncreates\n \na\n \nsubscription\n \nready\n \nApollo\n \nClient\n \ninstance\n\n\nexport\n \nfunction\n \nmakeApolloClient\n()\n \n{\n\n  \nconst\n \nscapholdUrl\n \n=\n \nv2.api.scaphold.io/graphql/my-awesome-app\n;\n\n  \nconst\n \ngraphqlUrl\n \n=\n \n`https://${scapholdUrl}`\n;\n\n  \nconst\n \nwebsocketUrl\n \n=\n \n`wss://${scapholdUrl}`\n;\n\n  \nconst\n \nnetworkInterface\n \n=\n \ncreateNetworkInterface\n(\ngraphqlUrl\n);\n\n  \nnetworkInterface\n.\nuse\n([{\n\n    \napplyMiddleware\n(\nreq\n,\n \nnext\n)\n \n{\n\n      \n//\n \nEasy\n \nway\n \nto\n \nadd\n \nauthorization\n \nheaders\n \nfor\n \nevery\n \nrequest\n\n      \nif\n \n(\n!\nreq\n.\noptions\n.\nheaders\n)\n \n{\n\n        \nreq\n.\noptions\n.\nheaders\n \n=\n \n{};\n  \n//\n \nCreate\n \nthe\n \nheader\n \nobject\n \nif\n \nneeded\n.\n\n      \n}\n\n      \nif\n \n(\nlocalStorage\n.\ngetItem\n(\nscaphold_user_token\n))\n \n{\n\n        \n//\n \nThis\n \nis\n \nhow\n \nto\n \nauthorize\n \nusers\n \nusing\n \nhttp\n \nauth\n \nheaders\n\n        \nreq\n.\noptions\n.\nheaders\n.\nAuthorization\n \n=\n \n`Bearer ${localStorage.getItem(\nscaphold_user_token\n)}`\n;\n\n      \n}\n\n      \nnext\n();\n\n    \n},\n\n  \n}]);\n\n  \nconst\n \nwsClient\n \n=\n \nnew\n \nClient\n(\nwebsocketUrl\n);\n\n  \nconst\n \nnetworkInterfaceWithSubscriptions\n \n=\n \naddGraphQLSubscriptions\n(\nnetworkInterface\n,\n \nwsClient\n);\n\n\n  \nconst\n \nclientGraphql\n \n=\n \nnew\n \nApolloClient\n({\n\n    \nnetworkInterface\n:\n \nnetworkInterfaceWithSubscriptions\n,\n\n    \ninitialState\n:\n \n{},\n\n  \n});\n\n  \nreturn\n \nclientGraphql\n;\n\n\n}\n\n\n/*\n \nEnd\n \nof\n \nFile\n:\n \nmakeApolloClient\n.\njs\n \n*/\n\n\n\n\n\n\n\nThe \nmakeApolloClient\n function then creates a new Apollo Client instance, applies the subscription methods, and adds a peice of authentication middleware before returning the client for use in our application.\n\n\nThis is all we need to do to configure our Apollo Client instance for subscriptions.\n\n\nUsing subscriptions from vanilla js\n\n\nUsing subscriptions from our application could not be much simpler. At Scaphold, we build our user interfaces with React, but Apollo Client works with any javascript frontend. Here is an unopinionated example.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\nimport\n \nmakeApolloClient\n \nfrom\n \n./makeApolloClient\n;\n\n\n\n//\n \nMake\n \nour\n \napollo\n \nclient\n \ninstance\n\n\nconst\n \nclient\n \n=\n \nmakeApolloClient\n();\n\n\n\n//\n \nOur\n \nsubscription\n \nquery\n\n\nconst\n \nsubscriptionQuery\n \n=\n \n`\n\n\nsubscription\n \nSubscribeToNewMessage\n(\n$\nmessageFilter\n:\n \nMessageWhereArgs\n)\n \n{\n\n    \nsubscribeToNewMessage\n(\nmutations\n:[\ncreateMessage\n],\n \nwhere\n:\n \n$\nmessageFilter\n)\n \n{\n\n        \nmutation\n\n        \nvalue\n \n{\n\n            \nid\n\n            \ncontent\n\n        \n}\n\n    \n}\n\n\n}\n\n\n`\n;\n\n\n\n//\n \nOur\n \nsubscription\n \nfilter\n\n\nconst\n \nvars\n \n=\n \n{\n\n  \nmessageFilter\n:\n \n{\n\n    \ncontent\n:\n \n{\n\n      \nchannelId\n:\n \n{\n\n        \neq\n:\n \nAChannelId\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n};\n\n\n\n//\n \nInitiate\n \nthe\n \nsubscription\n \nobservable\n\n\nconst\n \nsubscriptionObservable\n \n=\n \nclient\n.\nsubscribe\n({\n\n  \nquery\n:\n \nsubscriptionQuery\n,\n\n  \nvariables\n:\n \nvars\n,\n\n\n});\n\n\n\n//\n \nUse\n \nobservable\n.\nsubscribe\n \nto\n \nhandle\n \nnew\n \ndata\n \npushed\n \nfrom\n \nthe\n \nserver\n \nand\n \nerrors.\n\n\nconst\n \nmessageSubscription\n \n=\n \nsubscriptionObservable\n.\nsubscribe\n({\n\n  \nnext\n(\nnewObj\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nReceived new data\n);\n\n    \n//\n \nMerge\n \nthe\n \nnew\n \ndata\n \nwith\n \nour\n \nclient\n \nside\n \ndata\n \ncache\n.\n \nSee\n \nBelow\n \n*\n\n  \n},\n\n  \nerror\n(\nerr\n)\n \n{\n\n    \nconsole\n.\nlog\n(\n`Error Subscribing: ${err.message}`\n);\n\n  \n},\n\n\n});\n\n\n\n\n\n\n\nFirst you can see that we have provided a GraphQL query and variables to Apollo's GraphQL function to initiate the subscription. In this case we are only interested in new posts that belong to the channel with id 'MyChannelId'. In reality, the \nchannelId\n would be a base64 encoded string created automatically when you create a \nChannel\n but this works for demonstration purposes. If you take a look in the doc explorer you will see that in addition to the \neq\n operator, you can specify a list of channel ids to include or exclude using the \nin\n and \nnotIn\n operators.\n\n\n\n\nNote: The above example uses the default \nsubscribe\n method to listen for updates. There is also a higher-level, \nsubscribeToMore\n method that manages more for us. E.G. it will keep track of open subscriptions and automatically close them for us. It also allows you to pass in a \nupdateQuery\n function that lets you define how you would like to merge the new data with the cache.\n\n\n\n\nMerging changes with the client side cache\n\n\nAn important topic to discuss when it comes to subscriptions is how to merge new data pushed from the server with the client side cache. There are many ways to do this and it often changes from application to application. At Scaphold, we use \nImmutableJS\n data structures and \nredux\n alongside the Apollo Client managed cache but this is largely up to you.\n\n\nApollo Client does a lot really nice things for you that can mostly eliminate the need to do any custom work. The key to merging changes with the Apollo cache is the \nupdateQuery\n method passed to \nsubscribeToMore\n. To see an example of this let's take a snippet from our \nSlackr\n React application.\n\n\nUsing Subscriptions from React\n\n\nLet's look at a more real world example using react. Apollo comes packed with really nice react-binding that we can use to simplify the process of subscribing to data and merging new data into the client side cache.\n\n\nHere is a condensed example from our Slackr app.\n\n\nSee the complete code on GitHub\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \ngraphql\n,\n \ncompose\n \n}\n \nfrom\n \nreact-apollo\n;\n\n\nimport\n \ngql\n \nfrom\n \ngraphql-tag\n;\n\n\n\nconst\n \nChannelMessagesQuery\n \n=\n \ngql\n`\n\n\nquery\n \nGetPublicChannels\n(\n$\nchannelId\n:\n \nID\n!\n,\n \n$\nmessageOrder\n:\n \n[\nMessageOrderByArgs\n])\n \n{\n\n  \ngetChannel\n(\nid\n:\n \n$\nchannelId\n)\n \n{\n\n    \nid\n\n    \nname\n\n    \nmessages\n(\nlast\n:\n \n50\n,\n \norderBy\n:\n \n$\nmessageOrder\n)\n \n{\n\n      \nedges\n \n{\n\n        \nnode\n \n{\n\n          \nid\n\n          \ncontent\n\n          \ncreatedAt\n\n          \nauthor\n \n{\n\n            \nid\n\n            \nusername\n\n            \nnickname\n\n            \npicture\n\n          \n}\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n`\n;\n\n\n\nclass\n \nMessages\n \nextends\n \nReact\n.\nComponent\n \n{\n\n\n    \n...\n\n\n    \ncomponentWillReceiveProps\n(\nnewProps\n)\n \n{\n\n        \nif\n \n(\n\n            \n!\nnewProps\n.\ndata\n.\nloading\n \n\n            \nnewProps\n.\ndata\n.\ngetChannel\n\n        \n)\n \n{\n\n            \nif\n \n(\n\n                \n!\nthis\n.\nprops\n.\ndata\n.\ngetChannel\n \n||\n\n                \nnewProps\n.\ndata\n.\ngetChannel\n.\nid\n \n!==\n \nthis\n.\nprops\n.\ndata\n.\ngetChannel\n.\nid\n\n            \n)\n \n{\n\n                \n//\n \nIf\n \nwe\n \nchange\n \nchannels\n,\n \nsubscribe\n \nto\n \nthe\n \nnew\n \nchannel\n\n                \nthis\n.\nsubscribeToNewMessages\n();\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n    \n/*\n\n    \n*\n   \nInitiates\n \nthe\n \nsubscription\n \nand\n \nspecifies\n \nhow\n \nnew\n \ndata\n \nshould\n \nbe\n \nmerged\n\n    \n*\n   \ninto\n \nthe\n \ncache\n \nusing\n \nthe\n \nupdateQuery\n \nmethod\n.\n\n    \n*/\n\n    \nsubscribeToNewMessages\n()\n \n{\n\n        \nthis\n.\nsubscription\n \n=\n \nthis\n.\nprops\n.\ndata\n.\nsubscribeToMore\n({\n\n            \ndocument\n:\n \ngql\n`\n\n                \nsubscription\n \nnewMessages\n(\n$\nsubscriptionFilter\n:\nMessageSubscriptionFilter\n)\n \n{\n\n                    \nsubscribeToMessage\n(\nmutations\n:[\ncreateMessage\n],\n \nfilter\n:\n \n$\nsubscriptionFilter\n)\n \n{\n\n                        \nvalue\n \n{\n\n                            \nid\n\n                            \ncontent\n\n                            \ncreatedAt\n\n                            \nauthor\n \n{\n\n                                \nid\n\n                                \nusername\n\n                                \nnickname\n\n                                \npicture\n\n                            \n}\n\n                        \n}\n\n                    \n}\n\n                \n}\n\n            \n`\n,\n\n            \nvariables\n:\n \n{\n\n                \nsubscriptionFilter\n:\n \n{\n\n                    \nchannelId\n:\n \n{\n\n                        \n//\n \nWe\nre using react-router and grabbing the channelId from the url\n\n                        \n//\n \nto\n \ndesignate\n \nwhich\n \nchannel\n \nto\n \nsubscribe\n \nto\n\n                        \neq\n:\n \nthis\n.\nprops\n.\nparams\n \n?\n \nthis\n.\nprops\n.\nparams\n.\nchannelId\n \n:\n \nnull\n\n                    \n}\n\n                \n}\n\n            \n},\n\n\n            \n/*\n\n            \n*\n    \nUpdate\n \nquery\n \nspecifies\n \nhow\n \nthe\n \nnew\n \ndata\n \nshould\n \nbe\n \nmerged\n\n            \n*\n    \nwith\n \nour\n \nprevious\n \nresults\n.\n \nNote\n \nhow\n \nthe\n \nstructure\n \nof\n \nthe\n\n            \n*\n    \nobject\n \nwe\n \nreturn\n \nhere\n \ndirectly\n \nmatches\n \nthe\n \nstructure\n \nof\n\n            \n*\n    \nthe\n \nGetPublicChannels\n \nquery\n.\n\n            \n*/\n\n            \nupdateQuery\n:\n \n(\nprev\n,\n \n{\n \nsubscriptionData\n \n})\n \n=\n \n{\n\n                \nconst\n \nnewEdges\n \n=\n \n[\n\n                    \n...\nprev\n.\ngetChannel\n.\nmessages\n.\nedges\n,\n\n                    \n{\n\n                        \nnode\n:\n \n{\n\n                            \n...\nsubscriptionData\n.\ndata\n.\nsubscribeToMessage\n.\nvalue\n,\n\n                        \n}\n\n                    \n}\n\n                \n];\n\n                \nreturn\n \n{\n\n                    \ngetChannel\n:\n \n{\n\n                        \nmessages\n:\n \n{\n\n                            \nedges\n:\n \nnewEdges\n,\n\n                        \n}\n\n                    \n}\n\n                \n};\n\n            \n},\n\n        \n});\n\n    \n}\n\n\n    \n...\n\n\n}\n\n\n\nconst\n \nMessagesWithData\n \n=\n \ncompose\n(\n\n  \ngraphql\n(\nChannelMessagesQuery\n,\n \n{\n\n    \noptions\n:\n \n(\nprops\n)\n \n=\n \n{\n\n      \nconst\n \nchannelId\n \n=\n \nprops\n.\nparams\n \n?\n \nprops\n.\nparams\n.\nchannelId\n \n:\n \nnull\n;\n\n      \nreturn\n \n{\n\n        \nreturnPartialData\n:\n \ntrue\n,\n\n        \nvariables\n:\n \n{\n\n          \nchannelId\n,\n\n          \nmessageOrder\n:\n \n[\n\n            \n{\n\n              \nfield\n:\n \ncreatedAt\n,\n\n              \ndirection\n:\n \nASC\n\n            \n}\n\n          \n],\n\n        \n},\n\n      \n};\n\n    \n},\n\n  \n}),\n\n  \n...\n \n//\n \nWe\n \ncompose\n \na\n \nfew\n \nmore\n \nqueries\n \nin\n \nthe\n \nactual\n \napp\n.\n\n\n)(\nMessages\n);\n\n\n\nexport\n \ndefault\n \nMessagesWithData\n;\n\n\n\n\n\n\n\nA few things are going on here. To make sense of what is happening, let's start from the logical beginning which actually occurs at the end of the file. See this line \nconst MessagesWithData = compose(graphql(ChannelMessagesQuery, ...));\n towards the bottom of the snippet? This is the standard way to use Apollo to connect a React component with data from a GraphQL query. The \ngraphql\n function will wrap our component in a higher-order component that grabs our data and makes it available to our component via its \nprops\n. In this example, we will be able to access our \nChannel\n data from our component with \nthis.props.data.getChannel\n as soon as it is fetched.\n\n\n\n\nNote: The \nreturnPartialData: true\n option is important. When you want to use \nsubscribeToMore\n to merge results into the result of a normal query it is necessary to specify this.\n\n\n\n\nOkay so we have connected our component with a regular old GraphQL query, but how do we make it realtime? The key is the method \nsubscribeToMore\n.  Look at our \nsubscribeToNewMessages\n method. Apollo's \ngraphql\n function fits our component with the data prop that exposes the \nsubscribeToMore\n method. We use this method to attach a subscription query which then calls the \nupdateQuery\n method we pass in every time a new peice of data is pushed from the server. The object we return from \nupdateQuery\n is then merged with our previous results and persisted in the client side cache. This way, \nthis.props.data.getChannel...\n is always kept up to date and we can use it like normal to render our UI.\n\n\nTake a minute to look over this file. Apollo does a great job allowing us to use realtime subscriptions alongside traditional queries and mutations. The combination of \nsubscribeToMore\n and \nupdateQuery\n offer a powerful set of tools to keep our UI up to date when dealing with realtime data!\n\n\nUser Authentication\n\n\nWe have now covered the basics of how to use GraphQL subscriptions from both vanilla JS as well as React. We're now ready to finish up the surface area of our application! One of the nice things Scaphold does for you is handling user authentication. There is also an auth0 integration that lets you easily add social auth to any application instantly. In our Slackr app, we have enabled GitHub login so user's can easily chime in on our app without having to create any messy usernames or password.\n\n\nAuthentication with a Scaphold API is done via the \nAuthorization\n http header. We use \nJSON Web Tokens\n to securely authenticate your users and have integrations that allow you to pull in the auth provider of your choice. You've actually already seen how to add authentication to Apollo Client.\n\n\nRemember this from makeApolloClient.js?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n/* File: makeApolloClient.js */\n\n\nconst\n \nnetworkInterface\n \n=\n \ncreateNetworkInterface\n(\ngraphqlUrl\n);\n\n\nnetworkInterface\n.\nuse\n([{\n\n    \napplyMiddleware\n(\nreq\n,\n \nnext\n)\n \n{\n\n        \n// Easy way to add authorization headers for every request\n\n        \nif\n \n(\n!\nreq\n.\noptions\n.\nheaders\n)\n \n{\n\n            \nreq\n.\noptions\n.\nheaders\n \n=\n \n{};\n  \n// Create the header object if needed.\n\n        \n}\n\n        \nif\n \n(\nlocalStorage\n.\ngetItem\n(\nscaphold_user_token\n))\n \n{\n\n            \n// This is how to authorize users using http auth headers\n\n            \nreq\n.\noptions\n.\nheaders\n.\nAuthorization\n \n=\n \n`Bearer \n${\nlocalStorage\n.\ngetItem\n(\nscaphold_user_token\n)\n}\n`\n;\n\n        \n}\n\n        \nnext\n();\n\n    \n},\n\n\n}]);\n\n\n\n\n\n\n\nThis auth middleware looks for a token names 'scaphold_user_token' in the browser's local storage and then appends the necessary auth header to each request. This is great because all we need to do is pick a authentication mechanism and then save the token we get back from logging in to local storage and the middleware will handle the rest.\n\n\nSocial authentication for any application\n\n\nSlackr\n uses Auth0 lock for easy authentication. To make this work, we must first add the Auth0 integration to our API on Scaphold. It's easy!\n\n\n1) Go to \nAuth0\n and create a free account.\n\n\n2) Under the Social connections tab on the left, enable GitHub as an oauth provider.\n    - You will need to create a GitHub application to get the clientId and secret to give to Auth0.\n\n\n3) From the clients tab on the left in Auth0, open your application and grab your Auth0 clientId and client secret.\n\n\n4) Go to Scaphold's integrations page and enter the clientId and client secret in a new Auth0 integration.\n\n\n5) Presto chango, your API is now ready to handle social authentication!\n\n\nOne easy way to add authentication to your client app is by using Auth0 Lock. Lock is essentially a smart sign-in form that you can drop into any web or mobile application. You use Lock to handle the OAuth and then you can link the social credential with Scaphold's API using the \nloginWithAuth0Lock\n mutation that is now available in your API.\n\n\nFor a full example of how to do this take a look at \nauth.js\n and \nchannels.jsx\n in our \nSlackr\n app starter kit.\n\n\nThe login flow is simple. First we open lock, the user then enters his or her credentials or chooses from a set of social auth providers, and then Lock handles the OAuth handshake and returns a login credential. We then make one more call to Auth0 to grab the auth0 profile and then we send the auth0 user identity to Scaphold's servers where it is then matched with a Scaphold user. As part of the \nloginWithAuth0Lock\n mutation payload, Scaphold will return the auth token that is to be stored in local storage on the client and attached to http requests as the Authorization header by the Apollo Client auth middleware.\n\n\nWrapping Up\n\n\nCongrats! Now you've seen how you can use Scaphold, Apollo, and GraphQL subscriptions to build realtime, real-world applications in a fraction of the time it used to. To review what we did, we...\n\n\n\n\n\n\nDefined our applications data model using Scaphold's Graphical Schema Designer and a realtime GraphQL API was automatically configured and deployed for us.\n\n\n\n\n\n\nAs soon as we finished designing our schema, we jumped over to GraphiQL to prototype our subscriptions query and saw data pushed to us in realitme.\n\n\n\n\n\n\nWe discussed how you can easily add realtime subscriptions to you own application using Apollo Client.\n\n\n\n\n\n\nLast, we added social authentication to our API via the Auth0 Integration to allow our users to login via GitHub.\n\n\n\n\n\n\nThis is a great start but there is still alot we could do. We could start by adding permissions to our data for fine-grained access control which would allow us to create private channels. We could also instantly add iOS and Android push notifications so that we can alert our users when our application is closed. Stay tuned for more updates as more features come out daily!\n\n\nHappy Scapholding!", 
            "title": "Build A Chat App"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#the-case-for-subscriptions", 
            "text": "When Facebook open-sourced GraphQL, they described how applications can perform reads with queries, and writes with mutations. However, often times clients want to get pushed updates from the server when data they care about changes. Enter GraphQL Subscriptions. Subscriptions make real-time functionality a first class citizen in GraphQL!  Subscriptions offer a clean and efficient way to get pushed updates in realtime. They act in parallel to mutations. Just like how mutations describe the set of actions you can take to change your data, subscriptions define the set of events that you can subscribe to when data changes. In fact, you can think of subscriptions as a way to react to mutations that are performed on your server.  For example, think about a chat application like  Slack . To create a good user experience, our application needs to stay up to date at all times. I.E. when a co-worker sends me a message, I shouldn't have to refresh the page to see the message. A much better solution is to have the server push my chat client the message as soon as it is created. This is how Subscriptions work. When someone creates a message (or in other words issues a mutation), the server immediately pushes the data to every client that is also subscribed to that event.  To build an app like Slack, we need to be able to say:   Hey, every time someone posts a new message to a channel I am a member of, tell me!   With subscriptions we can do this by issuing a query like this:  1\n2\n3\n4\n5\n6\n7\n8\n9 subscription SubscribeToNewMessage($messageFilter: MessageWhereArgs) {\n    subscribeToMessage(mutations:[createMessage], filter: $messageFilter) {\n        mutation\n        value {\n            id\n            content\n        }\n    }\n}   For now, don't worry too much about the input arguments but just note that we can choose which mutations we would like to subscribe to as well as supply certain filters so that we only get pushed updates for the data we care about.  Now, every time another user calls a mutation like this:  1\n2\n3\n4\n5\n6\n7\n8 mutation CreateMessage($message: CreateMessageInput!) {\n    createMessage(input: $message) {\n        changedMessage {\n            id\n            content\n        }\n    }\n}   Every subscribed client will be pushed an update as long as the new message satisfies the filter it used to first subscribe! It's that easy!", 
            "title": "The Case for Subscriptions"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#this-tutorial-tldr", 
            "text": "Throughout this post, we are going to take a  practical dive into GraphQL subscriptions and build a simple chat application . To do this we will be building a React application in the spirit of Slack that we are going to call  Slackr . Our application will come complete with realtime messaging and social authentication. Although, we will be using React for demonstration purposes, Apollo Client and subscriptions will work with basically any Javascript frontend so I will do my best to keep the code snippets in this post as unopinionated as possible.  We are going to use  Scaphold.io  as our backend provider because we can get a powerful, realtime GraphQL API in a matter of minutes (less than 4 minutes to be exact) when it could take weeks to build and deploy our own. If you are interested in how subscriptions are implemented on the backend I will be following up this post with a server-side technical review of how we implemented subscriptions on our servers.  Check out slackr!", 
            "title": "This Tutorial (TLDR)"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#get-the-code-on-github", 
            "text": "If you would like to follow along, our  Slackr  Starter Kit is available on Github . We will only be looking at snippets from that repo so take a peek if you'd like to see the whole picture.", 
            "title": "Get the code on Github"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#were-happy-to-announce-that-subscriptions-are-now-available-for-all-scaphold-apps", 
            "text": "We have worked closely with the Apollo Team to remove all the friction from building realtime applications using GraphQL! Here is quick guide on how you can easily start building realtime apps  for free  using Apollo Client and Scaphold.io!  1) Go to Scaphold.io and create a free app!  2) That's it! You now have a fully featured, realtime GraphQL API ready to power your app!  Okay so it really is that easy, but let's make things a little more interesting!  Let's create a data model for our Slackr app!", 
            "title": "We're happy to announce that subscriptions are now available for all Scaphold Apps!"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#design-our-data-model", 
            "text": "This is one area where Scaphold excels over previous realtime BaaS offerings like Firebase. Although Firebase has powerful primitives for building realtime apps, they lack the ability to define powerful data models. Our use of GraphQL allows us to provides the best of both worlds. By leveraging GraphQL, we can provide millisecond subscription latencies for simple queries as well as allow you to define much more complex queries that will be rerun on every update. This can be much more efficient than exising solutions as you can often get all the data you want pushed to you in realtime without having to issue any other requests.  Let's try this out by defining the data model for our  Slackr  app. Our app will be like a dumbed down version of slack. A user can subscribe to any number of public channels and each channel can contain any number of messages each of which has an author.  Here is a simplified version of our data model in GraphQL schema language.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 type User {\n    id: ID!\n    username: String!\n    nickname: String\n    picture: String\n    messages: MessageConnection\n    channels: ChannelConnection\n}\n\ntype Message {\n    id: ID!\n    content: String!\n    author: User!\n    channel: Channel!\n}\n\ntype Channel {\n    id: ID!\n    name: String!\n    members: UserConnection\n    messages: MessageConnection\n}\n\n# Note: A Connection is a paginated relation. This allows us to connect\n# arbitrarily large sets of objects with one another   To aid you in developing your application's data model, Scaphold comes with a graphical schema designer. As you make changes to your schema, the infrastructure behind the scenes will automatically update to match the new schema. There is a lot you can do with the schema designer including creating Interfaces, Enums, defining permissions, and more. To start, let's just create a few types, add some fields, and create relations between your types via  Connection  fields.  Creating your schema is easy! Here is me doing it!   This is what I did  1) Using the schema designer, create two new types  Message  and  Channel  2) On the  Channel  type add the fields    name  with type  String .    messages  with type  Connection , ofType  Message , reverseName  channel , and cardinality  One to Many .    members  with type  Connection , ofType  User , reverseName  channels , and cardinality  Many To Many .    isPublic  with type  Boolean  and a defaultValue of  false .    3) On the  Message  type, add the fields    content  with type  String .    author  with type  Connection , ofType  User , reverseName  messages , and cardinality  Many To One  with the Many on the Message side.    4) On the  User  type, add the fields:    nickname  with type  String    picture  with type  String    That should do it! As we were poking around and adding types, fields, and relations the infrastrucutre needed to power your app was automatically deployed and configured for your new schema. We have now done all the setup that is necessary to start building our application. To get a feel for what capabilities our new API has in store, let's jump over to GraphiQL to explore our API and prototype some queries.", 
            "title": "Design our Data Model"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#exploring-your-api-in-graphiql", 
            "text": "As we said earlier, Subscriptions are reactions to mutations made elsewhere. Before diving into building our front-end we can play with our new realtime subscriptions using GraphiQL. Here is what it looks like:   We first issue a subcription query (seen below) and can then watch as changes are pushed to us from the server whenever we create new messages.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 subscription SubscribeToNewMessage($messageFilter: MessageWhereArgs) {\n    subscribeToNewMessage(mutations:[createMessage], where: $messageFilter) {\n        mutation\n        value {\n            id\n            content\n            author {\n                id\n                username\n            }\n        }\n    }\n}   Notice that this subscription query is slightly different than the subscription query I showed before. See how we are asking for the nested  author  id and username? This is a simple example showing the power that comes from combining realtime data with a structured data model. Not only will our client application receive an update within milliseconds of a new  Message  being created but it will also automatically receive the related  author  of the  Message  without having to issue another request. This is just one example that shows how GraphQL can make your applications not only more efficient but easier to develop.  Under the hood, a websocket connection is being established between our Apollo Client instance and Scaphold's webservers. This connection stays open as long as our subscription is alive and acts as the transport that allows the server to send updates to the client.  The pane that pops out from the right of GraphiQL will show all new messages that satisfy our filter. To see it in action lets call the  createMessage  mutation to create a new  Message  object.  1\n2\n3\n4\n5\n6\n7\n8 mutation CreateMessage($message: CreateMessageInput!) {\n    createMessage(input: $message) {\n        changedMessage {\n            id\n            content\n        }\n    }\n}   Each time you create a new object that satisfies your subscription filter, you should see a new object appear in the pane to the right! That new message was pushed to us from the server in realtime! Each message should also come with the associated user attached so you can easily present user information alongside the message in your UI!  Take some time to play around with your new API! It has a bunch of goodies hidden in it so poke around the doc explorer to see what it has to offer! For starters, we've generated a GraphQL Subscription for each type that you have in your data model.", 
            "title": "Exploring your API in GraphiQL"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#connecting-to-your-api-from-your-application", 
            "text": "The Scaphold GraphiQL page has already implemented the subscription protocol for you. The good news is that it is really easy to set this up in your own application. Here is how.  1) Download Apollo Client from npm! (Apollo Client works pretty much the same whether you are building a React, AngularJS, or vanilla JavaScript applications)    npm install apollo-client graphql-tag --save    If using React also  npm install react-apollo --save    If using Angular2 also  npm install angular2-apollo --save    2) Configure the Apollo Client network layer to work with websockets. To do this we can use the following two code snippets:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 /*   File :   addGraphQLSubscriptions . js   */  import   {   print   }   from   graphql-tag/printer ;  //   quick   way   to   add   the   subscribe   and   unsubscribe   functions   to   the   network   interface  export   default   function   addGraphQLSubscriptions ( networkInterface ,   wsClient )   { \n   return   Object . assign ( networkInterface ,   { \n     subscribe ( request ,   handler )   { \n       return   wsClient . subscribe ({ \n         query :   print ( request . query ), \n         variables :   request . variables , \n       },   handler ); \n     }, \n     unsubscribe ( id )   { \n       wsClient . unsubscribe ( id ); \n     }, \n   });  }  /*   End   of   file :   addGraphQLSubscriptions . js   */    The  addGraphQLSubscriptions  function retrofits the Apollo Client network interface with the subscribe and unsubscribe methods that we can use from our application code.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35 /*   File :   makeApolloClient . js   */  import   addGraphQLSubscriptions   from   ./addGraphQLSubscriptions ;  import   ApolloClient ,   {   createNetworkInterface   }   from   apollo-client ;  import   {   Client   }   from   subscriptions-transport-ws ;  //   creates   a   subscription   ready   Apollo   Client   instance  export   function   makeApolloClient ()   { \n   const   scapholdUrl   =   v2.api.scaphold.io/graphql/my-awesome-app ; \n   const   graphqlUrl   =   `https://${scapholdUrl}` ; \n   const   websocketUrl   =   `wss://${scapholdUrl}` ; \n   const   networkInterface   =   createNetworkInterface ( graphqlUrl ); \n   networkInterface . use ([{ \n     applyMiddleware ( req ,   next )   { \n       //   Easy   way   to   add   authorization   headers   for   every   request \n       if   ( ! req . options . headers )   { \n         req . options . headers   =   {};    //   Create   the   header   object   if   needed . \n       } \n       if   ( localStorage . getItem ( scaphold_user_token ))   { \n         //   This   is   how   to   authorize   users   using   http   auth   headers \n         req . options . headers . Authorization   =   `Bearer ${localStorage.getItem( scaphold_user_token )}` ; \n       } \n       next (); \n     }, \n   }]); \n   const   wsClient   =   new   Client ( websocketUrl ); \n   const   networkInterfaceWithSubscriptions   =   addGraphQLSubscriptions ( networkInterface ,   wsClient ); \n\n   const   clientGraphql   =   new   ApolloClient ({ \n     networkInterface :   networkInterfaceWithSubscriptions , \n     initialState :   {}, \n   }); \n   return   clientGraphql ;  }  /*   End   of   File :   makeApolloClient . js   */    The  makeApolloClient  function then creates a new Apollo Client instance, applies the subscription methods, and adds a peice of authentication middleware before returning the client for use in our application.  This is all we need to do to configure our Apollo Client instance for subscriptions.", 
            "title": "Connecting to your API from your application"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#using-subscriptions-from-vanilla-js", 
            "text": "Using subscriptions from our application could not be much simpler. At Scaphold, we build our user interfaces with React, but Apollo Client works with any javascript frontend. Here is an unopinionated example.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45 import   makeApolloClient   from   ./makeApolloClient ;  //   Make   our   apollo   client   instance  const   client   =   makeApolloClient ();  //   Our   subscription   query  const   subscriptionQuery   =   `  subscription   SubscribeToNewMessage ( $ messageFilter :   MessageWhereArgs )   { \n     subscribeToNewMessage ( mutations :[ createMessage ],   where :   $ messageFilter )   { \n         mutation \n         value   { \n             id \n             content \n         } \n     }  }  ` ;  //   Our   subscription   filter  const   vars   =   { \n   messageFilter :   { \n     content :   { \n       channelId :   { \n         eq :   AChannelId \n       } \n     } \n   }  };  //   Initiate   the   subscription   observable  const   subscriptionObservable   =   client . subscribe ({ \n   query :   subscriptionQuery , \n   variables :   vars ,  });  //   Use   observable . subscribe   to   handle   new   data   pushed   from   the   server   and   errors.  const   messageSubscription   =   subscriptionObservable . subscribe ({ \n   next ( newObj )   { \n     console . log ( Received new data ); \n     //   Merge   the   new   data   with   our   client   side   data   cache .   See   Below   * \n   }, \n   error ( err )   { \n     console . log ( `Error Subscribing: ${err.message}` ); \n   },  });    First you can see that we have provided a GraphQL query and variables to Apollo's GraphQL function to initiate the subscription. In this case we are only interested in new posts that belong to the channel with id 'MyChannelId'. In reality, the  channelId  would be a base64 encoded string created automatically when you create a  Channel  but this works for demonstration purposes. If you take a look in the doc explorer you will see that in addition to the  eq  operator, you can specify a list of channel ids to include or exclude using the  in  and  notIn  operators.   Note: The above example uses the default  subscribe  method to listen for updates. There is also a higher-level,  subscribeToMore  method that manages more for us. E.G. it will keep track of open subscriptions and automatically close them for us. It also allows you to pass in a  updateQuery  function that lets you define how you would like to merge the new data with the cache.", 
            "title": "Using subscriptions from vanilla js"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#merging-changes-with-the-client-side-cache", 
            "text": "An important topic to discuss when it comes to subscriptions is how to merge new data pushed from the server with the client side cache. There are many ways to do this and it often changes from application to application. At Scaphold, we use  ImmutableJS  data structures and  redux  alongside the Apollo Client managed cache but this is largely up to you.  Apollo Client does a lot really nice things for you that can mostly eliminate the need to do any custom work. The key to merging changes with the Apollo cache is the  updateQuery  method passed to  subscribeToMore . To see an example of this let's take a snippet from our  Slackr  React application.", 
            "title": "Merging changes with the client side cache"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#using-subscriptions-from-react", 
            "text": "Let's look at a more real world example using react. Apollo comes packed with really nice react-binding that we can use to simplify the process of subscribing to data and merging new data into the client side cache.  Here is a condensed example from our Slackr app.  See the complete code on GitHub    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131 import   React   from   react ;  import   {   graphql ,   compose   }   from   react-apollo ;  import   gql   from   graphql-tag ;  const   ChannelMessagesQuery   =   gql `  query   GetPublicChannels ( $ channelId :   ID ! ,   $ messageOrder :   [ MessageOrderByArgs ])   { \n   getChannel ( id :   $ channelId )   { \n     id \n     name \n     messages ( last :   50 ,   orderBy :   $ messageOrder )   { \n       edges   { \n         node   { \n           id \n           content \n           createdAt \n           author   { \n             id \n             username \n             nickname \n             picture \n           } \n         } \n       } \n     } \n   }  }  ` ;  class   Messages   extends   React . Component   { \n\n     ... \n\n     componentWillReceiveProps ( newProps )   { \n         if   ( \n             ! newProps . data . loading   \n             newProps . data . getChannel \n         )   { \n             if   ( \n                 ! this . props . data . getChannel   || \n                 newProps . data . getChannel . id   !==   this . props . data . getChannel . id \n             )   { \n                 //   If   we   change   channels ,   subscribe   to   the   new   channel \n                 this . subscribeToNewMessages (); \n             } \n         } \n     } \n\n     /* \n     *     Initiates   the   subscription   and   specifies   how   new   data   should   be   merged \n     *     into   the   cache   using   the   updateQuery   method . \n     */ \n     subscribeToNewMessages ()   { \n         this . subscription   =   this . props . data . subscribeToMore ({ \n             document :   gql ` \n                 subscription   newMessages ( $ subscriptionFilter : MessageSubscriptionFilter )   { \n                     subscribeToMessage ( mutations :[ createMessage ],   filter :   $ subscriptionFilter )   { \n                         value   { \n                             id \n                             content \n                             createdAt \n                             author   { \n                                 id \n                                 username \n                                 nickname \n                                 picture \n                             } \n                         } \n                     } \n                 } \n             ` , \n             variables :   { \n                 subscriptionFilter :   { \n                     channelId :   { \n                         //   We re using react-router and grabbing the channelId from the url \n                         //   to   designate   which   channel   to   subscribe   to \n                         eq :   this . props . params   ?   this . props . params . channelId   :   null \n                     } \n                 } \n             }, \n\n             /* \n             *      Update   query   specifies   how   the   new   data   should   be   merged \n             *      with   our   previous   results .   Note   how   the   structure   of   the \n             *      object   we   return   here   directly   matches   the   structure   of \n             *      the   GetPublicChannels   query . \n             */ \n             updateQuery :   ( prev ,   {   subscriptionData   })   =   { \n                 const   newEdges   =   [ \n                     ... prev . getChannel . messages . edges , \n                     { \n                         node :   { \n                             ... subscriptionData . data . subscribeToMessage . value , \n                         } \n                     } \n                 ]; \n                 return   { \n                     getChannel :   { \n                         messages :   { \n                             edges :   newEdges , \n                         } \n                     } \n                 }; \n             }, \n         }); \n     } \n\n     ...  }  const   MessagesWithData   =   compose ( \n   graphql ( ChannelMessagesQuery ,   { \n     options :   ( props )   =   { \n       const   channelId   =   props . params   ?   props . params . channelId   :   null ; \n       return   { \n         returnPartialData :   true , \n         variables :   { \n           channelId , \n           messageOrder :   [ \n             { \n               field :   createdAt , \n               direction :   ASC \n             } \n           ], \n         }, \n       }; \n     }, \n   }), \n   ...   //   We   compose   a   few   more   queries   in   the   actual   app .  )( Messages );  export   default   MessagesWithData ;    A few things are going on here. To make sense of what is happening, let's start from the logical beginning which actually occurs at the end of the file. See this line  const MessagesWithData = compose(graphql(ChannelMessagesQuery, ...));  towards the bottom of the snippet? This is the standard way to use Apollo to connect a React component with data from a GraphQL query. The  graphql  function will wrap our component in a higher-order component that grabs our data and makes it available to our component via its  props . In this example, we will be able to access our  Channel  data from our component with  this.props.data.getChannel  as soon as it is fetched.   Note: The  returnPartialData: true  option is important. When you want to use  subscribeToMore  to merge results into the result of a normal query it is necessary to specify this.   Okay so we have connected our component with a regular old GraphQL query, but how do we make it realtime? The key is the method  subscribeToMore .  Look at our  subscribeToNewMessages  method. Apollo's  graphql  function fits our component with the data prop that exposes the  subscribeToMore  method. We use this method to attach a subscription query which then calls the  updateQuery  method we pass in every time a new peice of data is pushed from the server. The object we return from  updateQuery  is then merged with our previous results and persisted in the client side cache. This way,  this.props.data.getChannel...  is always kept up to date and we can use it like normal to render our UI.  Take a minute to look over this file. Apollo does a great job allowing us to use realtime subscriptions alongside traditional queries and mutations. The combination of  subscribeToMore  and  updateQuery  offer a powerful set of tools to keep our UI up to date when dealing with realtime data!", 
            "title": "Using Subscriptions from React"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#user-authentication", 
            "text": "We have now covered the basics of how to use GraphQL subscriptions from both vanilla JS as well as React. We're now ready to finish up the surface area of our application! One of the nice things Scaphold does for you is handling user authentication. There is also an auth0 integration that lets you easily add social auth to any application instantly. In our Slackr app, we have enabled GitHub login so user's can easily chime in on our app without having to create any messy usernames or password.  Authentication with a Scaphold API is done via the  Authorization  http header. We use  JSON Web Tokens  to securely authenticate your users and have integrations that allow you to pull in the auth provider of your choice. You've actually already seen how to add authentication to Apollo Client.  Remember this from makeApolloClient.js?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 /* File: makeApolloClient.js */  const   networkInterface   =   createNetworkInterface ( graphqlUrl );  networkInterface . use ([{ \n     applyMiddleware ( req ,   next )   { \n         // Easy way to add authorization headers for every request \n         if   ( ! req . options . headers )   { \n             req . options . headers   =   {};    // Create the header object if needed. \n         } \n         if   ( localStorage . getItem ( scaphold_user_token ))   { \n             // This is how to authorize users using http auth headers \n             req . options . headers . Authorization   =   `Bearer  ${ localStorage . getItem ( scaphold_user_token ) } ` ; \n         } \n         next (); \n     },  }]);    This auth middleware looks for a token names 'scaphold_user_token' in the browser's local storage and then appends the necessary auth header to each request. This is great because all we need to do is pick a authentication mechanism and then save the token we get back from logging in to local storage and the middleware will handle the rest.", 
            "title": "User Authentication"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#social-authentication-for-any-application", 
            "text": "Slackr  uses Auth0 lock for easy authentication. To make this work, we must first add the Auth0 integration to our API on Scaphold. It's easy!  1) Go to  Auth0  and create a free account.  2) Under the Social connections tab on the left, enable GitHub as an oauth provider.\n    - You will need to create a GitHub application to get the clientId and secret to give to Auth0.  3) From the clients tab on the left in Auth0, open your application and grab your Auth0 clientId and client secret.  4) Go to Scaphold's integrations page and enter the clientId and client secret in a new Auth0 integration.  5) Presto chango, your API is now ready to handle social authentication!  One easy way to add authentication to your client app is by using Auth0 Lock. Lock is essentially a smart sign-in form that you can drop into any web or mobile application. You use Lock to handle the OAuth and then you can link the social credential with Scaphold's API using the  loginWithAuth0Lock  mutation that is now available in your API.  For a full example of how to do this take a look at  auth.js  and  channels.jsx  in our  Slackr  app starter kit.  The login flow is simple. First we open lock, the user then enters his or her credentials or chooses from a set of social auth providers, and then Lock handles the OAuth handshake and returns a login credential. We then make one more call to Auth0 to grab the auth0 profile and then we send the auth0 user identity to Scaphold's servers where it is then matched with a Scaphold user. As part of the  loginWithAuth0Lock  mutation payload, Scaphold will return the auth token that is to be stored in local storage on the client and attached to http requests as the Authorization header by the Apollo Client auth middleware.", 
            "title": "Social authentication for any application"
        }, 
        {
            "location": "/tutorials/realtime-apps-with-subscriptions/#wrapping-up", 
            "text": "Congrats! Now you've seen how you can use Scaphold, Apollo, and GraphQL subscriptions to build realtime, real-world applications in a fraction of the time it used to. To review what we did, we...    Defined our applications data model using Scaphold's Graphical Schema Designer and a realtime GraphQL API was automatically configured and deployed for us.    As soon as we finished designing our schema, we jumped over to GraphiQL to prototype our subscriptions query and saw data pushed to us in realitme.    We discussed how you can easily add realtime subscriptions to you own application using Apollo Client.    Last, we added social authentication to our API via the Auth0 Integration to allow our users to login via GitHub.    This is a great start but there is still alot we could do. We could start by adding permissions to our data for fine-grained access control which would allow us to create private channels. We could also instantly add iOS and Android push notifications so that we can alert our users when our application is closed. Stay tuned for more updates as more features come out daily!  Happy Scapholding!", 
            "title": "Wrapping Up"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/", 
            "text": "Step-by-step guide on sending push notifications with GraphQL\n\n\n\n\nAt \nScaphold\n, we\u2019ve talked to thousands of people from all walks of GraphQL life, and discovered that \nmobile is the next frontier for GraphQL tooling\n. Apollo has already done a wonderful job of strengthening the community with Apollo Client for \niOS\n and \nAndroid\n. And there\u2019s certainly more to come.\n\n\n\n\nWe\u2019re joining the mobile\u00a0effort!\n\n\n\n\n... With more GraphQL support for iOS and Android push notifications on Scaphold. In this guide, we\u2019ll show you how to send push notifications with a GraphQL API built to the open standard that works with both Apollo and Relay on any client platform.\n\n\nConfiguring Push Notifications with\u00a0GraphQL\n\n\nBefore we begin, make sure you have done the basic setup APNS (Apple Push Notication Service) and/or GCM (Google Cloud Messaging).\nIt\u2019s not the most straightforward process to get these accounts set up so we\u2019ve also written step-by-step guides to help you get started.\nIf needed, take a look at the relevant guide and come back here.\n\n\n\n\n\n\nSetup for iOS\n\n\n\n\n\n\nSetup for Android\n\n\n\n\n\n\nIf you have these tokens already, but don\u2019t have a GraphQL server at your disposal, the quickest way is to\n\nsign up for free on \nScaphold\n and create an app\n. As soon as you create an app,\nwe will deploy a GraphQL server backed by scalable AWS infrastructure.\nOnce you have an app, you can enable the relevant push notification integrations via the integration tab. The aforementioned setup guides will show you how.\n\n\nNow that we\u2019re on the same page, let\u2019s begin. The process for sending push notifications in any workflow\nstarts with your device token. It\u2019s a unique identifier for your app on your device specifically.\nThis is how APNS and GCM, or any other push notification hub for that matter, understand where to send your push notifications to.\n\n\n\n\n\ud83d\udc8c Think of a device token as a mailing address for push notifications.\n\n\n\n\nThis means that we\u2019re going to have to register each device token that\u2019s created on a particular device with Apple or Google, so that they have a registry of valid device tokens for our app.\n\n\nWe\u2019ll be using these working boilerplates for the remainder of this tutorial:\n\n\n\n\n\n\niOS boilerplate\n\n\n\n\n\n\nAndroid boilerplate\n\n\n\n\n\n\n1. Registering Device Tokens \n\u00a0Users.\n\n\nRun your app and make sure you \ngenerate a device token\n. The boilerplate will have this printed out in the console. It will look something like this:\n\n\niOS\n\n\n\n\nAndroid\n\n\n\n\nAssociate Token with a Valid\u00a0User\n\n\nIn order to use the device token to send a push notification, it\u2019s important that we associate a device token with a user in the app.\n\n\nThis is needed since let\u2019s say that \nUser A\n wants to send a push notification to \nUser B\n. The problem is that \nUser A\n will only have context of its own device token, but not the device token of \nUser B\n. However, \nUser A\n will most likely have the user ID of \nUser B\n, so we can send a push notification \nUser B\n in that manner, so long as \nUser B\n has a valid device token associated to that person.\n\n\nIn order to accomplish this, we must login first to obtain the user\u2019s authentication credentials.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n// Mutation\nmutation LoginUser ($user: LoginUserInput!) {\n  loginUser(input: $user) {\n    token\n    user {\n      id\n      username\n    }\n  }\n}\n\n// Variables\n{\n  \nuser\n: {\n    \nusername\n: \nelon@spacex.com\n,\n    \npassword\n: \nSuperSecretPassword\n\n  }\n}\n\n\n\n\n\n\nThe result of this mutation will provide an authentication token that you will need to set as the Authorization header for future requests.\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n      Thus, when we run the \ncreateDeviceToken\n mutation, the GraphQL server will know to connect the new device token with this particular user.\n    \n\n  \n\n\n\n\n\nThen, we run the \ncreateDeviceToken\n mutation to register the device token with APNS or GCM through our GraphQL server.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n// Mutation\nmutation CreateDeviceToken($input: CreateDeviceTokenInput!) {\n  createDeviceToken(input: $input) {\n    changedDeviceToken {\n      id\n      token\n      user {\n        id\n        username\n      }\n      platform\n      createdAt\n    }\n  }\n}\n\n// Variables\n{\n  \ninput\n:  {\n    \ntoken\n: \nYOUR_DEVICE_TOKEN\n,\n    \nplatform\n: \nAPNS_DEV\n // or GCM\n  }\n}\n\n\n\n\n\n\nThe GraphQL server understands that if the token was created already, the existing token instance will update instead of create a new one. Associating a token with a valid user can all be done in one step. Typically, following the login flow for your app, you should send an authenticated request to create the device token object on the server. This will create the token and associate the user altogether like above, so long as you have a valid authentication token in the header of your request.\n\n\n\n\nNow with this device token registered and associated to a user, we can start sending push notifications!\n\n\n\n\nSend Push Notification to\u00a0User\n\n\nSince we rarely know what the device token is for another user, Scaphold abstracts away the association of device token to user, meaning from your client app with \nUser A\n, you can send a push notification to User B only knowing that person\u2019s user ID.\n\n\nThis is a direct way of sending push notifications to a single user. \nRun this GraphQL mutation\n to send a push notification:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n// Mutation\nmutation SendToUser($notif: SendPushNotificationToUserInput!) {\n  sendPushNotificationToUser(input: $notif) {\n    changedPushConfirmation {\n      status\n      message {\n        APNS_DEV {\n          alert {\n            title\n            body\n          }\n          badge\n        }\n        GCM {\n          title\n          body\n          badge\n        }\n      }\n    }\n  }\n}\n\n// Variables\n{\n  \nnotif\n: {\n    \nuserId\n: \nVXNlcjox\n, // ID of User B\n    \nmessage\n: {\n      \nAPNS_DEV\n: {\n        \nalert\n: {\n          \ntitle\n: \nNew Message from Elon Musk\n,\n          \nbody\n: \nHey what\ns up Zuck?\n\n        },\n        \nbadge\n: 1\n      },\n      \nGCM\n: {\n        \ntitle\n: \nNew Message from Elon Musk\n,\n        \nbody\n: \nHey what\ns up Zuck?\n,\n        \nbadge\n: \n1\n\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\nNice! You just sent your first push notification with\u00a0GraphQL!\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \nSo what just happened?\n\n    \nWe sent a notification to both APNS and GCM so that any device from either platform associated with that user ID will receive the message.\n\n    \nThe way that each app receives notifications is through broadcast listeners.\n\n    \nFor iOS, the listener method is called: \ndidReceiveRemoteNotification\n in the \nAppDelegate\n file.\n\n    \nAnd on Android, the method is called: \nonReceive\n for the class that extends a \nBroadcastReceiver\n.\n\n  \n\n\n\n\n\n\n\nBonus: We\u2019ve included a mutation that allows you to send push notifications to a list of users all in one request with a \nlist of their user IDs\n. \ud83d\ude4c\n\n\n\n\n2. Managing Push Channels (Groups).\n\n\nOften times, you\u2019ll want to send push notifications to a group of people.\n\n\nPerhaps if you\u2019re running Facebook Messenger. Each time a new chat message is sent to a chat group, you\u2019ll want each person in that group to receive a notification that someone sent a new message, waiting to be read.\n\n\nCreate Push\u00a0Channel\n\n\nIn this case, we\u2019ve provided the ability to create and manage push notification channels for your app. These are unique by name. In the Facebook example, a new push channel would be created when a user decides to create a new chat group with his/her friends.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n// Mutation\nmutation CreateChannel ($channel: CreatePushChannelInput!) {\n  createPushChannel(input: $channel) {\n    changedPushChannel {\n      id\n      name\n    }\n  }\n}\n\n// Variables\n{\n  \nchannel\n: {\n    \nchannelName\n: \nZuck_Family\n\n  }\n}\n\n\n\n\n\n\nBut the channel (group) is still empty, so sending a push notification to this channel won\u2019t go to anyone right now.\n\n\nSubscribe to a Push\u00a0Channel\n\n\nIn order for a user to be part of this new push channel, a user needs to subscribe to the channel.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n// Mutation\nmutation Subscribe ($subscribe: SubscribeDeviceToChannelInput!) {\n  subscribeDeviceToChannel(input: $subscribe) {\n    changedDeviceToken {\n      token\n      user {\n        username\n      }\n    }\n  }\n}\n\n// Variables\n\nsubscribe\n: {\n    \ntoken\n: \nYOUR_DEVICE_TOKEN\n,\n    \nchannelName\n: \nZuck_Family\n\n  }\n}\n\n\n\n\n\n\nNow that we\u2019ve subscribed ourselves to Zuck\u2019s family\u2019s group chat thread \ud83d\ude02 we can start receiving push notifications whenever this channel is sent a new message. Currently, there\u2019s only one member in this group, but of course we can keep adding more users.\n\n\nSend Push Notification to\u00a0Channel\n\n\nLet\u2019s send a push notification to everyone who\u2019s subscribed to this channel in one request.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n// Mutation\nmutation SendToChannel ($msg: SendPushNotificationToChannelInput!) {\n  sendPushNotificationToChannel(input: $msg) {\n    changedPushConfirmation {\n      status\n      message {\n        APNS_DEV {\n          alert {\n            title\n            body\n          }\n          badge\n        }\n        GCM {\n          title\n          body\n          badge\n        }\n      }\n    }\n  }\n}\n\n// Variables\n{\n  \nmsg\n: {\n    \nchannelName\n: \nZuck_Family\n,\n    \nmessage\n: {\n      \nAPNS_DEV\n: {\n        \nalert\n: {\n          \ntitle\n: \nNew Message from Priscilla\n,\n          \nbody\n: \nWhere are the kids?\n\n        },\n        \nbadge\n: 1\n      },\n      \nGCM\n: {\n        \ntitle\n: \nNew Message from Priscilla\n,\n        \nbody\n: \nWhere are the kids?\n,\n        \nbadge\n: \n1\n\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\nNeat! We just sent a message to the Zuck family group\u00a0chat.\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \nThe result appears just the same as if the message were sent individually from one user to another.\n\n  \n\n\n\n\n\n\n\n\nGreat job \ud83c\udf89! You\u2019ve now learned how to send push notifications through GraphQL and set up your GraphQL server to handle this workflow in a flexible way.\n\n\nYou can take these practices of setting up a push notification system to your own GraphQL backend, but we can guarantee that \nScaphold\n makes it easier for you since you won\u2019t have to create an entirely new GraphQL server from scratch, manage device tokens and associations to user, let alone coordinate subscribing to channels.\n\n\nEnjoy how easy that was to set up a GraphQL server for iOS and Android push notifications? \nJoin \nScaphold\n today!\n\n\nAnd be sure to follow us on \nTwitter\n and \njoin our Slack\n for more awesome ways to learn about how to quickly launch your next app with GraphQL!", 
            "title": "Sending Push Notifications"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#step-by-step-guide-on-sending-push-notifications-with-graphql", 
            "text": "At  Scaphold , we\u2019ve talked to thousands of people from all walks of GraphQL life, and discovered that  mobile is the next frontier for GraphQL tooling . Apollo has already done a wonderful job of strengthening the community with Apollo Client for  iOS  and  Android . And there\u2019s certainly more to come.   We\u2019re joining the mobile\u00a0effort!   ... With more GraphQL support for iOS and Android push notifications on Scaphold. In this guide, we\u2019ll show you how to send push notifications with a GraphQL API built to the open standard that works with both Apollo and Relay on any client platform.", 
            "title": "Step-by-step guide on sending push notifications with GraphQL"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#configuring-push-notifications-with-graphql", 
            "text": "Before we begin, make sure you have done the basic setup APNS (Apple Push Notication Service) and/or GCM (Google Cloud Messaging).\nIt\u2019s not the most straightforward process to get these accounts set up so we\u2019ve also written step-by-step guides to help you get started.\nIf needed, take a look at the relevant guide and come back here.    Setup for iOS    Setup for Android    If you have these tokens already, but don\u2019t have a GraphQL server at your disposal, the quickest way is to sign up for free on  Scaphold  and create an app . As soon as you create an app,\nwe will deploy a GraphQL server backed by scalable AWS infrastructure.\nOnce you have an app, you can enable the relevant push notification integrations via the integration tab. The aforementioned setup guides will show you how.  Now that we\u2019re on the same page, let\u2019s begin. The process for sending push notifications in any workflow\nstarts with your device token. It\u2019s a unique identifier for your app on your device specifically.\nThis is how APNS and GCM, or any other push notification hub for that matter, understand where to send your push notifications to.   \ud83d\udc8c Think of a device token as a mailing address for push notifications.   This means that we\u2019re going to have to register each device token that\u2019s created on a particular device with Apple or Google, so that they have a registry of valid device tokens for our app.  We\u2019ll be using these working boilerplates for the remainder of this tutorial:    iOS boilerplate    Android boilerplate", 
            "title": "Configuring Push Notifications with\u00a0GraphQL"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#1-registering-device-tokens-users", 
            "text": "Run your app and make sure you  generate a device token . The boilerplate will have this printed out in the console. It will look something like this:", 
            "title": "1. Registering Device Tokens &amp;\u00a0Users."
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#ios", 
            "text": "", 
            "title": "iOS"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#android", 
            "text": "", 
            "title": "Android"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#associate-token-with-a-valid-user", 
            "text": "In order to use the device token to send a push notification, it\u2019s important that we associate a device token with a user in the app.  This is needed since let\u2019s say that  User A  wants to send a push notification to  User B . The problem is that  User A  will only have context of its own device token, but not the device token of  User B . However,  User A  will most likely have the user ID of  User B , so we can send a push notification  User B  in that manner, so long as  User B  has a valid device token associated to that person.  In order to accomplish this, we must login first to obtain the user\u2019s authentication credentials.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 // Mutation\nmutation LoginUser ($user: LoginUserInput!) {\n  loginUser(input: $user) {\n    token\n    user {\n      id\n      username\n    }\n  }\n}\n\n// Variables\n{\n   user : {\n     username :  elon@spacex.com ,\n     password :  SuperSecretPassword \n  }\n}   The result of this mutation will provide an authentication token that you will need to set as the Authorization header for future requests.  \n   \n     \n   \n   \n     \n      Thus, when we run the  createDeviceToken  mutation, the GraphQL server will know to connect the new device token with this particular user.\n     \n     Then, we run the  createDeviceToken  mutation to register the device token with APNS or GCM through our GraphQL server.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 // Mutation\nmutation CreateDeviceToken($input: CreateDeviceTokenInput!) {\n  createDeviceToken(input: $input) {\n    changedDeviceToken {\n      id\n      token\n      user {\n        id\n        username\n      }\n      platform\n      createdAt\n    }\n  }\n}\n\n// Variables\n{\n   input :  {\n     token :  YOUR_DEVICE_TOKEN ,\n     platform :  APNS_DEV  // or GCM\n  }\n}   The GraphQL server understands that if the token was created already, the existing token instance will update instead of create a new one. Associating a token with a valid user can all be done in one step. Typically, following the login flow for your app, you should send an authenticated request to create the device token object on the server. This will create the token and associate the user altogether like above, so long as you have a valid authentication token in the header of your request.   Now with this device token registered and associated to a user, we can start sending push notifications!", 
            "title": "Associate Token with a Valid\u00a0User"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#send-push-notification-to-user", 
            "text": "Since we rarely know what the device token is for another user, Scaphold abstracts away the association of device token to user, meaning from your client app with  User A , you can send a push notification to User B only knowing that person\u2019s user ID.  This is a direct way of sending push notifications to a single user.  Run this GraphQL mutation  to send a push notification:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 // Mutation\nmutation SendToUser($notif: SendPushNotificationToUserInput!) {\n  sendPushNotificationToUser(input: $notif) {\n    changedPushConfirmation {\n      status\n      message {\n        APNS_DEV {\n          alert {\n            title\n            body\n          }\n          badge\n        }\n        GCM {\n          title\n          body\n          badge\n        }\n      }\n    }\n  }\n}\n\n// Variables\n{\n   notif : {\n     userId :  VXNlcjox , // ID of User B\n     message : {\n       APNS_DEV : {\n         alert : {\n           title :  New Message from Elon Musk ,\n           body :  Hey what s up Zuck? \n        },\n         badge : 1\n      },\n       GCM : {\n         title :  New Message from Elon Musk ,\n         body :  Hey what s up Zuck? ,\n         badge :  1 \n      }\n    }\n  }\n}    Nice! You just sent your first push notification with\u00a0GraphQL!   \n   \n     \n   \n   \n     So what just happened? \n     We sent a notification to both APNS and GCM so that any device from either platform associated with that user ID will receive the message. \n     The way that each app receives notifications is through broadcast listeners. \n     For iOS, the listener method is called:  didReceiveRemoteNotification  in the  AppDelegate  file. \n     And on Android, the method is called:  onReceive  for the class that extends a  BroadcastReceiver . \n      Bonus: We\u2019ve included a mutation that allows you to send push notifications to a list of users all in one request with a  list of their user IDs . \ud83d\ude4c", 
            "title": "Send Push Notification to\u00a0User"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#2-managing-push-channels-groups", 
            "text": "Often times, you\u2019ll want to send push notifications to a group of people.  Perhaps if you\u2019re running Facebook Messenger. Each time a new chat message is sent to a chat group, you\u2019ll want each person in that group to receive a notification that someone sent a new message, waiting to be read.", 
            "title": "2. Managing Push Channels (Groups)."
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#create-push-channel", 
            "text": "In this case, we\u2019ve provided the ability to create and manage push notification channels for your app. These are unique by name. In the Facebook example, a new push channel would be created when a user decides to create a new chat group with his/her friends.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 // Mutation\nmutation CreateChannel ($channel: CreatePushChannelInput!) {\n  createPushChannel(input: $channel) {\n    changedPushChannel {\n      id\n      name\n    }\n  }\n}\n\n// Variables\n{\n   channel : {\n     channelName :  Zuck_Family \n  }\n}   But the channel (group) is still empty, so sending a push notification to this channel won\u2019t go to anyone right now.", 
            "title": "Create Push\u00a0Channel"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#subscribe-to-a-push-channel", 
            "text": "In order for a user to be part of this new push channel, a user needs to subscribe to the channel.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 // Mutation\nmutation Subscribe ($subscribe: SubscribeDeviceToChannelInput!) {\n  subscribeDeviceToChannel(input: $subscribe) {\n    changedDeviceToken {\n      token\n      user {\n        username\n      }\n    }\n  }\n}\n\n// Variables subscribe : {\n     token :  YOUR_DEVICE_TOKEN ,\n     channelName :  Zuck_Family \n  }\n}   Now that we\u2019ve subscribed ourselves to Zuck\u2019s family\u2019s group chat thread \ud83d\ude02 we can start receiving push notifications whenever this channel is sent a new message. Currently, there\u2019s only one member in this group, but of course we can keep adding more users.", 
            "title": "Subscribe to a Push\u00a0Channel"
        }, 
        {
            "location": "/tutorials/sending-push-notifications/#send-push-notification-to-channel", 
            "text": "Let\u2019s send a push notification to everyone who\u2019s subscribed to this channel in one request.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 // Mutation\nmutation SendToChannel ($msg: SendPushNotificationToChannelInput!) {\n  sendPushNotificationToChannel(input: $msg) {\n    changedPushConfirmation {\n      status\n      message {\n        APNS_DEV {\n          alert {\n            title\n            body\n          }\n          badge\n        }\n        GCM {\n          title\n          body\n          badge\n        }\n      }\n    }\n  }\n}\n\n// Variables\n{\n   msg : {\n     channelName :  Zuck_Family ,\n     message : {\n       APNS_DEV : {\n         alert : {\n           title :  New Message from Priscilla ,\n           body :  Where are the kids? \n        },\n         badge : 1\n      },\n       GCM : {\n         title :  New Message from Priscilla ,\n         body :  Where are the kids? ,\n         badge :  1 \n      }\n    }\n  }\n}    Neat! We just sent a message to the Zuck family group\u00a0chat.   \n   \n     \n   \n   \n     The result appears just the same as if the message were sent individually from one user to another. \n      Great job \ud83c\udf89! You\u2019ve now learned how to send push notifications through GraphQL and set up your GraphQL server to handle this workflow in a flexible way.  You can take these practices of setting up a push notification system to your own GraphQL backend, but we can guarantee that  Scaphold  makes it easier for you since you won\u2019t have to create an entirely new GraphQL server from scratch, manage device tokens and associations to user, let alone coordinate subscribing to channels.  Enjoy how easy that was to set up a GraphQL server for iOS and Android push notifications?  Join  Scaphold  today!  And be sure to follow us on  Twitter  and  join our Slack  for more awesome ways to learn about how to quickly launch your next app with GraphQL!", 
            "title": "Send Push Notification to\u00a0Channel"
        }, 
        {
            "location": "/tutorials/ios-push-notifications/", 
            "text": "Step-by-step guide on setting up Apple push notifications for your GraphQL backend\n\n\n\n\nCalling all iOS mobile developers! Today, we\u2019re going to walk you through how to set up Apple push notifications for your GraphQL server.\n\n\n\n\nIt\u2019s about time for mobile to get some GraphQL love.\u00a0\u2764\ufe0f\n\n\n\n\nWe\u2019re going to cut right to the chase with the \n4 steps\n to get you set up right away with iOS push notifications.\n\n\n\n\nPrerequisite: You must have an Apple Developer Account and an actual iOS device configured for development. Learn how to configure your device \nhere\n.\n\n\n\n\n1. Create and register your iOS\u00a0app.\n\n\nWe\u2019re going to start off by creating an iOS app. To make it easier for you, we\u2019ve provided a starter kit that goes along with this guide.\n\n\nDownload the starter kit here.\n\n\nOnce we\u2019ve created the app, we\u2019ll want to add it to the Apple Developer Center.\n\n\nFirst, under \nTargets \n General\n, ensure that your Bundle ID is unique.\n\n\n\n\nNext, under \nTargets \n Capabilities\n, enable Push Notifications.\n\n\n\n\nOnce this happens, you\u2019ll have an App ID associated with your Apple Developer profile that has push capabilities.\n\n\n\n\n2. Obtain certificates (APNS SSL Certificate \n App Private\u00a0Key).\n\n\nHere, you\u2019ll be creating certificates to configure your GraphQL server for sending mobile push notification messages.\n\n\nAPNS SSL Certificate\n\n\nGo to the \nApple Development Center\n to create a certificate. You can create two types of SSL certificates (Production \n Development). We\u2019ll create a Development version for this tutorial.\n\n\n\n\nFollow along and select the correct App ID associated with your app.\n\n\n\n\nUsing \nKeychain Access\n on your computer, follow the instructions on the next page to request a certificate from a certificate authority. Define an email address and name for your key. Leave the \u201cCA Email Address\u201d field blank.\n\n\n\n\nUpload the \nCertificateSigningRequest.certSigningRequest\n file that was just downloaded on the next screen.\n\n\n\n\nAfter successful completion of these steps, make sure you download your generated\u00a0\n.cer\n file.\n\n\nNow, convert the APNS SSL certificate from\u00a0\n.cer\n format to\u00a0\n.pem\n format. Using the openssl utility on your computer, run this command in your terminal. Be sure to replace \nmynsappcert.cer\n with the name of the certificate you downloaded from the Apple Developer site.\n\n\n1\nopenssl x509 -in myapnsappcert.cer -inform DER -out myapnsappcert.pem\n\n\n\n\n\n\nHold onto your SSL certificate (\n.pem\n file) for use later.\n\n\nApp Private Key\n\n\nIn order to create an app private key that\u2019s associated with your SSL certificate, you should export it from the Keychain Access application on your computer. Be sure you\u2019re exporting the \nprivate key\n.\n\n\n\n\nCreate a password for your private key and save it as a\u00a0\n.p12\n file format.\n\n\n\n\nAfter downloading the private key, run this command to convert the app private key from a\u00a0\n.p12\n format to a\u00a0\n.pem\n format. Again, be sure to replace \nmynsappcert.cer\n with the name of app private key you just created. You\u2019ll also be prompted to type in the password you created a minute ago for your private key.\n\n\n1\nopenssl pkcs12 -in myapnsappprivatekey.p12 -out myapnsappprivatekey.pem -nodes -clcerts\n\n\n\n\n\n\nVerify\n\n\nYou can verify that your APNS SSL certificate (\n.pem\n) and your App Private Key (\n.pem\n) are valid by connecting them to APNS.\n\n\nRun this command to do so, and as always, ensure that you\u2019re using your own key names.\n\n\n1\nopenssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert myapnsappcert.pem -key myapnsappprivatekey.pem\n\n\n\n\n\n\nIf successful, you should get a response that completes with:\n\n\n1\nVerify return code: 0 (ok)\n\n\n\n\n\n\n\n\nGood work.\u00a0\u2705\n\n\n\n\n3. Integrate your GraphQL server with\u00a0APNS.\n\n\nNow, it\u2019s time to connect your GraphQL server with APNS so that you can actually send push notifications.\n\n\nTo make it easy, \nScaphold.io\n provides an easy way to set up your very own GraphQL server for free in minutes. \nSign up for an account\n and \ncreate an app\n. At this point, you instantly have a GraphQL server deployed in production, ready to make requests.\n\n\nNow, go to Scaphold\u2019s Integrations Portal to enable iOS push notifications for development. \nClick Add\n to begin.\n\n\n\n\nA form will then pop up, asking for your SSL Certificate file and your App Private Key file. Drop them into the appropriate boxes and \nhit Create\n.\n\n\n\n  \n\n\n\n\n\nGood job! You\u2019ve now connected your GraphQL server to be able to send push notifications to devices with your app installed.\n\n\n4. Obtain a device token to send push notifications.\n\n\nIn order to send a push notification to a device, we need to generate a device token that is a unique identifier for a device and an app together. In that case, we\u2019ll need to install your app onto an actual Apple device.\n\n\nBut first, we need to create an event handler to receive the device token once a user permits the app to send push notifications to their phone. In your app, you\u2019ll need to put the following snippet in your AppDelegate file:\n\n\n1\n2\n3\n-\n \n(\nvoid\n)\napplication:\n(\nUIApplication\n*\n)\napplication\n \ndidRegisterForRemoteNotificationsWithDeviceToken:\n(\nNSData\n*\n)\ndeviceToken\n \n{\n\n    \nNSLog\n(\n@\ndeviceToken: %@\n,\n \ndeviceToken\n);\n\n\n}\n\n\n\n\n\n\n\nWe\u2019re going to be using the \nboilerplate code from earlier\n to illustrate.\n\n\nNow install your app on your Apple device by pressing the big \u25b6\ufe0f button in the top bar of Xcode.\n\n\n\n\nNote: An actual device is needed since the simulator is transient and cannot have a device token associated to it.\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n      Once the app is installed and run, you\u2019ll get a notification that prompts the user to allow push notifications to be sent to the device. And surely, hit Allow.\n    \n\n    \n\n      Upon success, your device token will be issued by APNS and printed out in your Xcode console.\n    \n\n  \n\n\n\n\n\n\n\nSave this device token and send it to Scaphold to register it on your behalf with APNS. This take the form of sending a GraphQL mutation from your app, but for demonstration purposes, we\u2019ll use GraphiQL to do so.\n\n\n\n\n\n\n\nCongratulations! You\u2019ve successfully configured your app and device to be able to send and receive iOS push notifications. And the best part is that it was all done with GraphQL.\n\n\nNow that your GraphQL server is set up for iOS push notifications, the next part of this guide will walk you through how to...\n\n\n\n\nSend push notifications\n\n\nAssociate users to device tokens\n\n\nManage push channels (i.e. groups)\n\n\n\n\nThanks for following along! We'll walk you through sending your first push notification with GraphQL in \nthe next part of this tutorial\n.\n\n\nLooking for how to set up Android push notifications with GCM? \nFollow along here!\n\n\nEnjoy how easy that was to set up a GraphQL server? \nJoin Scaphold today!\n And be sure to follow us on \nTwitter\n or join our \nSlack\n for more awesome ways to learn about how to quickly launch your next app with GraphQL!", 
            "title": "Setup iOS Push"
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#step-by-step-guide-on-setting-up-apple-push-notifications-for-your-graphql-backend", 
            "text": "Calling all iOS mobile developers! Today, we\u2019re going to walk you through how to set up Apple push notifications for your GraphQL server.   It\u2019s about time for mobile to get some GraphQL love.\u00a0\u2764\ufe0f   We\u2019re going to cut right to the chase with the  4 steps  to get you set up right away with iOS push notifications.   Prerequisite: You must have an Apple Developer Account and an actual iOS device configured for development. Learn how to configure your device  here .", 
            "title": "Step-by-step guide on setting up Apple push notifications for your GraphQL backend"
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#1-create-and-register-your-ios-app", 
            "text": "We\u2019re going to start off by creating an iOS app. To make it easier for you, we\u2019ve provided a starter kit that goes along with this guide.  Download the starter kit here.  Once we\u2019ve created the app, we\u2019ll want to add it to the Apple Developer Center.  First, under  Targets   General , ensure that your Bundle ID is unique.   Next, under  Targets   Capabilities , enable Push Notifications.   Once this happens, you\u2019ll have an App ID associated with your Apple Developer profile that has push capabilities.", 
            "title": "1. Create and register your iOS\u00a0app."
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#2-obtain-certificates-apns-ssl-certificate-app-private-key", 
            "text": "Here, you\u2019ll be creating certificates to configure your GraphQL server for sending mobile push notification messages.", 
            "title": "2. Obtain certificates (APNS SSL Certificate &amp; App Private\u00a0Key)."
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#apns-ssl-certificate", 
            "text": "Go to the  Apple Development Center  to create a certificate. You can create two types of SSL certificates (Production   Development). We\u2019ll create a Development version for this tutorial.   Follow along and select the correct App ID associated with your app.   Using  Keychain Access  on your computer, follow the instructions on the next page to request a certificate from a certificate authority. Define an email address and name for your key. Leave the \u201cCA Email Address\u201d field blank.   Upload the  CertificateSigningRequest.certSigningRequest  file that was just downloaded on the next screen.   After successful completion of these steps, make sure you download your generated\u00a0 .cer  file.  Now, convert the APNS SSL certificate from\u00a0 .cer  format to\u00a0 .pem  format. Using the openssl utility on your computer, run this command in your terminal. Be sure to replace  mynsappcert.cer  with the name of the certificate you downloaded from the Apple Developer site.  1 openssl x509 -in myapnsappcert.cer -inform DER -out myapnsappcert.pem   Hold onto your SSL certificate ( .pem  file) for use later.", 
            "title": "APNS SSL Certificate"
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#app-private-key", 
            "text": "In order to create an app private key that\u2019s associated with your SSL certificate, you should export it from the Keychain Access application on your computer. Be sure you\u2019re exporting the  private key .   Create a password for your private key and save it as a\u00a0 .p12  file format.   After downloading the private key, run this command to convert the app private key from a\u00a0 .p12  format to a\u00a0 .pem  format. Again, be sure to replace  mynsappcert.cer  with the name of app private key you just created. You\u2019ll also be prompted to type in the password you created a minute ago for your private key.  1 openssl pkcs12 -in myapnsappprivatekey.p12 -out myapnsappprivatekey.pem -nodes -clcerts", 
            "title": "App Private Key"
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#verify", 
            "text": "You can verify that your APNS SSL certificate ( .pem ) and your App Private Key ( .pem ) are valid by connecting them to APNS.  Run this command to do so, and as always, ensure that you\u2019re using your own key names.  1 openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert myapnsappcert.pem -key myapnsappprivatekey.pem   If successful, you should get a response that completes with:  1 Verify return code: 0 (ok)    Good work.\u00a0\u2705", 
            "title": "Verify"
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#3-integrate-your-graphql-server-with-apns", 
            "text": "Now, it\u2019s time to connect your GraphQL server with APNS so that you can actually send push notifications.  To make it easy,  Scaphold.io  provides an easy way to set up your very own GraphQL server for free in minutes.  Sign up for an account  and  create an app . At this point, you instantly have a GraphQL server deployed in production, ready to make requests.  Now, go to Scaphold\u2019s Integrations Portal to enable iOS push notifications for development.  Click Add  to begin.   A form will then pop up, asking for your SSL Certificate file and your App Private Key file. Drop them into the appropriate boxes and  hit Create .  \n     Good job! You\u2019ve now connected your GraphQL server to be able to send push notifications to devices with your app installed.", 
            "title": "3. Integrate your GraphQL server with\u00a0APNS."
        }, 
        {
            "location": "/tutorials/ios-push-notifications/#4-obtain-a-device-token-to-send-push-notifications", 
            "text": "In order to send a push notification to a device, we need to generate a device token that is a unique identifier for a device and an app together. In that case, we\u2019ll need to install your app onto an actual Apple device.  But first, we need to create an event handler to receive the device token once a user permits the app to send push notifications to their phone. In your app, you\u2019ll need to put the following snippet in your AppDelegate file:  1\n2\n3 -   ( void ) application: ( UIApplication * ) application   didRegisterForRemoteNotificationsWithDeviceToken: ( NSData * ) deviceToken   { \n     NSLog ( @ deviceToken: %@ ,   deviceToken );  }    We\u2019re going to be using the  boilerplate code from earlier  to illustrate.  Now install your app on your Apple device by pressing the big \u25b6\ufe0f button in the top bar of Xcode.   Note: An actual device is needed since the simulator is transient and cannot have a device token associated to it.   \n   \n     \n   \n   \n     \n      Once the app is installed and run, you\u2019ll get a notification that prompts the user to allow push notifications to be sent to the device. And surely, hit Allow.\n     \n     \n      Upon success, your device token will be issued by APNS and printed out in your Xcode console.\n     \n      Save this device token and send it to Scaphold to register it on your behalf with APNS. This take the form of sending a GraphQL mutation from your app, but for demonstration purposes, we\u2019ll use GraphiQL to do so.    Congratulations! You\u2019ve successfully configured your app and device to be able to send and receive iOS push notifications. And the best part is that it was all done with GraphQL.  Now that your GraphQL server is set up for iOS push notifications, the next part of this guide will walk you through how to...   Send push notifications  Associate users to device tokens  Manage push channels (i.e. groups)   Thanks for following along! We'll walk you through sending your first push notification with GraphQL in  the next part of this tutorial .  Looking for how to set up Android push notifications with GCM?  Follow along here!  Enjoy how easy that was to set up a GraphQL server?  Join Scaphold today!  And be sure to follow us on  Twitter  or join our  Slack  for more awesome ways to learn about how to quickly launch your next app with GraphQL!", 
            "title": "4. Obtain a device token to send push notifications."
        }, 
        {
            "location": "/tutorials/android-push-notifications/", 
            "text": "Step-by-step guide on setting up Apple push notifications for your GraphQL backend\n\n\n\n\nCalling all Android mobile developers! Today, we\u2019re going to walk you through how to set up Android push notifications for your GraphQL server.\n\n\n\n\nIt\u2019s about time for mobile to get some GraphQL love.\u00a0\u2764\ufe0f\n\n\n\n\nWe\u2019re going to cut right to the chase with the \n3 steps\n to get you set up right away with Android push notifications.\n\n\n\n\nPrerequisite: You must have an actual Android device configured for development.\n\n\n\n\n1. Create a Google API project to enable\u00a0GCM.\n\n\nWe\u2019re going to start off by creating an Android app. To make it easier for you, we\u2019ve provided a starter kit that goes along with this guide.\n\n\nDownload the starter kit here\n.\n\n\nOnce we\u2019ve created the app, we\u2019ll want to connect it to a Google project. Please go to your \nGoogle Developer Console\n and \ncreate a new project\n.\n\n\n\n\nOnce you\u2019ve created your Google project, you\u2019ll have to also create a new Firebase project at the \nFirebase console\n.\n\n\n\n\n\n\nWhy do we have to go to Firebase? Google now only provides GCM push notification support through the Firebase console. \ud83d\ude24\n\n\n\n\n\n  \n\n\n\n\n\nFollow the steps to finish creating your app, then \nAdd Firebase to your Android app\n.\n\n\n\n\nWe\u2019ll need your \nPackage Name (or Application ID)\n. Find your package name here in your app:\n\n\n\n\nThe \nnickname\n is your choice. Your first step should look like this.\n\n\n\n  \n\n\n\n\n\nAfter adding the app, you\u2019ll download a Google Service JSON file that you\u2019ll need to import into your project. Place it in your \napp\n directory.\n\n\n\n  \n\n\n\n\n\nGreat! Now you\u2019ll need to update the following dependencies in your Android app.\n\n\n\n\n\n\nApp-level \nbundle.gradle\n:\n\n\n\n\n\n\n\n\nProject-level \nbundle.gradle\n:\n\n\n\n\n\n\n\n\nAnd finally, you\u2019ll need to update your strings.xml constants file to reflect the App ID of the newly created Google project.\n\n\n\n\n\n\nNice work \u2705 Your Android app and Google project are now connected!\n\n\n\n\n2. Integrate your GraphQL server with\u00a0GCM.\n\n\nNow, it\u2019s time to connect your GraphQL server with GCM so that you can actually send push notifications.\n\n\nLet\u2019s first grab your \nServer API Key\n that was auto-generated by Google after successful completion of the previous process of connecting your Android app with your Google project. You\u2019ll need to find it in your Google Developer Console.\n\n\nOpen up the left side panel\n by clicking the top-left hamburger menu, and navigate to the \nAPI Manager\n.\n\n\n\n\nNow click the \nCredentials\n tab on the left-hand menu to grab your \nServer API Key\n. Save this. You\u2019ll need it in the next step to connect to your GraphQL server.\n\n\n\n\nTo make it easy, \nScaphold.io\n provides an easy way to set up your very own GraphQL server for free in minutes. \nSign up for an account\n and \ncreate an app\n. At this point, you instantly have a GraphQL server deployed in production, ready to make requests.\n\n\nNow, go to Scaphold\u2019s Integrations Portal to enable Android push notifications for development. \nClick Add\n to begin.\n\n\n\n\nA form will then pop up, asking for your \nServer API Key\n. Fill out the appropriate fields and \nhit Create\n.\n\n\n\n  \n\n\n\n\n\nGood job! You\u2019ve now connected your GraphQL server to be able to send push notifications to devices with your app installed.\n\n\n3. Obtain a device token to send push notifications.\n\n\nIn order to send a push notification to a device, we need to generate a device token that is a unique identifier for a device and an app together. In that case, we\u2019ll need to install your app onto an actual Android device.\n\n\nBut first, we need to create an event handler to receive the device token once a user permits the app to send push notifications to their phone. In your app, you\u2019ll need to put the following snippet in your ExternalReceiver file (i.e. class that extends BroadcastReceiver):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\npublic\n \nclass\n \nExternalReceiver\n \nextends\n \nBroadcastReceiver\n \n{\n\n  \nprivate\n \nvoid\n \nregister\n()\n \n{\n\n    \nnew\n \nAsyncTask\n(){\n\n      \nprotected\n \nObject\n \ndoInBackground\n(\nfinal\n \nObject\n...\n \nparams\n)\n \n{\n\n        \nString\n \ntoken\n;\n\n        \ntry\n \n{\n\n          \ntoken\n \n=\n \ngcm\n.\nregister\n(\ngetString\n(\nR\n.\nstring\n.\nproject_number\n));\n\n          \nLog\n.\ni\n(\nregistrationId\n,\n \ntoken\n);\n\n        \n}\n\n        \ncatch\n \n(\nIOException\n \ne\n)\n \n{\n\n          \nLog\n.\ni\n(\nRegistration Error\n,\n \ne\n.\ngetMessage\n());\n\n        \n}\n\n        \nreturn\n \ntrue\n;\n\n      \n}\n\n    \n}.\nexecute\n(\nnull\n,\n \nnull\n,\n \nnull\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWe\u2019re going to be using the \nboilerplate code from earlier\n to illustrate.\n\n\nNow install your app on your Android device by pressing the big \u25b6\ufe0f button in the top bar of Android Studio.\n\n\n\n\nNote: An actual device is needed since the simulator is transient and cannot have a device token associated to it.\n\n\n\n\nUpon success, your device token will be issued by GCM and printed out in your Android Studio console.\n\n\n\n\nSave this device token and send it to Scaphold to register it on your behalf with GCM. This take the form of sending a GraphQL mutation from your app, but for demonstration purposes, we\u2019ll use GraphiQL to do so.\n\n\n\n\n\n\n\nCongratulations! You\u2019ve successfully configured your app and device to be able to send and receive iOS push notifications. And the best part is that it was all done with GraphQL.\n\n\nNow that your GraphQL server is set up for iOS push notifications, the next part of this guide will walk you through how to...\n\n\n\n\nSend push notifications\n\n\nAssociate users to device tokens\n\n\nManage push channels (i.e. groups)\n\n\n\n\nThanks for following along! We'll walk you through sending your first push notification with GraphQL in \nthe next part of this tutorial\n.\n\n\nLooking for how to set up iOS push notifications with APNS? \nFollow along here!\n\n\nEnjoy how easy that was to set up a GraphQL server? \nJoin Scaphold today!\n And be sure to follow us on \nTwitter\n or join our \nSlack\n for more awesome ways to learn about how to quickly launch your next app with GraphQL!", 
            "title": "Setup Android Push"
        }, 
        {
            "location": "/tutorials/android-push-notifications/#step-by-step-guide-on-setting-up-apple-push-notifications-for-your-graphql-backend", 
            "text": "Calling all Android mobile developers! Today, we\u2019re going to walk you through how to set up Android push notifications for your GraphQL server.   It\u2019s about time for mobile to get some GraphQL love.\u00a0\u2764\ufe0f   We\u2019re going to cut right to the chase with the  3 steps  to get you set up right away with Android push notifications.   Prerequisite: You must have an actual Android device configured for development.", 
            "title": "Step-by-step guide on setting up Apple push notifications for your GraphQL backend"
        }, 
        {
            "location": "/tutorials/android-push-notifications/#1-create-a-google-api-project-to-enable-gcm", 
            "text": "We\u2019re going to start off by creating an Android app. To make it easier for you, we\u2019ve provided a starter kit that goes along with this guide.  Download the starter kit here .  Once we\u2019ve created the app, we\u2019ll want to connect it to a Google project. Please go to your  Google Developer Console  and  create a new project .   Once you\u2019ve created your Google project, you\u2019ll have to also create a new Firebase project at the  Firebase console .    Why do we have to go to Firebase? Google now only provides GCM push notification support through the Firebase console. \ud83d\ude24   \n     Follow the steps to finish creating your app, then  Add Firebase to your Android app .   We\u2019ll need your  Package Name (or Application ID) . Find your package name here in your app:   The  nickname  is your choice. Your first step should look like this.  \n     After adding the app, you\u2019ll download a Google Service JSON file that you\u2019ll need to import into your project. Place it in your  app  directory.  \n     Great! Now you\u2019ll need to update the following dependencies in your Android app.    App-level  bundle.gradle :     Project-level  bundle.gradle :     And finally, you\u2019ll need to update your strings.xml constants file to reflect the App ID of the newly created Google project.    Nice work \u2705 Your Android app and Google project are now connected!", 
            "title": "1. Create a Google API project to enable\u00a0GCM."
        }, 
        {
            "location": "/tutorials/android-push-notifications/#2-integrate-your-graphql-server-with-gcm", 
            "text": "Now, it\u2019s time to connect your GraphQL server with GCM so that you can actually send push notifications.  Let\u2019s first grab your  Server API Key  that was auto-generated by Google after successful completion of the previous process of connecting your Android app with your Google project. You\u2019ll need to find it in your Google Developer Console.  Open up the left side panel  by clicking the top-left hamburger menu, and navigate to the  API Manager .   Now click the  Credentials  tab on the left-hand menu to grab your  Server API Key . Save this. You\u2019ll need it in the next step to connect to your GraphQL server.   To make it easy,  Scaphold.io  provides an easy way to set up your very own GraphQL server for free in minutes.  Sign up for an account  and  create an app . At this point, you instantly have a GraphQL server deployed in production, ready to make requests.  Now, go to Scaphold\u2019s Integrations Portal to enable Android push notifications for development.  Click Add  to begin.   A form will then pop up, asking for your  Server API Key . Fill out the appropriate fields and  hit Create .  \n     Good job! You\u2019ve now connected your GraphQL server to be able to send push notifications to devices with your app installed.", 
            "title": "2. Integrate your GraphQL server with\u00a0GCM."
        }, 
        {
            "location": "/tutorials/android-push-notifications/#3-obtain-a-device-token-to-send-push-notifications", 
            "text": "In order to send a push notification to a device, we need to generate a device token that is a unique identifier for a device and an app together. In that case, we\u2019ll need to install your app onto an actual Android device.  But first, we need to create an event handler to receive the device token once a user permits the app to send push notifications to their phone. In your app, you\u2019ll need to put the following snippet in your ExternalReceiver file (i.e. class that extends BroadcastReceiver):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 public   class   ExternalReceiver   extends   BroadcastReceiver   { \n   private   void   register ()   { \n     new   AsyncTask (){ \n       protected   Object   doInBackground ( final   Object ...   params )   { \n         String   token ; \n         try   { \n           token   =   gcm . register ( getString ( R . string . project_number )); \n           Log . i ( registrationId ,   token ); \n         } \n         catch   ( IOException   e )   { \n           Log . i ( Registration Error ,   e . getMessage ()); \n         } \n         return   true ; \n       } \n     }. execute ( null ,   null ,   null ); \n   }  }    We\u2019re going to be using the  boilerplate code from earlier  to illustrate.  Now install your app on your Android device by pressing the big \u25b6\ufe0f button in the top bar of Android Studio.   Note: An actual device is needed since the simulator is transient and cannot have a device token associated to it.   Upon success, your device token will be issued by GCM and printed out in your Android Studio console.   Save this device token and send it to Scaphold to register it on your behalf with GCM. This take the form of sending a GraphQL mutation from your app, but for demonstration purposes, we\u2019ll use GraphiQL to do so.    Congratulations! You\u2019ve successfully configured your app and device to be able to send and receive iOS push notifications. And the best part is that it was all done with GraphQL.  Now that your GraphQL server is set up for iOS push notifications, the next part of this guide will walk you through how to...   Send push notifications  Associate users to device tokens  Manage push channels (i.e. groups)   Thanks for following along! We'll walk you through sending your first push notification with GraphQL in  the next part of this tutorial .  Looking for how to set up iOS push notifications with APNS?  Follow along here!  Enjoy how easy that was to set up a GraphQL server?  Join Scaphold today!  And be sure to follow us on  Twitter  or join our  Slack  for more awesome ways to learn about how to quickly launch your next app with GraphQL!", 
            "title": "3. Obtain a device token to send push notifications."
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/", 
            "text": "Migrating from MongoDB to GraphQL\n\n\nHey!\n\n\nToday I'm going to demonstrate how I migrated a MongoDB collection to GraphQL. With Parse shutting\ndown at the end of the month, there are a lot of applications are looking for a new home for their data\nand since GraphQL is the future, it's a great time to migrate! I was genuinely surprised by how easy\nthe process was so here is a little guide so you can migrate your data yourself.\n\n\nStep 1: Define the schema\n\n\nThe first step in migrating your data is to prepare your GraphQL schema. I'll be using\n\nMongoDB's sample\nrestaurants collection found here\n.\nThe restaurants collection is defined by a pretty simple Schema. We're going to change a few field names for consistency\nand our migration script will handle transforming each data item. Here is our final schema:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\ntype Restaurant implements Node {\n  id: ID!\n  name: String!\n  mongoId: String!\n  cuisine: String!\n  borough: String!\n  address: Address!\n  grades: [Grade]\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\ntype Address {\n  zipcode: String!\n  street: String!\n  coord: [Float]\n  building: String\n}\n\ntype Grade {\n  score: String!\n  grade: String\n  date: DateTime!\n}\n\n\n\n\n\n\nThat's it!\n\n\n\n\nNotice that our \nGrade\n and \nAddress\n types do not implement Node. It is unlikely that \nGrades\n\nor \nAddresses\n are shared by more than one restaurant so there is no need to create full connections\nand thus we don't need to implement \nNode\n.\n\n\n\n\nDeploy the schema on Scaphold.io\n\n\nTo get up and running quickly, we'll deploy an API defined by our new schema on Scaphold.io! It takes\nabout 3 minutes.\n\n\n\n\n\n\nGo to \nScaphold.io\n and create an app.\n\n\n\n\n\n\nYou will be taken to the schema designer where you can create the 3 types listed above. Make sure that your\n\nAddress\n and \nGrade\n types do not implement the \nNode\n interface.\n\n\n\n\n\n\nYou're done! Don't worry if you made a mistake, the GraphQL type system will let you know\nexactly where you went wrong when you start pushing data.\n\n\n\n\n\n\n\n\nTip! Watch this \nvideo to learn more about the Scaphold Schema Designer\n\n\n\n\nThe migration script\n\n\nIn the industry, a migration task like this is referred to as ETL (Extract, Transform, Load) and\nis extremely common. We're going to write a simple node.js script that streams data from our\nrestaurants.json MongoDB dump into our GraphQL API. Our restaurant data might be too large for the\nmemory on our machine so we are going to read it in line by line and then queue our API calls so\nthat we do not run out of network bandwidth on our machine.\n\n\nHere is our script! We are using two packages that are not available to a basic node.js installation.\nBefore running this script make sure you install \nasync\n and \nrequest-promise\n via \nnpm install async request-promise\n from your project\ndirectory.\n\n\nTake a look at our script.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n// migrator.js\n\n\nimport\n \nfs\n \nfrom\n \nfs\n;\n\n\nimport\n \nreadline\n \nfrom\n \nreadline\n;\n\n\nimport\n \npath\n \nfrom\n \npath\n;\n\n\nimport\n \nrequest\n \nfrom\n \nrequest-promise\n;\n\n\nimport\n \nasync\n \nfrom\n \nasync\n;\n\n\n\nconst\n \nMONGO_COLLECTION_FILE\n \n=\n \npath\n.\njoin\n(\n__dirname\n,\n \nrestaurants.json\n);\n\n\n\n/*\n\n\n * Sets our max concurrency to 250 so we don\nt exhaust\n\n\n * local network resources\n\n\n */\n\n\nconst\n \nasyncQueue\n \n=\n \nasync\n.\nqueue\n((\nrestaurant\n,\n \ncallback\n)\n \n=\n \n{\n\n  \ncreateRestaurant\n(\nrestaurant\n).\nthen\n(()\n \n=\n \ncallback\n());\n\n\n},\n \n250\n);\n\n\n\n/**\n\n\n * Create a read stream. The mongoexport tool outputs a\n\n\n * single JSON object per line.\n\n\n * https://docs.mongodb.com/manual/reference/program/mongoexport/\n\n\n */\n\n\nconst\n \nreadStream\n \n=\n \nfs\n.\ncreateReadStream\n(\nMONGO_COLLECTION_FILE\n);\n\n\nconst\n \nlineReader\n \n=\n \nreadline\n.\ncreateInterface\n({\n\n  \ninput\n:\n \nreadStream\n\n\n});\n\n\nlineReader\n.\non\n(\nline\n,\n \nline\n \n=\n \n{\n\n  \nconst\n \nrestaurant\n \n=\n \nJSON\n.\nparse\n(\nline\n);\n\n  \n/**\n\n\n   * Apply a simple transformation to the restaurant item to adhere\n\n\n   * to our graphql schema.\n\n\n   *\n\n\n   * This takes two steps.\n\n\n   *\n\n\n   * 1) rename restaurant_id to mongoId\n\n\n   * 2) Pull the date out of the nested { $date: ... } structure lying\n\n\n   *    under grades.date\n\n\n   *\n\n\n   * Note: The ... below is the JS rest operator which enumerates\n\n\n   * an objects keys and values into another object. You can think\n\n\n   * of it as cloning an object. If you don\nt use babel then you can\n\n\n   * replace the ... (rest operator) with Object.assign()\n\n\n   *\n\n\n   * It works like this:\n\n\n   * var copy = Object.assign({}, { a: 1 }, { b: 2 });\n\n\n   * console.log(copy); // { a: 1, b: 2 }\n\n\n   */\n\n  \nconst\n \nmodified\n \n=\n \n{\n\n    \n...\nrestaurant\n,\n\n    \nmongoId\n:\n \nrestaurant\n.\nrestaurant_id\n,\n\n    \ngrades\n:\n \nrestaurant\n.\ngrades\n.\nmap\n(\ngrade\n \n=\n \n{\n\n      \n// grade.date currently looks like { $date: \ntimevalue\n }.\n\n      \n// We only want the \ntimevalue\n\n      \nreturn\n \n{\n\n        \n...\ngrade\n,\n\n        \ndate\n:\n \ngrade\n.\ndate\n[\n$date\n]\n\n      \n};\n\n    \n})\n\n  \n};\n\n  \n// Remove the restaurant id so we don\nt upset the GraphQL type system.\n\n  \ndelete\n \nmodified\n.\nrestaurant_id\n;\n\n  \nasyncQueue\n.\npush\n(\nmodified\n);\n\n\n});\n\n\nlineReader\n.\non\n(\nerror\n,\n \nerr\n \n=\n \n{\n\n  \nconsole\n.\nerror\n(\nerr\n);\n\n\n});\n\n\n\n// Make sure you replace the uri with your Scaphold app\ns url.\n\n\nconst\n \ncreateRestaurant\n \n=\n \nrestaurant\n \n=\n \n{\n\n  \nconst\n \nreqOpts\n \n=\n \n{\n\n    \nmethod\n:\n \nPOST\n,\n\n    \nuri\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/\nmy-alias\n,\n\n    \nbody\n:\n \n{\n\n      \nquery\n:\n \n`\n\n\n      mutation CreateRestaurant($restaurant: CreateRestaurantInput!) {\n\n\n        createRestaurant(input: $restaurant) {\n\n\n          changedRestaurant {\n\n\n            id\n\n\n            name\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n      `\n,\n\n      \nvariables\n:\n \n{\n\n        \nrestaurant\n\n      \n}\n\n    \n},\n\n    \njson\n:\n \ntrue\n,\n\n  \n};\n\n  \nreturn\n \nrequest\n(\nreqOpts\n).\nthen\n(\nres\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\n`\n\n\n      Successfully created restaurant: \n${\nres\n.\ndata\n.\ncreateRestaurant\n.\nchangedRestaurant\n.\nid\n}\n\n\n    `\n);\n\n  \n}).\ncatch\n(\nerr\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\n`Error creating restaurant: \n${\nerr\n.\nmessage\n}\n`\n);\n\n  \n});\n\n\n};\n\n\n\n\n\n\n\n\n\nThe $date syntax from the mongodump exists because mongodb stores its documents using BSON not JSON.\nBSON is a binary superset of JSON that adds some additional functionality and thus needs the extra\nannotations in order serialize itself to JSON.\n\n\n\n\nIf you're following along all you should have to do now is run your migration script via\n\nnode ./migrator.js\n. If everything is setup correctly, your terminal will start printing out\nsuccess messages for each item it uploads!\n\n\nTest the migration\n\n\nAs soon as it is done, you can immediately start querying your deployed GraphQL API.\nTry this one in the GraphiQL tab in the Scaphold portal and/or from your application:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nquery AllRestaurants {\n  viewer {\n    allRestaurants(first: 50) {\n      edges {\n        node {\n          id\n          borough\n          name\n          mongoId\n          cuisine\n          address {\n            zipcode\n            building\n            street\n            coord\n          }\n          grades {\n            score\n            grade\n            date\n          }\n          createdAt\n        }\n        cursor\n      }\n    }\n  }\n}\n\n\n\n\n\n\nMigrating more complicated data\n\n\nYou can use this same process to easily migrate any data to GraphQL. Scaphold offers a couple\nfeatures that can make it a lot easier to migrate more complicated data as well. If you have\nnative relations in your datasets already, \n take a look at the nested create operators in your\nScaphold API\n. They allow you create and associate Node implementing types in a single API call.\n\n\nFor example, assume we had the following types.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ntype Post implements Node {\n  id: ID!\n  title: String!\n  category: Category\n}\n\ntype Category implements Node {\n  id: ID!\n  name: String!\n}\n\n\n\n\n\n\nIf we had a dataset with a lot of post nodes that were already associated with a category then we\ncould create our posts as well as associate them with the category with a query like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nmutation CreatePostAndAssociateCategory($post:CreatePostInput!) {\n  createPost(input: $post) {\n    changedPost {\n      id\n      title\n      category {\n        id\n        name\n      }\n    }\n  }\n}\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// Variables\n\n\n{\n\n  \npost\n:\n \n{\n\n    \ntitle\n:\n \nGraphQL Rocks!\n,\n\n    \ncategory\n:\n \n{\n\n      \nname\n:\n \nNext Generation Tech\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThese are just a few techniques we have used to migrate our mongodb data to GraphQL. I hope it helps\nand please let me know what you think and if you have any other techniques.\n\n\nThanks for reading!\n\n\nIf you have any questions please let me know below or \nJoin us on Slack\n!\n\n\nWe'd love to hear what you think and are even more excited to see what you build!", 
            "title": "Migrating MongoDB"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#migrating-from-mongodb-to-graphql", 
            "text": "Hey!  Today I'm going to demonstrate how I migrated a MongoDB collection to GraphQL. With Parse shutting\ndown at the end of the month, there are a lot of applications are looking for a new home for their data\nand since GraphQL is the future, it's a great time to migrate! I was genuinely surprised by how easy\nthe process was so here is a little guide so you can migrate your data yourself.", 
            "title": "Migrating from MongoDB to GraphQL"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#step-1-define-the-schema", 
            "text": "The first step in migrating your data is to prepare your GraphQL schema. I'll be using MongoDB's sample\nrestaurants collection found here .\nThe restaurants collection is defined by a pretty simple Schema. We're going to change a few field names for consistency\nand our migration script will handle transforming each data item. Here is our final schema:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 type Restaurant implements Node {\n  id: ID!\n  name: String!\n  mongoId: String!\n  cuisine: String!\n  borough: String!\n  address: Address!\n  grades: [Grade]\n  createdAt: DateTime\n  modifiedAt: DateTime\n}\n\ntype Address {\n  zipcode: String!\n  street: String!\n  coord: [Float]\n  building: String\n}\n\ntype Grade {\n  score: String!\n  grade: String\n  date: DateTime!\n}   That's it!   Notice that our  Grade  and  Address  types do not implement Node. It is unlikely that  Grades \nor  Addresses  are shared by more than one restaurant so there is no need to create full connections\nand thus we don't need to implement  Node .", 
            "title": "Step 1: Define the schema"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#deploy-the-schema-on-scapholdio", 
            "text": "To get up and running quickly, we'll deploy an API defined by our new schema on Scaphold.io! It takes\nabout 3 minutes.    Go to  Scaphold.io  and create an app.    You will be taken to the schema designer where you can create the 3 types listed above. Make sure that your Address  and  Grade  types do not implement the  Node  interface.    You're done! Don't worry if you made a mistake, the GraphQL type system will let you know\nexactly where you went wrong when you start pushing data.     Tip! Watch this  video to learn more about the Scaphold Schema Designer", 
            "title": "Deploy the schema on Scaphold.io"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#the-migration-script", 
            "text": "In the industry, a migration task like this is referred to as ETL (Extract, Transform, Load) and\nis extremely common. We're going to write a simple node.js script that streams data from our\nrestaurants.json MongoDB dump into our GraphQL API. Our restaurant data might be too large for the\nmemory on our machine so we are going to read it in line by line and then queue our API calls so\nthat we do not run out of network bandwidth on our machine.  Here is our script! We are using two packages that are not available to a basic node.js installation.\nBefore running this script make sure you install  async  and  request-promise  via  npm install async request-promise  from your project\ndirectory.  Take a look at our script.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97 // migrator.js  import   fs   from   fs ;  import   readline   from   readline ;  import   path   from   path ;  import   request   from   request-promise ;  import   async   from   async ;  const   MONGO_COLLECTION_FILE   =   path . join ( __dirname ,   restaurants.json );  /*   * Sets our max concurrency to 250 so we don t exhaust   * local network resources   */  const   asyncQueue   =   async . queue (( restaurant ,   callback )   =   { \n   createRestaurant ( restaurant ). then (()   =   callback ());  },   250 );  /**   * Create a read stream. The mongoexport tool outputs a   * single JSON object per line.   * https://docs.mongodb.com/manual/reference/program/mongoexport/   */  const   readStream   =   fs . createReadStream ( MONGO_COLLECTION_FILE );  const   lineReader   =   readline . createInterface ({ \n   input :   readStream  });  lineReader . on ( line ,   line   =   { \n   const   restaurant   =   JSON . parse ( line ); \n   /**     * Apply a simple transformation to the restaurant item to adhere     * to our graphql schema.     *     * This takes two steps.     *     * 1) rename restaurant_id to mongoId     * 2) Pull the date out of the nested { $date: ... } structure lying     *    under grades.date     *     * Note: The ... below is the JS rest operator which enumerates     * an objects keys and values into another object. You can think     * of it as cloning an object. If you don t use babel then you can     * replace the ... (rest operator) with Object.assign()     *     * It works like this:     * var copy = Object.assign({}, { a: 1 }, { b: 2 });     * console.log(copy); // { a: 1, b: 2 }     */ \n   const   modified   =   { \n     ... restaurant , \n     mongoId :   restaurant . restaurant_id , \n     grades :   restaurant . grades . map ( grade   =   { \n       // grade.date currently looks like { $date:  timevalue  }. \n       // We only want the  timevalue \n       return   { \n         ... grade , \n         date :   grade . date [ $date ] \n       }; \n     }) \n   }; \n   // Remove the restaurant id so we don t upset the GraphQL type system. \n   delete   modified . restaurant_id ; \n   asyncQueue . push ( modified );  });  lineReader . on ( error ,   err   =   { \n   console . error ( err );  });  // Make sure you replace the uri with your Scaphold app s url.  const   createRestaurant   =   restaurant   =   { \n   const   reqOpts   =   { \n     method :   POST , \n     uri :   https://us-west-2.api.scaphold.io/graphql/ my-alias , \n     body :   { \n       query :   `        mutation CreateRestaurant($restaurant: CreateRestaurantInput!) {          createRestaurant(input: $restaurant) {            changedRestaurant {              id              name            }          }        }        ` , \n       variables :   { \n         restaurant \n       } \n     }, \n     json :   true , \n   }; \n   return   request ( reqOpts ). then ( res   =   { \n     console . log ( `        Successfully created restaurant:  ${ res . data . createRestaurant . changedRestaurant . id }      ` ); \n   }). catch ( err   =   { \n     console . log ( `Error creating restaurant:  ${ err . message } ` ); \n   });  };     The $date syntax from the mongodump exists because mongodb stores its documents using BSON not JSON.\nBSON is a binary superset of JSON that adds some additional functionality and thus needs the extra\nannotations in order serialize itself to JSON.   If you're following along all you should have to do now is run your migration script via node ./migrator.js . If everything is setup correctly, your terminal will start printing out\nsuccess messages for each item it uploads!", 
            "title": "The migration script"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#test-the-migration", 
            "text": "As soon as it is done, you can immediately start querying your deployed GraphQL API.\nTry this one in the GraphiQL tab in the Scaphold portal and/or from your application:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 query AllRestaurants {\n  viewer {\n    allRestaurants(first: 50) {\n      edges {\n        node {\n          id\n          borough\n          name\n          mongoId\n          cuisine\n          address {\n            zipcode\n            building\n            street\n            coord\n          }\n          grades {\n            score\n            grade\n            date\n          }\n          createdAt\n        }\n        cursor\n      }\n    }\n  }\n}", 
            "title": "Test the migration"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#migrating-more-complicated-data", 
            "text": "You can use this same process to easily migrate any data to GraphQL. Scaphold offers a couple\nfeatures that can make it a lot easier to migrate more complicated data as well. If you have\nnative relations in your datasets already,   take a look at the nested create operators in your\nScaphold API . They allow you create and associate Node implementing types in a single API call.  For example, assume we had the following types.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 type Post implements Node {\n  id: ID!\n  title: String!\n  category: Category\n}\n\ntype Category implements Node {\n  id: ID!\n  name: String!\n}   If we had a dataset with a lot of post nodes that were already associated with a category then we\ncould create our posts as well as associate them with the category with a query like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 mutation CreatePostAndAssociateCategory($post:CreatePostInput!) {\n  createPost(input: $post) {\n    changedPost {\n      id\n      title\n      category {\n        id\n        name\n      }\n    }\n  }\n}   1\n2\n3\n4\n5\n6\n7\n8\n9 // Variables  { \n   post :   { \n     title :   GraphQL Rocks! , \n     category :   { \n       name :   Next Generation Tech \n     } \n   }  }    These are just a few techniques we have used to migrate our mongodb data to GraphQL. I hope it helps\nand please let me know what you think and if you have any other techniques.", 
            "title": "Migrating more complicated data"
        }, 
        {
            "location": "/tutorials/migrate-mongodb-graphql/#thanks-for-reading", 
            "text": "If you have any questions please let me know below or  Join us on Slack !  We'd love to hear what you think and are even more excited to see what you build!", 
            "title": "Thanks for reading!"
        }, 
        {
            "location": "/tutorials/persisted-queries/", 
            "text": "Improve performance with persisted queries\n\n\nToday we are happy to announce support for persisted queries on Scaphold.\nPersisted queries allow you store the text of your queries on our servers. This allow you to\noptimize your app so it doesn't have to send the same query in each request which\ncan significantly decrease your application's bandwidth usage. Mobile devices with limited connectivity\nbenefit even more from persisted queries. It's quick and easy to start using persisted queries.\nLet's check them out.\n\n\nHow Persisted Queries Work\n\n\nA traditional GraphQL request includes a request body that looks like this.\n\n\n1\n2\n3\n4\n{\n\n  \nquery\n:\n \nquery GetUser($id: ID!) { getUser(id: $id) { id username } }\n,\n\n  \nvariables\n:\n \n{\n \nid\n:\n \n7\n \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nThis query is relatively small, but queries can get much larger. In a large application,\nthe bandwidth required to send these queries over and over again can have very real impacts on your\napplication's performance. Persisted queries fix this by transforming the above request into this.\n\n\n1\n2\n3\n4\n{\n\n  \nid\n:\n \n1\n,\n\n  \nvariables\n:\n \n{\n \nid\n:\n \n7\n \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nPersisted queries require a mapping from query text to an ID. In our example, we would have a\nmapping from the \nquery\n:\n\n\n1\nquery GetUser($id: ID!) { getUser(id: $id) { id username } }\n\n\n\n\n\n\n\n\nto the \nid\n \n1\n.\n\n\nThese mappings are stored as json documents that have the form\n\n\n1\n{\n \n[\ngraphql_query\n]\n:\n \n \nID\n \n \n}\n\n\n\n\n\n\n\nFor example, the mapping for our query to the right would look like this:\n\n\n1\n{\n \nquery getUser($id: ID!) { getUser(id: $id) { id username } }\n:\n \n1\n \n}\n\n\n\n\n\n\n\nAdding persisted queries to your API is easy! First create the mapping file, then upload it\nto Scaphold via the \nGraphiQL\n tab in the portal. Once you have uploaded the file, you\ncan begin passing query ids instead of query text to our APIs.\n\n\nGetting Started with Persisted Queries\n\n\nThe first step is to create the mapping from our GraphQL queries to their IDs. To do this we\nwill use the \npersistgraphql\n npm package. \npersistgraphql\n expects that you store your\nqueries as \n.graphql\n files in your source. If you aren't already doing this, the first step\nis to move your queries out to their own \n.graphql\n files and then \nimport\n those queries from your\ncomponents.\n\n\nOnce you have your queries separated out into their own files then run these commands:\n\n\n1) \nnpm install -g persistgraphql\n\n\n2) \npersistgraphql \n projectdir \n\n\n3) This will generate an \nextracted_queries.json\n file that you will upload to Scaphold.\n\n\n\n\nYou can also point \npersistgraphql\n to a single \n.graphql\n file. Pointing it to a directory will\nrecursively pull queries out of every \n.graphql\n file.\n\n\n\n\nUploading Your Queries to Scaphold\n\n\nUploading your \nextracted_queries.json\n file to Scaphold is easy. Go to the GraphiQL tab in your\n\nScaphold\n portal and click \nPersisted Queries\n in the page header.\n\n\n\n\nThis will open a side panel where you can drop your \nextracted_queries.json\n file.\n\n\n\n\nWe will automatically store this mapping so our servers know what query to call for a\nparticular query ID.\n\n\n\n\nWe will store your queries in a database and cache them with Redis so you see the full speed benefits.\n\n\n\n\nAdd Persisted Queries To Apollo Client\n\n\nApollo Client comes with built-in support for persisted queries. To enable it, replace your\nnetwork interface with one that looks like this. This will automatically replace your query text\nwith the associated query ID without any changes to your code. Scaphold will handle replacing\nthe ID with the query text on the server.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nimport\n \nqueryMap\n \nfrom\n \n\u2018\n.\n/\nextracted_queries\n.\njson\n\u2019\n;\n\n\nimport\n \n{\n \nPersistedQueryNetworkInterface\n \n}\n \nfrom\n \n\u2018\npersistgraphql\n\u2019\n;\n\n\nconst\n \nnetworkInterface\n \n=\n \nnew\n \nPersistedQueryNetworkInterface\n({\n\n  \nqueryMap\n,\n\n  \nuri\n:\n \napiUrl\n,\n\n  \nopts\n:\n \n{\n\n    \nheaders\n:\n \n{\n\n      \nAuthorization\n:\n \n \nscaphold\n \nauth\n \ntoken\n \n\n    \n},\n\n  \n},\n\n\n});\n\n\nconst\n \nclient\n \n=\n \nnew\n \nApolloClient\n({\n\n  \nnetworkInterface\n,\n\n\n});\n\n\n\n\n\n\n\nUsing Persisted Queries Without Apollo Client\n\n\nApollo Client makes it easy to use persisted queries but you're welcome to manage the queries\nyourself. All you need to do is replace the \n\"query\"\n property in each of your requests with\nthe associated \n\"id\"\n. Keep in mind though, that it's up to you to make sure that you have updated\nthe most recent version of your queries to our servers.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nvar\n \nrequest\n \n=\n \nrequire\n(\nrequest\n);\n\n\n\nvar\n \ndata\n \n=\n \n{\n\n  \nid\n:\n \n1\n,\n\n  \nvariables\n:\n \n{\n\n    \nid\n:\n \n7\n\n  \n}\n\n\n}\n\n\n\nrequest\n({\n\n  \nurl\n:\n \nhttps://us-west-2.api.scaphold.io/graphql/my-awesome-app\n,\n\n  \nmethod\n:\n \nPOST\n,\n\n  \njson\n:\n \ntrue\n,\n\n  \nheaders\n:\n \n{\n\n    \ncontent-type\n:\n \napplication/json\n,\n\n  \n},\n\n  \nbody\n:\n \ndata\n\n\n},\n \nfunction\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n  \nif\n \n(\n!\nerror\n \n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nbody\n,\n \nnull\n,\n \n2\n));\n\n  \n}\n \nelse\n \n{\n\n    \nconsole\n.\nlog\n(\nerror\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\nWrapping Up\n\n\nI hope you enjoy these new features! Let me know what you think in the comments or connect\nwith us on slack!\n\n\n\n  \n\n    \nJoin us on Slack", 
            "title": "Using Persisted Queries"
        }, 
        {
            "location": "/tutorials/persisted-queries/#improve-performance-with-persisted-queries", 
            "text": "Today we are happy to announce support for persisted queries on Scaphold.\nPersisted queries allow you store the text of your queries on our servers. This allow you to\noptimize your app so it doesn't have to send the same query in each request which\ncan significantly decrease your application's bandwidth usage. Mobile devices with limited connectivity\nbenefit even more from persisted queries. It's quick and easy to start using persisted queries.\nLet's check them out.", 
            "title": "Improve performance with persisted queries"
        }, 
        {
            "location": "/tutorials/persisted-queries/#how-persisted-queries-work", 
            "text": "A traditional GraphQL request includes a request body that looks like this.  1\n2\n3\n4 { \n   query :   query GetUser($id: ID!) { getUser(id: $id) { id username } } , \n   variables :   {   id :   7   }  }     This query is relatively small, but queries can get much larger. In a large application,\nthe bandwidth required to send these queries over and over again can have very real impacts on your\napplication's performance. Persisted queries fix this by transforming the above request into this.  1\n2\n3\n4 { \n   id :   1 , \n   variables :   {   id :   7   }  }     Persisted queries require a mapping from query text to an ID. In our example, we would have a\nmapping from the  query :  1 query GetUser($id: ID!) { getUser(id: $id) { id username } }    to the  id   1 .  These mappings are stored as json documents that have the form  1 {   [ graphql_query ] :     ID     }    For example, the mapping for our query to the right would look like this:  1 {   query getUser($id: ID!) { getUser(id: $id) { id username } } :   1   }    Adding persisted queries to your API is easy! First create the mapping file, then upload it\nto Scaphold via the  GraphiQL  tab in the portal. Once you have uploaded the file, you\ncan begin passing query ids instead of query text to our APIs.", 
            "title": "How Persisted Queries Work"
        }, 
        {
            "location": "/tutorials/persisted-queries/#getting-started-with-persisted-queries", 
            "text": "The first step is to create the mapping from our GraphQL queries to their IDs. To do this we\nwill use the  persistgraphql  npm package.  persistgraphql  expects that you store your\nqueries as  .graphql  files in your source. If you aren't already doing this, the first step\nis to move your queries out to their own  .graphql  files and then  import  those queries from your\ncomponents.  Once you have your queries separated out into their own files then run these commands:  1)  npm install -g persistgraphql  2)  persistgraphql   projectdir   3) This will generate an  extracted_queries.json  file that you will upload to Scaphold.   You can also point  persistgraphql  to a single  .graphql  file. Pointing it to a directory will\nrecursively pull queries out of every  .graphql  file.", 
            "title": "Getting Started with Persisted Queries"
        }, 
        {
            "location": "/tutorials/persisted-queries/#uploading-your-queries-to-scaphold", 
            "text": "Uploading your  extracted_queries.json  file to Scaphold is easy. Go to the GraphiQL tab in your Scaphold  portal and click  Persisted Queries  in the page header.   This will open a side panel where you can drop your  extracted_queries.json  file.   We will automatically store this mapping so our servers know what query to call for a\nparticular query ID.   We will store your queries in a database and cache them with Redis so you see the full speed benefits.", 
            "title": "Uploading Your Queries to Scaphold"
        }, 
        {
            "location": "/tutorials/persisted-queries/#add-persisted-queries-to-apollo-client", 
            "text": "Apollo Client comes with built-in support for persisted queries. To enable it, replace your\nnetwork interface with one that looks like this. This will automatically replace your query text\nwith the associated query ID without any changes to your code. Scaphold will handle replacing\nthe ID with the query text on the server.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 import   queryMap   from   \u2018 . / extracted_queries . json \u2019 ;  import   {   PersistedQueryNetworkInterface   }   from   \u2018 persistgraphql \u2019 ;  const   networkInterface   =   new   PersistedQueryNetworkInterface ({ \n   queryMap , \n   uri :   apiUrl , \n   opts :   { \n     headers :   { \n       Authorization :     scaphold   auth   token   \n     }, \n   },  });  const   client   =   new   ApolloClient ({ \n   networkInterface ,  });", 
            "title": "Add Persisted Queries To Apollo Client"
        }, 
        {
            "location": "/tutorials/persisted-queries/#using-persisted-queries-without-apollo-client", 
            "text": "Apollo Client makes it easy to use persisted queries but you're welcome to manage the queries\nyourself. All you need to do is replace the  \"query\"  property in each of your requests with\nthe associated  \"id\" . Keep in mind though, that it's up to you to make sure that you have updated\nthe most recent version of your queries to our servers.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 var   request   =   require ( request );  var   data   =   { \n   id :   1 , \n   variables :   { \n     id :   7 \n   }  }  request ({ \n   url :   https://us-west-2.api.scaphold.io/graphql/my-awesome-app , \n   method :   POST , \n   json :   true , \n   headers :   { \n     content-type :   application/json , \n   }, \n   body :   data  },   function ( error ,   response ,   body )   { \n   if   ( ! error     response . statusCode   ==   200 )   { \n     console . log ( JSON . stringify ( body ,   null ,   2 )); \n   }   else   { \n     console . log ( error ); \n   }  });", 
            "title": "Using Persisted Queries Without Apollo Client"
        }, 
        {
            "location": "/tutorials/persisted-queries/#wrapping-up", 
            "text": "I hope you enjoy these new features! Let me know what you think in the comments or connect\nwith us on slack!  \n   \n     Join us on Slack", 
            "title": "Wrapping Up"
        }, 
        {
            "location": "/tutorials/advanced-queries/", 
            "text": "Simplify relational logic with GraphQL\n\n\nOne of the biggest benefits of GraphQL is how it allows you traverse hierarhical data in a single query.\nGone are the days of REST when you would query for a user, get back a list of post ids, and then\nask the API for all those posts. This same query which might take 11 requests in REST would take\nthis simple GraphQL query.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nquery GetUserAndPosts {\n  getUser(id: 1) {\n    id\n    name\n    posts(first: 10) {\n      id\n      title\n      content\n    }\n  }\n}\n\n\n\n\n\n\nIn one round trip, you now have all the data you need to populate your front-end! This is great,\nbut only scratches the surface of what GraphQL can do. Let's dig a little deeper.\n\n\nBasic relational queries\n\n\nThe GraphQL language offers an expressive syntax that we can use to query data on our servers. It\nmakes no assumptions as to how we store our data which is also what makes it so powerful. A\nquery might pull from any number of datasources whether they be SQL, Neo4j, REST, or something else.\nThe GraphQL schema and language provide a powerful set of tools that we as developers can use to\nbuild safer, more efficient systems.\n\n\nLet's start with a simple example. Assume we're building an application that tracks and displays\nsporting events happening in different cities around the world. To build this app, we would have a\nschema like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ntype Event implements Node {\n  id: ID!\n  name: String!\n  date: DateTime!\n  city: City\n  sport: Sport\n}\n\ntype City implements Node {\n  id: ID!\n  name: String!\n  events: [Event]\n}\n\ntype Sport implements Node {\n  id: ID!\n  name: String!\n  events: [Event]\n}\n\n\n\n\n\n\nOur app would be perfect for a relational database like MySQL or Postgres. All three of our \nNode\n\nimplementing types could be conceptually mapped to tables in SQL so that we can create relations\nbetween them. SQL itself is a powerful language that we can use\nto query our data, but it would be a very bold move to expose your SQL database directly your client\napplications. Enter GraphQL!\n\n\nOkay, so now let's build a \nCityView\n that shows all the events\nfor a particular city. Whether we are building on react, react-native, ios, etc the GraphQL\nquery will be exactly the same.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nquery GetCityEvents {\n  getCity(id: \nid-for-san-francisco\n) {\n    id\n    name\n    events {\n      edges {\n        node {\n          id\n          name\n          date\n          sport {\n            id\n            name\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThe resolver for the \ngetCity\n query is responsible for returning all the data that this query\nis asking for. There are a number of different ways we could implement this. Let's take a look\nat two.\n\n\nUse GraphQL to optimize your queries\n\n\nThe GraphQL type system has implications that extend far beyond a better developer experience\non the client. For the first time, our APIs have a structure that we can introspect and use\nto build better tools. For example, the above query could operate in two different ways.\n\n\nWe could think of the \ngetCity\n, \nevents\n, and \nsport\n resolvers as three separate SQL queries.\n\n\nI.E. first we get the city, then we get the events given the cityId, then we get the sport connected to each event.\nThere are ways to optimize this query using projects like \ndataloader\n,\nbut I would argue there is a more interesting alternative.\n\n\nUse the GraphQL type system to pre-compute joins\n\n\nWhen our GraphQL server receives a request, it knows exactly what data the query is asking for.\nIn GraphQL, you call the sections of the query between brackets a \nselection set\n. Using the query\nselection set, we can precompute the necessary join that will fulfill the query.\n\n\nIn our example, we would be able to generate a query like this:\n\n\n1\n2\n3\n4\n5\n6\n7\nSELECT\n \n*\n\n\nFROM\n \n`\nCity\n`\n \nas\n \n`\nC\n`\n\n\nJOIN\n \n`\nEvent\n`\n \nas\n \n`\nE\n`\n\n\nON\n \n`\nC\n`\n.\n`\nid\n`\n \n=\n \n`\nE\n`\n.\n`\ncityId\n`\n\n\nJOIN\n \n`\nSport\n`\n \nas\n \n`\nS\n`\n\n\nON\n \n`\nS\n`\n.\n`\nid\n`\n \n=\n \n`\nE\n`\n.\n`\nsportId\n`\n\n\nWHERE\n \n`\nC\n`\n.\n`\nid\n`\n \n=\n \n1\n;\n\n\n\n\n\n\n\nThese queries can get even further optimized by replacing the \n*\n with the the subset of\nfields necessary to fulfill the request. This gives the client the power to define exactly what\ndata they need while also ensuring the each query will be optimized at runtime.\nI hope this helps demonstrate the types of optimizations you can make given a GraphQL query.\n\n\nIf you want to try this yourself, there is an npm package called \ngraphql-fields\n that\nwill parse the selection set out of a GraphQL resolver's info object.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nimport\n \ngraphqlFields\n \nfrom\n \ngraphql-fields\n;\n\n\n\nfunction\n \ngetCityResolver\n(\nparent\n,\n \nargs\n,\n \ncontext\n,\n \ninfo\n)\n \n{\n\n  \nconst\n \nselectionSet\n \n=\n \ngraphqlFields\n(\ninfo\n);\n\n  \n/**\n\n\n    selectionSet = {\n\n\n      id: {},\n\n\n      name: {},\n\n\n      events: {\n\n\n        edges: {\n\n\n          node: {\n\n\n            id: {},\n\n\n            name: {},\n\n\n            date: {},\n\n\n            sport: {\n\n\n              id: {},\n\n\n              name: {},\n\n\n            }\n\n\n          }\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n  */\n\n  \n// .. generate sql from selection set\n\n  \nreturn\n \ndb\n.\nquery\n(\ngeneratedQuery\n);\n\n\n}\n\n\n\n\n\n\n\n\n\nThere are also higher level tools like \njoin monster\n that\ncan help with this.\n\n\n\n\nAdvanced relational queries with GraphQL\n\n\nAt \nScaphold\n, we have just released a new feature that allows for even more\ncomplex relational queries. We have extended your \nWhereArgs\n types to allow you to traverse connections.\nFor example, let's say we wanted to query for all the Football events in Seattle in 2017.\n\n\nThis query\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nquery FootballEventsInSeattle {\n  viewer {\n    allEvents(where: {\n      date: {\n        gt: \n2017\n\n      },\n      city: {\n        name: {\n          eq: \nSeattle\n\n        }\n      },\n      sport: {\n        name: {\n          eq: \nFootball\n\n        }\n      }\n    }) {\n      edges {\n        node {\n          id\n          name\n          sport {\n            id\n            name\n          }\n        }\n      }\n      aggregations {\n        count\n      }\n    }\n  }\n}\n\n\n\n\n\n\nwould yield these results\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n{\n\n  \ndata\n:\n \n{\n\n    \nviewer\n:\n \n{\n\n      \nallEvents\n:\n \n{\n\n        \nedges\n:\n \n[\n\n          \n{\n\n            \nnode\n:\n \n{\n\n              \nid\n:\n \nRXZlbnQ6OQ==\n,\n\n              \nname\n:\n \n12th man bar night\n,\n\n              \ndate\n:\n \n2017-02-01T08:30:00.000Z\n\n              \nsport\n:\n \n{\n\n                \nid\n:\n \nU3BvcnQ6MQ==\n,\n\n                \nname\n:\n \nFootball\n\n              \n}\n\n            \n}\n\n          \n},\n\n          \n{\n\n            \nnode\n:\n \n{\n\n              \nid\n:\n \nRXZlbnQ6Nw==\n,\n\n              \nname\n:\n \nSeahawks preseason begins\n,\n\n              \ndate\n:\n \n2017-08-01T08:05:12.000Z\n\n              \nsport\n:\n \n{\n\n                \nid\n:\n \nU3BvcnQ6MQ==\n,\n\n                \nname\n:\n \nFootball\n\n              \n}\n\n            \n}\n\n          \n},\n\n          \n{\n\n            \nnode\n:\n \n{\n\n              \nid\n:\n \nRXZlbnQ6OA==\n,\n\n              \nname\n:\n \nRussell Wilson\ns Birthday\n,\n\n              \ndate\n:\n \n2017-11-29T00:01:00.000Z\n\n              \nsport\n:\n \n{\n\n                \nid\n:\n \nU3BvcnQ6MQ==\n,\n\n                \nname\n:\n \nFootball\n\n              \n}\n\n            \n}\n\n          \n}\n\n        \n],\n\n        \naggregations\n:\n \n{\n\n          \ncount\n:\n \n3\n,\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWe use the optimization techniques mentioned above to precompute the simplest join necessary to\nverify the relationships. You can even traverse deep connections to find objects connected\nto types multiple hops away.\n\n\nTraversing deep connections\n\n\nThis query will get all sports that have atleast one event in San Francisco\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nquery SportsWithEventsInSF {\n  viewer {\n    allSports(where: {\n      events: {\n        city: {\n          name: {\n            eq: \nSan Francisco\n\n          }\n        }\n      }\n    }) {\n      edges {\n        node {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nMuch like how you can use the selection set of a query to precompute SQL joins, you can\nalso use input arguments. Our servers will recognize that this query is asking for a connection\ntwo hops away and will compute the necessary join in a single round trip.\n\n\nQuerying by fields on edges of Many-To-Many connections\n\n\nMany to many connection use a join table or \"through\" type to manage the objects in the connection.\nFor example you might have accessLevel on a role membership or an isAccepted flag on a friendship.\nYou can use these fields to query for objects that satisfy certain connection constraints like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nquery AllAdminsInDeveloperRole {\n  viewer {\n    allUsers(where: {\n      roles: {\n        edge: {\n          createdAt: {\n            gt:\n2017\n\n          },\n          accessLevel: {\n            eq: admin\n          }\n        },\n        node: {\n          name: {\n            eq: \nDeveloper\n\n          }\n        }\n      }\n    }) {\n      edges {\n        node {\n          id\n          username\n          roles {\n            edges {\n              createdAt\n              node {\n                id\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nNotice how the WhereArgs for many to many connections work a bit differently. They include the\n\nedge\n and \nnode\n fields allowing you to specify whether you are filtering on the edge itself\nor the target type.\n\n\nQuerying connections by ID\n\n\nWe've added one more style of connection query that you can use. If you already know the id\nof a connected object(s) or you are looking for the absence of a connection you can use this\nstyle of query.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nquery EventsWithCityId {\n  viewer {\n    allEvents(where: {\n      cityId: {\n        eq: \nsome-object-id\n,\n        # ne: \nsome-object-id\n,\n        # in: [\nsome-object-id\n, \nsome-object-id-2\n],\n        # notIn: [\nsome-object-id\n, \nsome-object-id-2\n],\n        # isNull: true\n      }\n    }) {\n      edges {\n        node {\n          id\n          name\n          city {\n            id\n            name\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThe above query could be used to look for all events that don't have a city, are connected\nto one or more of a set of cities, or are not connected to one or more of a set of cities.\n\n\nWrapping Up\n\n\nGraphQL is an awesome tool that can be used to wrap all kinds of datasources. Even though\nit uses a graph based query language, you don't have to use a graph database. Having the\nGraphQL schema at your disposal you can build more powerful services that provide a great\ndeveloper experience as well optimized performance. I'd love to hear what datasources you\nare all using behind your GraphQL apis and would love to have you checkout \nScaphold.io\n\n\nThanks for reading\n\n\nI hope this helps show you the kinds of queries you can run to build powerful, data-driven\napplications with GraphQL! Thanks for reading! Please let me know what you think in the comments!\n\n\nHappy Scapholding!\n\n\nJoin us on slack", 
            "title": "Advanced Relational Queries"
        }, 
        {
            "location": "/tutorials/advanced-queries/#simplify-relational-logic-with-graphql", 
            "text": "One of the biggest benefits of GraphQL is how it allows you traverse hierarhical data in a single query.\nGone are the days of REST when you would query for a user, get back a list of post ids, and then\nask the API for all those posts. This same query which might take 11 requests in REST would take\nthis simple GraphQL query.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 query GetUserAndPosts {\n  getUser(id: 1) {\n    id\n    name\n    posts(first: 10) {\n      id\n      title\n      content\n    }\n  }\n}   In one round trip, you now have all the data you need to populate your front-end! This is great,\nbut only scratches the surface of what GraphQL can do. Let's dig a little deeper.", 
            "title": "Simplify relational logic with GraphQL"
        }, 
        {
            "location": "/tutorials/advanced-queries/#basic-relational-queries", 
            "text": "The GraphQL language offers an expressive syntax that we can use to query data on our servers. It\nmakes no assumptions as to how we store our data which is also what makes it so powerful. A\nquery might pull from any number of datasources whether they be SQL, Neo4j, REST, or something else.\nThe GraphQL schema and language provide a powerful set of tools that we as developers can use to\nbuild safer, more efficient systems.  Let's start with a simple example. Assume we're building an application that tracks and displays\nsporting events happening in different cities around the world. To build this app, we would have a\nschema like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 type Event implements Node {\n  id: ID!\n  name: String!\n  date: DateTime!\n  city: City\n  sport: Sport\n}\n\ntype City implements Node {\n  id: ID!\n  name: String!\n  events: [Event]\n}\n\ntype Sport implements Node {\n  id: ID!\n  name: String!\n  events: [Event]\n}   Our app would be perfect for a relational database like MySQL or Postgres. All three of our  Node \nimplementing types could be conceptually mapped to tables in SQL so that we can create relations\nbetween them. SQL itself is a powerful language that we can use\nto query our data, but it would be a very bold move to expose your SQL database directly your client\napplications. Enter GraphQL!  Okay, so now let's build a  CityView  that shows all the events\nfor a particular city. Whether we are building on react, react-native, ios, etc the GraphQL\nquery will be exactly the same.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 query GetCityEvents {\n  getCity(id:  id-for-san-francisco ) {\n    id\n    name\n    events {\n      edges {\n        node {\n          id\n          name\n          date\n          sport {\n            id\n            name\n          }\n        }\n      }\n    }\n  }\n}   The resolver for the  getCity  query is responsible for returning all the data that this query\nis asking for. There are a number of different ways we could implement this. Let's take a look\nat two.", 
            "title": "Basic relational queries"
        }, 
        {
            "location": "/tutorials/advanced-queries/#use-graphql-to-optimize-your-queries", 
            "text": "The GraphQL type system has implications that extend far beyond a better developer experience\non the client. For the first time, our APIs have a structure that we can introspect and use\nto build better tools. For example, the above query could operate in two different ways.  We could think of the  getCity ,  events , and  sport  resolvers as three separate SQL queries.  I.E. first we get the city, then we get the events given the cityId, then we get the sport connected to each event.\nThere are ways to optimize this query using projects like  dataloader ,\nbut I would argue there is a more interesting alternative.  Use the GraphQL type system to pre-compute joins  When our GraphQL server receives a request, it knows exactly what data the query is asking for.\nIn GraphQL, you call the sections of the query between brackets a  selection set . Using the query\nselection set, we can precompute the necessary join that will fulfill the query.  In our example, we would be able to generate a query like this:  1\n2\n3\n4\n5\n6\n7 SELECT   *  FROM   ` City `   as   ` C `  JOIN   ` Event `   as   ` E `  ON   ` C ` . ` id `   =   ` E ` . ` cityId `  JOIN   ` Sport `   as   ` S `  ON   ` S ` . ` id `   =   ` E ` . ` sportId `  WHERE   ` C ` . ` id `   =   1 ;    These queries can get even further optimized by replacing the  *  with the the subset of\nfields necessary to fulfill the request. This gives the client the power to define exactly what\ndata they need while also ensuring the each query will be optimized at runtime.\nI hope this helps demonstrate the types of optimizations you can make given a GraphQL query.  If you want to try this yourself, there is an npm package called  graphql-fields  that\nwill parse the selection set out of a GraphQL resolver's info object.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 import   graphqlFields   from   graphql-fields ;  function   getCityResolver ( parent ,   args ,   context ,   info )   { \n   const   selectionSet   =   graphqlFields ( info ); \n   /**      selectionSet = {        id: {},        name: {},        events: {          edges: {            node: {              id: {},              name: {},              date: {},              sport: {                id: {},                name: {},              }            }          }        }      }    */ \n   // .. generate sql from selection set \n   return   db . query ( generatedQuery );  }     There are also higher level tools like  join monster  that\ncan help with this.", 
            "title": "Use GraphQL to optimize your queries"
        }, 
        {
            "location": "/tutorials/advanced-queries/#advanced-relational-queries-with-graphql", 
            "text": "At  Scaphold , we have just released a new feature that allows for even more\ncomplex relational queries. We have extended your  WhereArgs  types to allow you to traverse connections.\nFor example, let's say we wanted to query for all the Football events in Seattle in 2017.  This query   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 query FootballEventsInSeattle {\n  viewer {\n    allEvents(where: {\n      date: {\n        gt:  2017 \n      },\n      city: {\n        name: {\n          eq:  Seattle \n        }\n      },\n      sport: {\n        name: {\n          eq:  Football \n        }\n      }\n    }) {\n      edges {\n        node {\n          id\n          name\n          sport {\n            id\n            name\n          }\n        }\n      }\n      aggregations {\n        count\n      }\n    }\n  }\n}   would yield these results   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46 { \n   data :   { \n     viewer :   { \n       allEvents :   { \n         edges :   [ \n           { \n             node :   { \n               id :   RXZlbnQ6OQ== , \n               name :   12th man bar night , \n               date :   2017-02-01T08:30:00.000Z \n               sport :   { \n                 id :   U3BvcnQ6MQ== , \n                 name :   Football \n               } \n             } \n           }, \n           { \n             node :   { \n               id :   RXZlbnQ6Nw== , \n               name :   Seahawks preseason begins , \n               date :   2017-08-01T08:05:12.000Z \n               sport :   { \n                 id :   U3BvcnQ6MQ== , \n                 name :   Football \n               } \n             } \n           }, \n           { \n             node :   { \n               id :   RXZlbnQ6OA== , \n               name :   Russell Wilson s Birthday , \n               date :   2017-11-29T00:01:00.000Z \n               sport :   { \n                 id :   U3BvcnQ6MQ== , \n                 name :   Football \n               } \n             } \n           } \n         ], \n         aggregations :   { \n           count :   3 , \n         } \n       } \n     } \n   }  }    We use the optimization techniques mentioned above to precompute the simplest join necessary to\nverify the relationships. You can even traverse deep connections to find objects connected\nto types multiple hops away.", 
            "title": "Advanced relational queries with GraphQL"
        }, 
        {
            "location": "/tutorials/advanced-queries/#traversing-deep-connections", 
            "text": "This query will get all sports that have atleast one event in San Francisco   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 query SportsWithEventsInSF {\n  viewer {\n    allSports(where: {\n      events: {\n        city: {\n          name: {\n            eq:  San Francisco \n          }\n        }\n      }\n    }) {\n      edges {\n        node {\n          id\n          name\n        }\n      }\n    }\n  }\n}   Much like how you can use the selection set of a query to precompute SQL joins, you can\nalso use input arguments. Our servers will recognize that this query is asking for a connection\ntwo hops away and will compute the necessary join in a single round trip.", 
            "title": "Traversing deep connections"
        }, 
        {
            "location": "/tutorials/advanced-queries/#querying-by-fields-on-edges-of-many-to-many-connections", 
            "text": "Many to many connection use a join table or \"through\" type to manage the objects in the connection.\nFor example you might have accessLevel on a role membership or an isAccepted flag on a friendship.\nYou can use these fields to query for objects that satisfy certain connection constraints like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37 query AllAdminsInDeveloperRole {\n  viewer {\n    allUsers(where: {\n      roles: {\n        edge: {\n          createdAt: {\n            gt: 2017 \n          },\n          accessLevel: {\n            eq: admin\n          }\n        },\n        node: {\n          name: {\n            eq:  Developer \n          }\n        }\n      }\n    }) {\n      edges {\n        node {\n          id\n          username\n          roles {\n            edges {\n              createdAt\n              node {\n                id\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}   Notice how the WhereArgs for many to many connections work a bit differently. They include the edge  and  node  fields allowing you to specify whether you are filtering on the edge itself\nor the target type.", 
            "title": "Querying by fields on edges of Many-To-Many connections"
        }, 
        {
            "location": "/tutorials/advanced-queries/#querying-connections-by-id", 
            "text": "We've added one more style of connection query that you can use. If you already know the id\nof a connected object(s) or you are looking for the absence of a connection you can use this\nstyle of query.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 query EventsWithCityId {\n  viewer {\n    allEvents(where: {\n      cityId: {\n        eq:  some-object-id ,\n        # ne:  some-object-id ,\n        # in: [ some-object-id ,  some-object-id-2 ],\n        # notIn: [ some-object-id ,  some-object-id-2 ],\n        # isNull: true\n      }\n    }) {\n      edges {\n        node {\n          id\n          name\n          city {\n            id\n            name\n          }\n        }\n      }\n    }\n  }\n}   The above query could be used to look for all events that don't have a city, are connected\nto one or more of a set of cities, or are not connected to one or more of a set of cities.", 
            "title": "Querying connections by ID"
        }, 
        {
            "location": "/tutorials/advanced-queries/#wrapping-up", 
            "text": "GraphQL is an awesome tool that can be used to wrap all kinds of datasources. Even though\nit uses a graph based query language, you don't have to use a graph database. Having the\nGraphQL schema at your disposal you can build more powerful services that provide a great\ndeveloper experience as well optimized performance. I'd love to hear what datasources you\nare all using behind your GraphQL apis and would love to have you checkout  Scaphold.io", 
            "title": "Wrapping Up"
        }, 
        {
            "location": "/tutorials/advanced-queries/#thanks-for-reading", 
            "text": "I hope this helps show you the kinds of queries you can run to build powerful, data-driven\napplications with GraphQL! Thanks for reading! Please let me know what you think in the comments!  Happy Scapholding!  Join us on slack", 
            "title": "Thanks for reading"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/", 
            "text": "Authentication with GraphQL\n\n\nProtecting your APIs is as critical a component as anything else in your application. We believe\nthat GraphQL is the future of APIs so let's spend a little bit of time discussing how to go about\nprotecting them. Before we start lets get a few definitions out of the way. This post is about\nauthentication and authorization. The different between the two is only a\nfew letters and the fact that they accomplish two different things.\n\n\nAuthentication\n has to do with logging users in. This generally involves a cookie if you strictly\nbuilding a webpage or a header if you are targetting an API. \nJWT's\n have become\nan increasingly popular way to authenticate users with an API.\n\n\nAuthorization\n although similar to authentication, involves granting users access to specific\nresources in an API. For example, you might be logged in and \nauthenticated\n as John Deer but John Deer\nmight not have access to update the profile of Jane Doe and is thus not \nauthorized\n for that operation.\n\n\nApplication's often have a workflow that looks like this:\n\n\n\n\n\n\nA user logs in by providing a username \n password and in return gets back an auth token.\n\n\n\n\n\n\nThe client application attaches that auth token to every future request (via the Authorization header).\n\n\n\n\n\n\nEach time the server receives a request, the server validates the token and fetches the user from\nthe database.\n\n\n\n\n\n\nThe fetched user object is attached to some context that flows throughout the application.\n\n\n\n\n\n\nDifferent parts of your application use the context's user to determine if the user is authorized\nfor a particular operation.\n\n\n\n\n\n\nRepeat.\n\n\n\n\n\n\nScaphold\n provides a number of \nauthentication\n providers such as \nAuth0\n\nfor social auth, \nDigits\n for passwordless auth, and traditional username \n password\nauth.\n\n\nWe also provide powerful \nauthorization\n mechanisms via permissions. Scaphold supports\nboth role-based and relational access control that can be layered to create powerful authorization\nsystems.\n\n\nLet's take a look at each of these concepts in turn to learn how they help us build more robust APIs.\n\n\nAuthentication\n\n\nWe just learned that authentication is all about attaching a request or session to a user in the database.\nIf you are building against a GraphQL API, chances are that you will be using auth tokens. We prefer JWTs\nso let's take a look at one.\n\n\nThe Anatomy of a JWT (JSON Web Token)\n\n\nThis is an example JWT:\n\n\n\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n\n\n\nThis might look like a random bunch of bits, but there is an order to the chaos. If you head over to \njwt.io\n, you\nwill find a nifty debugger that can help you make sense of this token.\n\n\nA JWT is made up of three parts separated by a period \n.\n\n\n\n\n\n\nThe header contains the algorithm and token type.\n\n\n\n\n\n\nThe payload has an identifier for the user \nsub\n as well as other metadata.\n\n\n\n\n\n\nThe signature is a checksum that is calculated by hashing together the header, payload, and a secret key.\n\n\n\n\n\n\nWhen you decode the above token, you should see these values\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n// header\n\n\n{\n\n  \nalg\n:\n \nHS256\n,\n\n  \ntyp\n:\n \nJWT\n\n\n}\n\n\n\n// payload\n\n\n{\n\n  \nsub\n:\n \n1234567890\n,\n\n  \nname\n:\n \nJohn Doe\n,\n\n  \nadmin\n:\n \ntrue\n\n\n}\n\n\n\n// signature\n\n\nHMACSHA256\n(\n\n  \nbase64UrlEncode\n(\nheader\n)\n \n+\n \n.\n \n+\n\n  \nbase64UrlEncode\n(\npayload\n),\n\n  \nsecret_key\n\n\n)\n\n\n\n\n\n\n\nAuthentication with REST\n\n\nSo how might our application make use of a JWT? If you notice in the payload, there is a\nfield called \nsub\n. The \nsub\n stands for subject and is holds an identifier\nfor the user that the token represents. To authenticate the user, a server will often have a\npiece of code that serves as the gatekeeper and validate these tokens. If you are familiar with\njavascript and express, this might look something like this.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nimport\n \njwt\n \nfrom\n \nexpress-jwt\n;\n\n\nimport\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \napp\n \n=\n \nexpress\n();\n\n\n\napp\n.\nget\n(\n/protected\n,\n\n  \njwt\n({\nsecret\n:\n \nshhhhhhared-secret\n}),\n\n  \nfunction\n(\nreq\n,\n \nres\n)\n \n{\n\n    \nif\n \n(\n!\nreq\n.\nuser\n.\nadmin\n)\n \nreturn\n \nres\n.\nsendStatus\n(\n401\n);\n\n    \nres\n.\nsendStatus\n(\n200\n);\n\n  \n});\n\n\n\n\n\n\n\nThe \nexpress-jwt\n package understands how to decode a JWT and verify its signature. We are adding\na piece of middleware \njwt({secret: 'shhhhhhared-secret'})\n to the \n/protected\n route in our API\nso that you can only hit the \n/protected\n endpoint if you are authenticated.\n\n\nYou can rinse and repeat this technique all day long if you are building a REST API, but since\nwe are savvy developers and building GraphQL APIs this model doesn't work quite the same.\n\n\nAuthentication with GraphQL\n\n\nGraphQL throws away the old idea that resources in an API should be denoted by some path in the\nurl. Instead, we get a rich query language that we can use to access all the data on our servers\nno matter where it lives. Authenticating a GraphQL API, however, can be a little tricky because\nwe have to think about things a little differently. Instead of attaching middleware to our endpoints,\nwe're going to solve this problem by attaching middleware to our GraphQL resolvers. But first, let's\nset the scene.\n\n\nThat same server file from above might look like this in GraphQL.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nimport\n \njwt\n \nfrom\nexpress-jwt\n;\n\n\nimport\n \ngraphqlHTTP\n \nfrom\nexpress-graphql\n;\n\n\nimport\n \nexpress\n \nfrom\nexpress\n;\n\n\nimport\n \nschema\n \nfrom\n./mySchema\n;\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\napp\n.\nuse\n(\n/graphql\n,\n \njwt\n({\n\n  \nsecret\n:\n \nshhhhhhared-secret\n,\n\n  \nrequestProperty\n:\n \nauth\n,\n\n  \ncredentialsRequired\n:\n \nfalse\n,\n\n\n}));\n\n\napp\n.\nuse\n(\n/graphql\n,\n \nfunction\n(\nreq\n,\n \nres\n,\n \ndone\n)\n \n{\n\n  \nconst\n \nuser\n \n=\n \ndb\n.\nUser\n.\nget\n(\nreq\n.\nauth\n.\nsub\n);\n\n  \nreq\n.\ncontext\n \n=\n \n{\n\n    \nuser\n:\n \nuser\n,\n\n  \n}\n\n  \ndone\n();\n\n\n});\n\n\napp\n.\nuse\n(\n/graphql\n,\n \ngraphqlHTTP\n(\nreq\n \n=\n \n({\n\n    \nschema\n:\n \nschema\n,\n\n    \ncontext\n:\n \nreq\n.\ncontext\n,\n\n  \n})\n\n\n));\n\n\n\n\n\n\n\nThis is where things get interesting. This API is not secure at all. It might try to verify the JWT\nbut if the JWT doesn't exist or is invalid, the request will still pass through (see \ncredentialsRequired: false\n).\nWhy? We have to allow the request to pass through because if we blocked it we would block the entire API.\nThat means, our users wouldn't even be able to call a \nloginUser\n mutation to get a token to authenticate themselves.\nThis is no good.\n\n\nThe good news that GraphQL gives us a whole set of tools to build even more robust authentication\nmechanisms than we could with REST. First, we'll cover the basics and then I'll introduce a\ntechnique that will make authentication much more scalable and fun to use.\n\n\nAuthenticate resolvers, not endpoints.\n\n\nWhen you build a GraphQL API, you define a set of types each of which contains a set of fields and an\noptional resolver function that knows how to fetch the data necessary to satisfy that field. Here is a barebones\nexample\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nimport\n \n{\n \nGraphQLSchema\n \n}\n \nfrom\n \ngraphql\n;\n\n\nimport\n \n{\n \nRegistry\n \n}\n \nfrom\n \ngraphql-helpers\n;\n\n\n\n// The registry wraps graphql-js and is more concise\n\n\nconst\n \nregistry\n \n=\n \nnew\n \nRegistry\n();\n\n\n\nregistry\n.\ncreateType\n(\n`\n\n\n  type User {\n\n\n    id: ID!\n\n\n    username: String!\n\n\n  }\n\n\n`\n;\n\n\n\nregistry\n.\ncreateType\n(\n`\n\n\n  type Query {\n\n\n    me: User\n\n\n  }\n\n\n`\n,\n \n{\n\n  \nme\n:\n \n(\nparent\n,\n \nargs\n,\n \ncontext\n,\n \ninfo\n)\n \n=\n \n{\n\n    \nif\n \n(\ncontext\n.\nuser\n)\n \n{\n\n      \nreturn\n \ncontext\n.\nuser\n;\n\n    \n}\n\n    \nthrow\n \nnew\n \nError\n(\nUser is not logged in (or authenticated).\n);\n\n  \n},\n\n\n};\n\n\n\nconst\n \nschema\n \n=\n \nnew\n \nGraphQLSchema\n({\n\n  \nquery\n:\n \nregistry\n.\ngetType\n(\nQuery\n),\n\n\n});\n\n\n\n\n\n\n\nBy the time the request gets to our \nQuery.me\n resolver, the server middleware has already tried\nto authenticate the user and fetch the user object from the database. In our resolver, we can then\ncheck the graphql context for the user (we set the context in our \nserver.js\n file) and if one\nexists then return it else throw an error.\n\n\n\n\nNote: you could just as easily return null instead of throwing an error and I would actually recommend it.\n\n\n\n\nYou can use this technique to start authenticating your GraphQL APIs in a moments notice. You might\nrealize, however, that this could get pretty dirty if we had to check for a user in each of our\nresolvers. This will be especially transparent as you start to build more powerful authentication\nsystems. Before we leave, let's go over a more scalable way to accomplish this.\n\n\nResolvers as a composition of functions\n\n\nIf you are familiar with \nexpress\n (or many other web frameworks for that matter), you have likely\nheard of or used middleware functions. In fact, when we called \napp.get('/protected', ...)\n earlier,\nwe were applying a piece of middleware to the \n/protected\n route handler. Being able to apply\nmiddleware like this is a very powerful technique that is an example of a more general programming\nconcept called \nfunction composition\n.\nThat's a fancy term for combining multiple small functions to create a single more powerful one.\n\n\nJust like how \nexpress\n uses middleware to process requests coming in and responses going out, we\ncan use function composition to make more maintainable and \nDRY\n\nGraphQL resolvers. This is the same\ntechnique that powers our \nLogic Functions\n at \nscaphold\n that allows you\nto pull microservices from all around the web into your Scaphold GraphQL API.\n\n\nIt might take a few minutes to wrap your head around how exactly function composition works but\nI promise that it will make you a better programmer if you master the technique. Let's rewrite the\ncode above using our new and improved functional technique.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nimport\n \n{\n \nGraphQLSchema\n \n}\n \nfrom\n \ngraphql\n;\n\n\nimport\n \n{\n \nRegistry\n \n}\n \nfrom\n \ngraphql-helpers\n;\n\n\n// See an implementation of compose https://gist.github.com/mlp5ab/f5cdee0fe7d5ed4e6a2be348b81eac12\n\n\nimport\n \n{\n \ncompose\n \n}\n \nfrom\n \n./compose\n;\n\n\n\nconst\n \nregistry\n \n=\n \nnew\n \nRegistry\n();\n\n\n\n/**\n\n\n* The authenticated function checks for a user and calls the next function in the composition if\n\n\n* one exists. If no user exists in the context then an error is thrown.\n\n\n*/\n\n\nconst\n \nauthenticated\n \n=\n\n  \n(\nfn\n:\n \nGraphQLFieldResolver\n)\n \n=\n\n  \n(\nparent\n,\n \nargs\n,\n \ncontext\n,\n \ninfo\n)\n \n=\n \n{\n\n    \nif\n \n(\ncontext\n.\nuser\n)\n \n{\n\n      \nreturn\n \nfn\n(\nparent\n,\n \nargs\n,\n \ncontext\n,\n \ninfo\n);\n\n    \n}\n\n    \nthrow\n \nnew\n \nError\n(\nUser is not authenticated\n);\n\n  \n};\n\n\n\n/*\n\n\n* getLoggedInUser returns the logged in user from the context.\n\n\n*/\n\n\nconst\n \ngetLoggedInUser\n \n=\n \n(\nparent\n,\n \nargs\n,\n \ncontext\n,\n \ninfo\n)\n \n=\n \ncontext\n.\nuser\n;\n\n\n\nregistry\n.\ncreateType\n(\n`\n\n\n  type User {\n\n\n    id: ID!\n\n\n    username: String!\n\n\n  }\n\n\n`\n;\n\n\n\nregistry\n.\ncreateType\n(\n`\n\n\n  type Query {\n\n\n    me: User\n\n\n  }\n\n\n`\n,\n \n{\n\n  \nme\n:\n \ncompose\n(\nauthenticated\n)(\ngetLoggedInUser\n)\n\n\n};\n\n\n\nconst\n \nschema\n \n=\n \nnew\n \nGraphQLSchema\n({\n\n  \nquery\n:\n \nregistry\n.\ngetType\n(\nQuery\n),\n\n\n});\n\n\n\n\n\n\n\nThe above code will work exactly the same as the first snippet. Instead of checking for the user\nin our main resolver function, we have created a highly reusable and testable middleware function\nthat achieves the same thing. The immediate impact of this design may not be apparent yet but think\nabout what would happen if we wanted to add another protected route as well as log our\nresolver running times. With our new design its as simple as:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nconst\n \ntraceResolve\n \n=\n\n  \n(\nfn\n:\n \nGraphQLFieldResolver\n)\n \n=\n\n  \nasync\n \n(\nobj\n:\n \nany\n,\n \nargs\n:\n \nany\n,\n \ncontext\n:\n \nany\n,\n \ninfo\n:\n \nany\n)\n \n=\n \n{\n\n    \nconst\n \nstart\n \n=\n \nnew\n \nDate\n().\ngetTime\n();\n\n    \nconst\n \nresult\n \n=\n \nawait\n \nfn\n(\nobj\n,\n \nargs\n,\n \ncontext\n,\n \ninfo\n);\n\n    \nconst\n \nend\n \n=\n \nnew\n \nDate\n().\ngetTime\n();\n\n    \nconsole\n.\nlog\n(\n`Resolver took \n${\nend\n \n-\n \nstart\n}\n ms`\n);\n\n    \nreturn\n \nresult\n;\n\n  \n};\n\n\n\nregistry\n.\ncreateType\n(\n`\n\n\n  type Query {\n\n\n    me: User\n\n\n    otherSecretData: SecretData\n\n\n  }\n\n\n`\n,\n \n{\n\n  \nme\n:\n \ncompose\n(\ntraceResolve\n,\n \nauthenticated\n)(\ngetLoggedInUser\n)\n\n  \notherSecretData\n:\n \ncompose\n(\ntraceResolve\n,\n \nauthenticated\n)(\ngetSecretData\n)\n\n\n};\n\n\n\n\n\n\n\nUsing this technique will help you build more robust GraphQL APIs. Function composition is a great\nsolution for authentication tasks but you can also use it for logging resolvers, cleaning input,\nmassaging output, and much more.\n\n\nAuthorization in Scaphold\n\n\nThese techniques are powerful building blocks for those of you who want to build your own GraphQL\nservers. If you want to get started right now, then we at Scaphold have already built all of This\nfor you so you can start building awesome apps. At Scaphold, our permissions allow you define\ncustom access control rules over your data. There are 4 permission scopes each of enforces slightly\ndifferent behavior.\n\n\nEVERYONE Scope\n\n\nThe everyone scope does what you might have guessed. It authorizes everyone everyone whether you\nare authenticated or not. This is useful if you want any user to be able to read a public forum\nfor example.\n\n\nAUTHENTICATED Scope\n\n\nThe authenticated scope is just as simple. It's a boolean check that authorizes an operation if the\nuser is authenticated and reject the operation if the user is not. This can be useful if you would\nonly like logged in users to create posts for example.\n\n\nROLE Scope\n\n\nThe role scope is slightly more complex. Role scoped permissions allow for Role based access control\nrules. That means you can define roles, enroll users into roles, and then apply a permission that\ngrants members of that role access to certain operations. Getting started with roles is simple:\n\n\nFirst create a roll and enroll a user into the role.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# First create a role\nmutation CreateRole($newrole:CreateRoleInput!) {\n  createRole(input:$newrole) {\n    changedRole {\n      id\n      name\n    }\n  }\n}\n\n# Then enroll a user into that role\nmutation EnrollUser($enrollment:AddToUserRolesConnectionInput!) {\n  addToUserRolesConnection(input:$enrollment) {\n    changedUserRoles {\n      user {\n        id\n      }\n      role {\n        id\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThen add a ROLE scope permission to certain operations for a type using the \nAdd Permission\n button\nin the schema designer.\n\n\nRELATION Scope\n\n\nThe relation scope is the most advanced permission scope. Role based permissions allow you to\nmanually manage role membership and grant access users access to entire types all at once. The relation\nscope uses the natural connections in your API to grant users access to objects that they are\nconnected to through some user field path. Let's look at an example from an app like slack.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# Our simple slack schema\ntype User {\n  id: ID!\n  channels: ChannelConnection\n  messages: MessageConnection\n}\n\ntype Channel {\n  id: ID!\n  name: String!\n  members: UserConnection\n  messages: MessageConnection\n}\n\ntype Message {\n  id: ID!\n  content: String!\n  channel: Channel\n  author: User\n}\n\n\n\n\n\n\nLet's say we were building slack and we wanted our users to only be able to read and create messages\nin channels that they are a member of. To do this we would create the following RELATION scoped permission\n\n\n\n\nOnce that permission is in place you can query for objects connected to your user\nthrough \nviewer.user\n. We leverage the graphql type system to keep performance quick\nas we don't need to issue any other queries to know that you are attached to the results\nwhen you query through \nviewer.user\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nquery MyChannelsAndMessages {\n  viewer {\n    user {\n      channels {\n        edges {\n          node {\n            name\n            messages {\n              edges {\n                node {\n                  id\n                  content\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nRelation scoped permissions also protect mutations. We checked \ncreate\n when we added our permission\nso now this mutation will only succeed the logged in user is already a member channel with id\n\nchannelId\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nmutation CreateMessage($input:CreateMessageInput!) {\n  createMessage(input:$input) {\n    changedMessage {\n      id\n      content\n      channel {\n        name\n      }\n    }\n  }\n}\n\n# Variables\n{\n  \ninput\n: {\n    \ncontent\n: \nI rest easy when my data is protected.\n,\n    \nchannelId\n: \nABC\n # This value determines if the operation will succeed\n  }\n}\n\n\n\n\n\n\nRELATION scoped permissions can have arbitrarily long user field paths. This means you can layer\npermissions on any operation that is connected to user via some path in your APIs graph. Stay tuned\nbecause we have even more powerful permissions features on the way that will give you even more\nfreedom in deciding how you would like to lock down your data.\n\n\nBuild better apps with GraphQL\n\n\nI hope this post helped give a better understanding for how you can implement authentication with\nGraphQL. If you are itching to get started building with GraphQL, check out \nScaphold's GraphQL Backend as a Service\n\nplatform. We have already built all of this plus much more so that you can get a scalable, secure GraphQL API that you can\nextend with your own business logic to rapidly build applications. Plus it's free for development!\n\n\nThanks for reading! Please let me know what you think in the comments!\n\n\nHappy Scapholding!\n\n\nJoin Scaphold on slack", 
            "title": "Authentication in GraphQL"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authentication-with-graphql", 
            "text": "Protecting your APIs is as critical a component as anything else in your application. We believe\nthat GraphQL is the future of APIs so let's spend a little bit of time discussing how to go about\nprotecting them. Before we start lets get a few definitions out of the way. This post is about\nauthentication and authorization. The different between the two is only a\nfew letters and the fact that they accomplish two different things.  Authentication  has to do with logging users in. This generally involves a cookie if you strictly\nbuilding a webpage or a header if you are targetting an API.  JWT's  have become\nan increasingly popular way to authenticate users with an API.  Authorization  although similar to authentication, involves granting users access to specific\nresources in an API. For example, you might be logged in and  authenticated  as John Deer but John Deer\nmight not have access to update the profile of Jane Doe and is thus not  authorized  for that operation.  Application's often have a workflow that looks like this:    A user logs in by providing a username   password and in return gets back an auth token.    The client application attaches that auth token to every future request (via the Authorization header).    Each time the server receives a request, the server validates the token and fetches the user from\nthe database.    The fetched user object is attached to some context that flows throughout the application.    Different parts of your application use the context's user to determine if the user is authorized\nfor a particular operation.    Repeat.    Scaphold  provides a number of  authentication  providers such as  Auth0 \nfor social auth,  Digits  for passwordless auth, and traditional username   password\nauth.  We also provide powerful  authorization  mechanisms via permissions. Scaphold supports\nboth role-based and relational access control that can be layered to create powerful authorization\nsystems.  Let's take a look at each of these concepts in turn to learn how they help us build more robust APIs.", 
            "title": "Authentication with GraphQL"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authentication", 
            "text": "We just learned that authentication is all about attaching a request or session to a user in the database.\nIf you are building against a GraphQL API, chances are that you will be using auth tokens. We prefer JWTs\nso let's take a look at one.", 
            "title": "Authentication"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#the-anatomy-of-a-jwt-json-web-token", 
            "text": "This is an example JWT:   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ   This might look like a random bunch of bits, but there is an order to the chaos. If you head over to  jwt.io , you\nwill find a nifty debugger that can help you make sense of this token.  A JWT is made up of three parts separated by a period  .    The header contains the algorithm and token type.    The payload has an identifier for the user  sub  as well as other metadata.    The signature is a checksum that is calculated by hashing together the header, payload, and a secret key.    When you decode the above token, you should see these values   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 // header  { \n   alg :   HS256 , \n   typ :   JWT  }  // payload  { \n   sub :   1234567890 , \n   name :   John Doe , \n   admin :   true  }  // signature  HMACSHA256 ( \n   base64UrlEncode ( header )   +   .   + \n   base64UrlEncode ( payload ), \n   secret_key  )", 
            "title": "The Anatomy of a JWT (JSON Web Token)"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authentication-with-rest", 
            "text": "So how might our application make use of a JWT? If you notice in the payload, there is a\nfield called  sub . The  sub  stands for subject and is holds an identifier\nfor the user that the token represents. To authenticate the user, a server will often have a\npiece of code that serves as the gatekeeper and validate these tokens. If you are familiar with\njavascript and express, this might look something like this.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 import   jwt   from   express-jwt ;  import   express   from   express ;  import   app   =   express ();  app . get ( /protected , \n   jwt ({ secret :   shhhhhhared-secret }), \n   function ( req ,   res )   { \n     if   ( ! req . user . admin )   return   res . sendStatus ( 401 ); \n     res . sendStatus ( 200 ); \n   });    The  express-jwt  package understands how to decode a JWT and verify its signature. We are adding\na piece of middleware  jwt({secret: 'shhhhhhared-secret'})  to the  /protected  route in our API\nso that you can only hit the  /protected  endpoint if you are authenticated.  You can rinse and repeat this technique all day long if you are building a REST API, but since\nwe are savvy developers and building GraphQL APIs this model doesn't work quite the same.", 
            "title": "Authentication with REST"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authentication-with-graphql_1", 
            "text": "GraphQL throws away the old idea that resources in an API should be denoted by some path in the\nurl. Instead, we get a rich query language that we can use to access all the data on our servers\nno matter where it lives. Authenticating a GraphQL API, however, can be a little tricky because\nwe have to think about things a little differently. Instead of attaching middleware to our endpoints,\nwe're going to solve this problem by attaching middleware to our GraphQL resolvers. But first, let's\nset the scene.  That same server file from above might look like this in GraphQL.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 import   jwt   from express-jwt ;  import   graphqlHTTP   from express-graphql ;  import   express   from express ;  import   schema   from ./mySchema ;  const   app   =   express ();  app . use ( /graphql ,   jwt ({ \n   secret :   shhhhhhared-secret , \n   requestProperty :   auth , \n   credentialsRequired :   false ,  }));  app . use ( /graphql ,   function ( req ,   res ,   done )   { \n   const   user   =   db . User . get ( req . auth . sub ); \n   req . context   =   { \n     user :   user , \n   } \n   done ();  });  app . use ( /graphql ,   graphqlHTTP ( req   =   ({ \n     schema :   schema , \n     context :   req . context , \n   })  ));    This is where things get interesting. This API is not secure at all. It might try to verify the JWT\nbut if the JWT doesn't exist or is invalid, the request will still pass through (see  credentialsRequired: false ).\nWhy? We have to allow the request to pass through because if we blocked it we would block the entire API.\nThat means, our users wouldn't even be able to call a  loginUser  mutation to get a token to authenticate themselves.\nThis is no good.  The good news that GraphQL gives us a whole set of tools to build even more robust authentication\nmechanisms than we could with REST. First, we'll cover the basics and then I'll introduce a\ntechnique that will make authentication much more scalable and fun to use.", 
            "title": "Authentication with GraphQL"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authenticate-resolvers-not-endpoints", 
            "text": "When you build a GraphQL API, you define a set of types each of which contains a set of fields and an\noptional resolver function that knows how to fetch the data necessary to satisfy that field. Here is a barebones\nexample   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 import   {   GraphQLSchema   }   from   graphql ;  import   {   Registry   }   from   graphql-helpers ;  // The registry wraps graphql-js and is more concise  const   registry   =   new   Registry ();  registry . createType ( `    type User {      id: ID!      username: String!    }  ` ;  registry . createType ( `    type Query {      me: User    }  ` ,   { \n   me :   ( parent ,   args ,   context ,   info )   =   { \n     if   ( context . user )   { \n       return   context . user ; \n     } \n     throw   new   Error ( User is not logged in (or authenticated). ); \n   },  };  const   schema   =   new   GraphQLSchema ({ \n   query :   registry . getType ( Query ),  });    By the time the request gets to our  Query.me  resolver, the server middleware has already tried\nto authenticate the user and fetch the user object from the database. In our resolver, we can then\ncheck the graphql context for the user (we set the context in our  server.js  file) and if one\nexists then return it else throw an error.   Note: you could just as easily return null instead of throwing an error and I would actually recommend it.   You can use this technique to start authenticating your GraphQL APIs in a moments notice. You might\nrealize, however, that this could get pretty dirty if we had to check for a user in each of our\nresolvers. This will be especially transparent as you start to build more powerful authentication\nsystems. Before we leave, let's go over a more scalable way to accomplish this.", 
            "title": "Authenticate resolvers, not endpoints."
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#resolvers-as-a-composition-of-functions", 
            "text": "If you are familiar with  express  (or many other web frameworks for that matter), you have likely\nheard of or used middleware functions. In fact, when we called  app.get('/protected', ...)  earlier,\nwe were applying a piece of middleware to the  /protected  route handler. Being able to apply\nmiddleware like this is a very powerful technique that is an example of a more general programming\nconcept called  function composition .\nThat's a fancy term for combining multiple small functions to create a single more powerful one.  Just like how  express  uses middleware to process requests coming in and responses going out, we\ncan use function composition to make more maintainable and  DRY \nGraphQL resolvers. This is the same\ntechnique that powers our  Logic Functions  at  scaphold  that allows you\nto pull microservices from all around the web into your Scaphold GraphQL API.  It might take a few minutes to wrap your head around how exactly function composition works but\nI promise that it will make you a better programmer if you master the technique. Let's rewrite the\ncode above using our new and improved functional technique.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 import   {   GraphQLSchema   }   from   graphql ;  import   {   Registry   }   from   graphql-helpers ;  // See an implementation of compose https://gist.github.com/mlp5ab/f5cdee0fe7d5ed4e6a2be348b81eac12  import   {   compose   }   from   ./compose ;  const   registry   =   new   Registry ();  /**  * The authenticated function checks for a user and calls the next function in the composition if  * one exists. If no user exists in the context then an error is thrown.  */  const   authenticated   = \n   ( fn :   GraphQLFieldResolver )   = \n   ( parent ,   args ,   context ,   info )   =   { \n     if   ( context . user )   { \n       return   fn ( parent ,   args ,   context ,   info ); \n     } \n     throw   new   Error ( User is not authenticated ); \n   };  /*  * getLoggedInUser returns the logged in user from the context.  */  const   getLoggedInUser   =   ( parent ,   args ,   context ,   info )   =   context . user ;  registry . createType ( `    type User {      id: ID!      username: String!    }  ` ;  registry . createType ( `    type Query {      me: User    }  ` ,   { \n   me :   compose ( authenticated )( getLoggedInUser )  };  const   schema   =   new   GraphQLSchema ({ \n   query :   registry . getType ( Query ),  });    The above code will work exactly the same as the first snippet. Instead of checking for the user\nin our main resolver function, we have created a highly reusable and testable middleware function\nthat achieves the same thing. The immediate impact of this design may not be apparent yet but think\nabout what would happen if we wanted to add another protected route as well as log our\nresolver running times. With our new design its as simple as:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 const   traceResolve   = \n   ( fn :   GraphQLFieldResolver )   = \n   async   ( obj :   any ,   args :   any ,   context :   any ,   info :   any )   =   { \n     const   start   =   new   Date (). getTime (); \n     const   result   =   await   fn ( obj ,   args ,   context ,   info ); \n     const   end   =   new   Date (). getTime (); \n     console . log ( `Resolver took  ${ end   -   start }  ms` ); \n     return   result ; \n   };  registry . createType ( `    type Query {      me: User      otherSecretData: SecretData    }  ` ,   { \n   me :   compose ( traceResolve ,   authenticated )( getLoggedInUser ) \n   otherSecretData :   compose ( traceResolve ,   authenticated )( getSecretData )  };    Using this technique will help you build more robust GraphQL APIs. Function composition is a great\nsolution for authentication tasks but you can also use it for logging resolvers, cleaning input,\nmassaging output, and much more.", 
            "title": "Resolvers as a composition of functions"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authorization-in-scaphold", 
            "text": "These techniques are powerful building blocks for those of you who want to build your own GraphQL\nservers. If you want to get started right now, then we at Scaphold have already built all of This\nfor you so you can start building awesome apps. At Scaphold, our permissions allow you define\ncustom access control rules over your data. There are 4 permission scopes each of enforces slightly\ndifferent behavior.", 
            "title": "Authorization in Scaphold"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#everyone-scope", 
            "text": "The everyone scope does what you might have guessed. It authorizes everyone everyone whether you\nare authenticated or not. This is useful if you want any user to be able to read a public forum\nfor example.", 
            "title": "EVERYONE Scope"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#authenticated-scope", 
            "text": "The authenticated scope is just as simple. It's a boolean check that authorizes an operation if the\nuser is authenticated and reject the operation if the user is not. This can be useful if you would\nonly like logged in users to create posts for example.", 
            "title": "AUTHENTICATED Scope"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#role-scope", 
            "text": "The role scope is slightly more complex. Role scoped permissions allow for Role based access control\nrules. That means you can define roles, enroll users into roles, and then apply a permission that\ngrants members of that role access to certain operations. Getting started with roles is simple:  First create a roll and enroll a user into the role.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 # First create a role\nmutation CreateRole($newrole:CreateRoleInput!) {\n  createRole(input:$newrole) {\n    changedRole {\n      id\n      name\n    }\n  }\n}\n\n# Then enroll a user into that role\nmutation EnrollUser($enrollment:AddToUserRolesConnectionInput!) {\n  addToUserRolesConnection(input:$enrollment) {\n    changedUserRoles {\n      user {\n        id\n      }\n      role {\n        id\n      }\n    }\n  }\n}   Then add a ROLE scope permission to certain operations for a type using the  Add Permission  button\nin the schema designer.", 
            "title": "ROLE Scope"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#relation-scope", 
            "text": "The relation scope is the most advanced permission scope. Role based permissions allow you to\nmanually manage role membership and grant access users access to entire types all at once. The relation\nscope uses the natural connections in your API to grant users access to objects that they are\nconnected to through some user field path. Let's look at an example from an app like slack.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 # Our simple slack schema\ntype User {\n  id: ID!\n  channels: ChannelConnection\n  messages: MessageConnection\n}\n\ntype Channel {\n  id: ID!\n  name: String!\n  members: UserConnection\n  messages: MessageConnection\n}\n\ntype Message {\n  id: ID!\n  content: String!\n  channel: Channel\n  author: User\n}   Let's say we were building slack and we wanted our users to only be able to read and create messages\nin channels that they are a member of. To do this we would create the following RELATION scoped permission   Once that permission is in place you can query for objects connected to your user\nthrough  viewer.user . We leverage the graphql type system to keep performance quick\nas we don't need to issue any other queries to know that you are attached to the results\nwhen you query through  viewer.user .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 query MyChannelsAndMessages {\n  viewer {\n    user {\n      channels {\n        edges {\n          node {\n            name\n            messages {\n              edges {\n                node {\n                  id\n                  content\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}   Relation scoped permissions also protect mutations. We checked  create  when we added our permission\nso now this mutation will only succeed the logged in user is already a member channel with id channelId .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 mutation CreateMessage($input:CreateMessageInput!) {\n  createMessage(input:$input) {\n    changedMessage {\n      id\n      content\n      channel {\n        name\n      }\n    }\n  }\n}\n\n# Variables\n{\n   input : {\n     content :  I rest easy when my data is protected. ,\n     channelId :  ABC  # This value determines if the operation will succeed\n  }\n}   RELATION scoped permissions can have arbitrarily long user field paths. This means you can layer\npermissions on any operation that is connected to user via some path in your APIs graph. Stay tuned\nbecause we have even more powerful permissions features on the way that will give you even more\nfreedom in deciding how you would like to lock down your data.", 
            "title": "RELATION Scope"
        }, 
        {
            "location": "/tutorials/authentication-in-graphql/#build-better-apps-with-graphql", 
            "text": "I hope this post helped give a better understanding for how you can implement authentication with\nGraphQL. If you are itching to get started building with GraphQL, check out  Scaphold's GraphQL Backend as a Service \nplatform. We have already built all of this plus much more so that you can get a scalable, secure GraphQL API that you can\nextend with your own business logic to rapidly build applications. Plus it's free for development!  Thanks for reading! Please let me know what you think in the comments!  Happy Scapholding!  Join Scaphold on slack", 
            "title": "Build better apps with GraphQL"
        }, 
        {
            "location": "/tutorials/search-with-algolia/", 
            "text": "Learn how to integrate Algolia into your GraphQL backend\n\n\n\n\nEvery day, millions of requests are served by Scaphold.io, a GraphQL backend as a service company  that helps people rapidly develop apps.\n\n\n\n\nWe\u2019ve helped companies like National Geographic, Visa, and software consulting agencies drastically reduce their development cycle from 3 months to 2\u00a0weeks.\n\n\n\n\nAt Scaphold, we pride ourselves in not only providing the best app development experience, but also offering the best end-user experiences as possible. We ensure that every request makes it to the client as reliably, efficiently, and as fast as possible with millisecond latencies.\n\n\n\n\nMilliseconds really do matter!\u00a0\u231b\ufe0f\n\n\n\n\nThe Problem\n\n\nApps need any easy way to add search functionality.\n\n\nScaphold customers come in all shapes and sizes. From indie developers, to small startups and even larger enterprises like National Geographic, Scaphold guarantees their customers the fastest response times across the industry for all types of apps and data. All too often, apps are centralized upon \nfull-text search\n to be able to provide the workflow they want for their users, and we needed a way to address that cleanly and scalably. In addition, many apps include rich location-based features as core components for their product, meaning Scaphold needed to provide geo-indexing for \nlocation-based querying\n. For instance, the app might help people find nearby restaurants in a given radius based on their current location. These are very common use cases for modern apps, and it\u2019s no surprise that Scaphold needed to consider various way to support these features.\n\n\nThe Solution\n\n\nEnter Algolia.\n\n\nWe found Algolia since we were both Y Combinator companies. And even after we did our research and scoured the web to find alternative search solutions, the only other one that was in the same league ElasticSearch.\n\n\nBut then we found this:\n\n\n\n\nSource: https://blog.algolia.com/full-text-search-in-your-database-algolia-versus-elasticsearch/\n\n\nObjectively, there are tons of use cases for ElasticSearch, but for our purposes at Scaphold, we needed speed and ease-of-use, and in lieu of our integrations platform, it was a no-brainer to couple Scaphold with Algolia as our search solution. And it covered our customers\u2019 biggest use cases: full-text search and geo-search.\n\n\nHow It\u00a0Works\n\n\nScaphold\u2019s Algolia integration.\n\n\n\n\nScaphold provides a wide array of integrations to third-party services, allowing developers on our platform to be able to modularly append large chunks of functionality all into their one standardized GraphQL API. In the case of Algolia, all you need is your Application ID and API key.\n\n\n\n\nScaphold will be able to automatically synchronize your data across your app with Algolia\u2019s indexes.\n\n\n\n\nThere are two things going on here under the hood:\n\n\n\n\n\n\nUpon enabling Scaphold\u2019s Algolia integration, you\u2019ll be able to pick which types you want to index, and immediately that data will be searchable using corresponding GraphQL queries that are added to your API.\n\n\n\n\n\n\nEach request that creates, updates, or deletes data of that type will automatically trigger the same operation on that particular Algolia index, ensuring that the data in Algolia always stays in sync with your data on Scaphold.\n\n\n\n\n\n\n\n\n\ud83d\ude4c In a matter of minutes, you\u2019ll have Algolia\u2019s search experiences available through GraphQL on Scaphold\u2019s platform, without having to manage any infrastructure yourself.\n\n\n\n\n\nQuick Demo\n\n\nSeeing is believing.\n\n\nAt Scaphold, we needed a way to demonstrate the power of GraphQL and search working together. So we built a simple Slack messaging app that allows you to send messages in real-time, as well as search through those messages at lightning speeds using GraphQL and Algolia.\n\n\nCheck it out!\n\n\n\n\nThis was all built in a matter of minutes without having to write any server-side code to set this up. If you want to start playing around with it, we\u2019ve provided the \nfull code example on GitHub\n.\n\n\n\n\n\ud83c\udf89 Voil\u00e0!\n\n\n\n\nApp developers now have a simple and very well-integrated solution to expose search in their GraphQL APIs with just a few clicks of a button, all thanks to our amazing Algolia integration. Thousands of apps have now been built on Scaphold as a result of this awesome example, and you can \nget started today as well\n!\n\n\nTo learn more, follow us on \nTwitter\n or join our \nSlack\n!", 
            "title": "Add Search With Algolia"
        }, 
        {
            "location": "/tutorials/search-with-algolia/#learn-how-to-integrate-algolia-into-your-graphql-backend", 
            "text": "Every day, millions of requests are served by Scaphold.io, a GraphQL backend as a service company  that helps people rapidly develop apps.   We\u2019ve helped companies like National Geographic, Visa, and software consulting agencies drastically reduce their development cycle from 3 months to 2\u00a0weeks.   At Scaphold, we pride ourselves in not only providing the best app development experience, but also offering the best end-user experiences as possible. We ensure that every request makes it to the client as reliably, efficiently, and as fast as possible with millisecond latencies.   Milliseconds really do matter!\u00a0\u231b\ufe0f", 
            "title": "Learn how to integrate Algolia into your GraphQL backend"
        }, 
        {
            "location": "/tutorials/search-with-algolia/#the-problem", 
            "text": "", 
            "title": "The Problem"
        }, 
        {
            "location": "/tutorials/search-with-algolia/#apps-need-any-easy-way-to-add-search-functionality", 
            "text": "Scaphold customers come in all shapes and sizes. From indie developers, to small startups and even larger enterprises like National Geographic, Scaphold guarantees their customers the fastest response times across the industry for all types of apps and data. All too often, apps are centralized upon  full-text search  to be able to provide the workflow they want for their users, and we needed a way to address that cleanly and scalably. In addition, many apps include rich location-based features as core components for their product, meaning Scaphold needed to provide geo-indexing for  location-based querying . For instance, the app might help people find nearby restaurants in a given radius based on their current location. These are very common use cases for modern apps, and it\u2019s no surprise that Scaphold needed to consider various way to support these features.", 
            "title": "Apps need any easy way to add search functionality."
        }, 
        {
            "location": "/tutorials/search-with-algolia/#the-solution", 
            "text": "", 
            "title": "The Solution"
        }, 
        {
            "location": "/tutorials/search-with-algolia/#enter-algolia", 
            "text": "We found Algolia since we were both Y Combinator companies. And even after we did our research and scoured the web to find alternative search solutions, the only other one that was in the same league ElasticSearch.  But then we found this:   Source: https://blog.algolia.com/full-text-search-in-your-database-algolia-versus-elasticsearch/  Objectively, there are tons of use cases for ElasticSearch, but for our purposes at Scaphold, we needed speed and ease-of-use, and in lieu of our integrations platform, it was a no-brainer to couple Scaphold with Algolia as our search solution. And it covered our customers\u2019 biggest use cases: full-text search and geo-search.", 
            "title": "Enter Algolia."
        }, 
        {
            "location": "/tutorials/search-with-algolia/#how-it-works", 
            "text": "", 
            "title": "How It\u00a0Works"
        }, 
        {
            "location": "/tutorials/search-with-algolia/#scapholds-algolia-integration", 
            "text": "Scaphold provides a wide array of integrations to third-party services, allowing developers on our platform to be able to modularly append large chunks of functionality all into their one standardized GraphQL API. In the case of Algolia, all you need is your Application ID and API key.   Scaphold will be able to automatically synchronize your data across your app with Algolia\u2019s indexes.   There are two things going on here under the hood:    Upon enabling Scaphold\u2019s Algolia integration, you\u2019ll be able to pick which types you want to index, and immediately that data will be searchable using corresponding GraphQL queries that are added to your API.    Each request that creates, updates, or deletes data of that type will automatically trigger the same operation on that particular Algolia index, ensuring that the data in Algolia always stays in sync with your data on Scaphold.     \ud83d\ude4c In a matter of minutes, you\u2019ll have Algolia\u2019s search experiences available through GraphQL on Scaphold\u2019s platform, without having to manage any infrastructure yourself.", 
            "title": "Scaphold\u2019s Algolia integration."
        }, 
        {
            "location": "/tutorials/search-with-algolia/#quick-demo", 
            "text": "", 
            "title": "Quick Demo"
        }, 
        {
            "location": "/tutorials/search-with-algolia/#seeing-is-believing", 
            "text": "At Scaphold, we needed a way to demonstrate the power of GraphQL and search working together. So we built a simple Slack messaging app that allows you to send messages in real-time, as well as search through those messages at lightning speeds using GraphQL and Algolia.  Check it out!   This was all built in a matter of minutes without having to write any server-side code to set this up. If you want to start playing around with it, we\u2019ve provided the  full code example on GitHub .   \ud83c\udf89 Voil\u00e0!   App developers now have a simple and very well-integrated solution to expose search in their GraphQL APIs with just a few clicks of a button, all thanks to our amazing Algolia integration. Thousands of apps have now been built on Scaphold as a result of this awesome example, and you can  get started today as well !  To learn more, follow us on  Twitter  or join our  Slack !", 
            "title": "Seeing is believing."
        }, 
        {
            "location": "/tutorials/aggregations-in-graphql/", 
            "text": "Build Data Driven Applications with GraphQL Aggregations\n\n\nToday we launched our newest feature with Aggregations! All applications now come with\npowerful analytical capabilities by default!\nGo take a look at the documentation explorer in the GraphiQL tab of the Scaphold portal to check out\nall the awesome new functionality. In the meantime, here are the basics!\n\n\nAggregations crash course\n\n\nImagine you were building a blogging platform like Medium. It would be an obvious value add\nto be able to slice \n dice your data to better understand how your posts are performing. Let's\nsay our blogging platform has an \nArticle\n model like this:\n\n\n1\n2\n3\n4\n5\n6\n7\ntype Article {\n  id: ID!\n  title: String\n  content: Text    # Like a String but larger\n  recommends: Int\n  reads: Int\n}\n\n\n\n\n\n\nIt would be really nice to be able to ask questions like, how many times were all our articles\nread in 2016?\nWith aggregations and GraphQL this is easy!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nquery LikeData {\n  viewer {\n    allArticles(where:{ createdAt: { gt: \n2016\n, lt: \n2017\n }}) {\n      aggregations {\n        sum {\n          reads\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThis is great, but what if we also wanted to know the average read count and the total number\nof articles listed  on the site.\nWhile we're at it, lets also grab the total \n average number of recommendations for our articles.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nquery PostData {\n  viewer {\n    allArticles(where:{ createdAt: { gt: \n2016\n, lt: \n2017\n }}) {\n      aggregations {\n        count\n        sum {\n          recommends\n          reads\n        }\n        avg {\n          recommends\n          reads\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThis query is both intuitive to understand and performant. Behind the scenes all of these\nmetrics are calculated in a single query keeping your api snappy and you user's happy! Aggregations\nopen the door for all kinds of insights into our data. For example, we could use the query above\nto answer a question like what is the average conversion rate from a read to a recommendation.\n\n\nThis is just touching the surface of our aggregation capabilities. Let's keep digging.\n\n\nAdvanced Aggregations Using Connections\n\n\nIn the previous section, we showed how you can crunch the numbers for all the records\nin your dataset. This is useful for administrative tasks, but often our applications\nare more user-centric. The good news is that aggregations work for every connection in\nyour API.\n\n\nLet's compound on the previous example and ask the question, \"How many reads did MY posts\nget on average in 2016?\". To make this work, we need to introduce a \nUser\n type.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\ntype User {\n  id: ID!\n  username: String\n  password: Secret\n  articles: ArticleConnection\n}\n\ntype Article {\n  id: ID!\n  title: String\n  content: Text\n  recommends: Int\n  reads: Int\n  author: User\n}\n\n\n\n\n\n\nOnce we setup the connection between our \nUser\n and \nArticle\n types, we can issue a query like this\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nquery PostData {\n  viewer {\n    user {\n      articles(where:{ createdAt: { gt: \n2016\n, lt: \n2017\n }}) {\n        aggregations {\n          count\n          sum {\n            recommends\n            reads\n          }\n          avg {\n            recommends\n            reads\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nThis query will only perform the aggregation on the articles that are attached to the logged in\nuser via the \narticles\n connection. You can continue to manipulate these queries with more and more\nadvanced filters and aggregations. You'll find that every connection in your API operates the same\nway allowing you do run multiple aggregations at different levels in your GraphQL API!\n\n\nThanks for reading\n\n\nI hope this helps show you the kinds of queries you can run to build powerful, data-driven\napplications with GraphQL! Thanks for reading! Please let me know what you think in the comments!\n\n\nHappy Scapholding!\n\n\nJoin us on slack", 
            "title": "Aggregations In GraphQL"
        }, 
        {
            "location": "/tutorials/aggregations-in-graphql/#build-data-driven-applications-with-graphql-aggregations", 
            "text": "Today we launched our newest feature with Aggregations! All applications now come with\npowerful analytical capabilities by default!\nGo take a look at the documentation explorer in the GraphiQL tab of the Scaphold portal to check out\nall the awesome new functionality. In the meantime, here are the basics!", 
            "title": "Build Data Driven Applications with GraphQL Aggregations"
        }, 
        {
            "location": "/tutorials/aggregations-in-graphql/#aggregations-crash-course", 
            "text": "Imagine you were building a blogging platform like Medium. It would be an obvious value add\nto be able to slice   dice your data to better understand how your posts are performing. Let's\nsay our blogging platform has an  Article  model like this:  1\n2\n3\n4\n5\n6\n7 type Article {\n  id: ID!\n  title: String\n  content: Text    # Like a String but larger\n  recommends: Int\n  reads: Int\n}   It would be really nice to be able to ask questions like, how many times were all our articles\nread in 2016?\nWith aggregations and GraphQL this is easy!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 query LikeData {\n  viewer {\n    allArticles(where:{ createdAt: { gt:  2016 , lt:  2017  }}) {\n      aggregations {\n        sum {\n          reads\n        }\n      }\n    }\n  }\n}   This is great, but what if we also wanted to know the average read count and the total number\nof articles listed  on the site.\nWhile we're at it, lets also grab the total   average number of recommendations for our articles.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 query PostData {\n  viewer {\n    allArticles(where:{ createdAt: { gt:  2016 , lt:  2017  }}) {\n      aggregations {\n        count\n        sum {\n          recommends\n          reads\n        }\n        avg {\n          recommends\n          reads\n        }\n      }\n    }\n  }\n}   This query is both intuitive to understand and performant. Behind the scenes all of these\nmetrics are calculated in a single query keeping your api snappy and you user's happy! Aggregations\nopen the door for all kinds of insights into our data. For example, we could use the query above\nto answer a question like what is the average conversion rate from a read to a recommendation.  This is just touching the surface of our aggregation capabilities. Let's keep digging.", 
            "title": "Aggregations crash course"
        }, 
        {
            "location": "/tutorials/aggregations-in-graphql/#advanced-aggregations-using-connections", 
            "text": "In the previous section, we showed how you can crunch the numbers for all the records\nin your dataset. This is useful for administrative tasks, but often our applications\nare more user-centric. The good news is that aggregations work for every connection in\nyour API.  Let's compound on the previous example and ask the question, \"How many reads did MY posts\nget on average in 2016?\". To make this work, we need to introduce a  User  type.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 type User {\n  id: ID!\n  username: String\n  password: Secret\n  articles: ArticleConnection\n}\n\ntype Article {\n  id: ID!\n  title: String\n  content: Text\n  recommends: Int\n  reads: Int\n  author: User\n}   Once we setup the connection between our  User  and  Article  types, we can issue a query like this   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 query PostData {\n  viewer {\n    user {\n      articles(where:{ createdAt: { gt:  2016 , lt:  2017  }}) {\n        aggregations {\n          count\n          sum {\n            recommends\n            reads\n          }\n          avg {\n            recommends\n            reads\n          }\n        }\n      }\n    }\n  }\n}   This query will only perform the aggregation on the articles that are attached to the logged in\nuser via the  articles  connection. You can continue to manipulate these queries with more and more\nadvanced filters and aggregations. You'll find that every connection in your API operates the same\nway allowing you do run multiple aggregations at different levels in your GraphQL API!", 
            "title": "Advanced Aggregations Using Connections"
        }, 
        {
            "location": "/tutorials/aggregations-in-graphql/#thanks-for-reading", 
            "text": "I hope this helps show you the kinds of queries you can run to build powerful, data-driven\napplications with GraphQL! Thanks for reading! Please let me know what you think in the comments!  Happy Scapholding!  Join us on slack", 
            "title": "Thanks for reading"
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/", 
            "text": "Hi folks!\n\n\nToday, we\u2019re going to be taking a deep dive into how you can analyze your GraphQL server for performance monitoring.\n\n\nWhy analytics is important?\n\n\nFor those that care about performance, money, UX, and scalability.\n\n\nAs we move into a GraphQL-first world, it\u2019s important to be able to understand not only what data you\u2019re fetching, but also how it\u2019s being fetched. Many people think of this as an after-thought, especially for those trying to \u201cmove fast and break things\u201d, in hopes that getting as much code out as possible as fast as possible will help them win over their competition.\n\n\nHowever, \u201cmoving fast\u201d can be costly on many levels. First of all, your application\u2019s end users will feel the clunkiness of your application. In addition, on your servers, fetching data the wrong way can create inefficiencies that cost CPU usage, memory leaks, and slow response times, not to mention your AWS bill skyrocketing through the roof. Not the type of growth you\u2019re looking for probably.\n\n\n\n\nReal world example:\n  \n\n  In 2016, \nFacebook reported to have lost $19,385 per minute\n in profits that it was down. \nhttp://bit.ly/2l6wibD\n\n\n\n\nPerformance matters.\n\n\nLet\u2019s get\u00a0started!\n\n\nEasily hook up Apollo Optics into your GraphQL API in a couple minutes.\n\n\nThere\u2019s a simple-to-use tool called \nApollo Optics\n. You can try it out for free, and it comes with a beautiful dashboard that helps you visualize your queries to gain insights on request order and response times.\n\n\n\n\nGraphQL lends itself to awesome tooling like this due to its type system, where you can clearly and automatically introspect what the inputs and outputs are of a an API.\n\n\nHere are the steps:\n\n\n\n\n\n\nSign up for Scaphold and create an app.\n\n\nOnce you hit \nCreate\n, you\u2019ll automatically have a production-ready GraphQL server and API at your disposal.\n\n\n\n\n\n\n\n\nSign up for \nApollo Optics\n and grab your API key.\n\n\nOn your Apollo Optics account, open your \napp settings\n.\n\n\n\n\nCopy your API key\n for use in the next step.\n\n\n\n\n\n\n\n\nAdd Apollo Optics integration on Scaphold.\n\n\nIn the Integrations Dashboard, click \nAdd\n.\n\n\n\n\nPaste your API key\n from earlier into the appropriate field, then hit \nCreate\n.\n\n\n\n\n\n\n\n\nMake a request and see it in your Optics dashboard!\n\n\nIn this case, we created a couple users and queried for all of them back.\n\n\n\n\nOur data shows up within seconds in our Apollo Optics dashboard. Hooray!\n\n\n\n\n\n\n\n\nSeeing the\u00a0Value\n\n\nTrimming out unnecessary calls can save you time and money.\n\n\nLet\u2019s take the Facebook example.\n\n\n\n\nIf you were Facebook last year, \neach second you wasted would have cost you $323\n \nhttp://bit.ly/2l6wibD\n.\n\n\n\n\nTo demonstrate how much money we can save, let\u2019s make a Stripe call to create a new customer in order to simulate Facebook\u2019s payment flow.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmutation CreateStripeCustomer ($customer: CreateStripeCustomerInput!) {\n  createStripeCustomer(input: $customer) {\n    changedStripeCustomer {\n      id\n      email\n      created\n    }\n  }\n}\n\n\n\n\n\n\nCheck it out in your Optics dashboard. Look at how much time that took.\n\n\nThat request took 219ms\n\n\n\n\nLooks like the bottleneck is when we\u2019re asking for the created field to be returned as part of the request. We actually don\u2019t need that value on our client, so let\u2019s remove it from the request.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nmutation CreateStripeCustomer ($customer: CreateStripeCustomerInput!) {\n  createStripeCustomer(input: $customer) {\n    changedStripeCustomer {\n      id\n      email\n    }\n  }\n}\n\n\n\n\n\n\nAfter running this mutation, we can see that the total request time was only 157ms.\n\n\n\n\nRequest time decreased by over 28%!\u00a0\ud83c\udf89\n\n\n\n\n\n\nIn dollar amounts, you were able to \nsave Facebook about $20 each time a new customer was created\n. Now, that\u2019s pretty significant.\n\n\nCongratulations! You\u2019ve successfully set up powerful analytics to help you optimize your GraphQL API, and saved yourself both time and money.\n\n\nThanks for reading!\n\n\nIf you\u2019re interested in learning more about analytics, feel free to join our Slack channel and ask us directly, or get started today with Apollo Optics and Scaphold.io!\n\n\nHappy to provide more information on how you can optimize your GraphQL API and more.", 
            "title": "Integrate Apollo Optics"
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#why-analytics-is-important", 
            "text": "", 
            "title": "Why analytics is important?"
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#for-those-that-care-about-performance-money-ux-and-scalability", 
            "text": "As we move into a GraphQL-first world, it\u2019s important to be able to understand not only what data you\u2019re fetching, but also how it\u2019s being fetched. Many people think of this as an after-thought, especially for those trying to \u201cmove fast and break things\u201d, in hopes that getting as much code out as possible as fast as possible will help them win over their competition.  However, \u201cmoving fast\u201d can be costly on many levels. First of all, your application\u2019s end users will feel the clunkiness of your application. In addition, on your servers, fetching data the wrong way can create inefficiencies that cost CPU usage, memory leaks, and slow response times, not to mention your AWS bill skyrocketing through the roof. Not the type of growth you\u2019re looking for probably.   Real world example:\n   \n  In 2016,  Facebook reported to have lost $19,385 per minute  in profits that it was down.  http://bit.ly/2l6wibD", 
            "title": "For those that care about performance, money, UX, and scalability."
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#performance-matters", 
            "text": "", 
            "title": "Performance matters."
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#lets-get-started", 
            "text": "", 
            "title": "Let\u2019s get\u00a0started!"
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#easily-hook-up-apollo-optics-into-your-graphql-api-in-a-couple-minutes", 
            "text": "There\u2019s a simple-to-use tool called  Apollo Optics . You can try it out for free, and it comes with a beautiful dashboard that helps you visualize your queries to gain insights on request order and response times.   GraphQL lends itself to awesome tooling like this due to its type system, where you can clearly and automatically introspect what the inputs and outputs are of a an API.  Here are the steps:    Sign up for Scaphold and create an app.  Once you hit  Create , you\u2019ll automatically have a production-ready GraphQL server and API at your disposal.     Sign up for  Apollo Optics  and grab your API key.  On your Apollo Optics account, open your  app settings .   Copy your API key  for use in the next step.     Add Apollo Optics integration on Scaphold.  In the Integrations Dashboard, click  Add .   Paste your API key  from earlier into the appropriate field, then hit  Create .     Make a request and see it in your Optics dashboard!  In this case, we created a couple users and queried for all of them back.   Our data shows up within seconds in our Apollo Optics dashboard. Hooray!", 
            "title": "Easily hook up Apollo Optics into your GraphQL API in a couple minutes."
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#seeing-the-value", 
            "text": "", 
            "title": "Seeing the\u00a0Value"
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#trimming-out-unnecessary-calls-can-save-you-time-and-money", 
            "text": "Let\u2019s take the Facebook example.   If you were Facebook last year,  each second you wasted would have cost you $323   http://bit.ly/2l6wibD .   To demonstrate how much money we can save, let\u2019s make a Stripe call to create a new customer in order to simulate Facebook\u2019s payment flow.  1\n2\n3\n4\n5\n6\n7\n8\n9 mutation CreateStripeCustomer ($customer: CreateStripeCustomerInput!) {\n  createStripeCustomer(input: $customer) {\n    changedStripeCustomer {\n      id\n      email\n      created\n    }\n  }\n}   Check it out in your Optics dashboard. Look at how much time that took.", 
            "title": "Trimming out unnecessary calls can save you time and money."
        }, 
        {
            "location": "/tutorials/apollo-optics-graphql-server/#that-request-took-219ms", 
            "text": "Looks like the bottleneck is when we\u2019re asking for the created field to be returned as part of the request. We actually don\u2019t need that value on our client, so let\u2019s remove it from the request.  1\n2\n3\n4\n5\n6\n7\n8 mutation CreateStripeCustomer ($customer: CreateStripeCustomerInput!) {\n  createStripeCustomer(input: $customer) {\n    changedStripeCustomer {\n      id\n      email\n    }\n  }\n}   After running this mutation, we can see that the total request time was only 157ms.   Request time decreased by over 28%!\u00a0\ud83c\udf89    In dollar amounts, you were able to  save Facebook about $20 each time a new customer was created . Now, that\u2019s pretty significant.  Congratulations! You\u2019ve successfully set up powerful analytics to help you optimize your GraphQL API, and saved yourself both time and money.  Thanks for reading!  If you\u2019re interested in learning more about analytics, feel free to join our Slack channel and ask us directly, or get started today with Apollo Optics and Scaphold.io!  Happy to provide more information on how you can optimize your GraphQL API and more.", 
            "title": "That request took 219ms"
        }, 
        {
            "location": "/tutorials/adding-social-auth/", 
            "text": "How to integrate OAuth with \nScaphold's\n GraphQL platform.\n\n\n\n\nHi GraphQL-Lovers!\n\n\nSocial authentication has been a hot topic for developers and users alike. There are many guides on how to implement it for traditional REST-based APIs, so here's one for the good guys.\n\n\nWhy social authentication? It all starts with the users. Most people have online social accounts on Facebook, Twitter, Google, and more. So they're thinking,\n\n\n\n\n\u201cI'll check out your app if I can just log in with my existing Facebook or Twitter account.\u201d\n\n\n\n\nThe benefits are two-fold.\n\n\n\n\n\n\nUsers\n are excited to get to remember one less account name and password. Hooray!\n\n\n\n\n\n\nDevelopers\n gets more content from these social authentication providers immediately upon log in, like emails, profile pictures, friends, etc\u2026\n\n\n\n\n\n\nHere's how it works at a high level:\n\n\n\n\nSource: \nhttps://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\n\n\n\n\n\n\nUser must grant the application permission to access secured resources from an OAuth provider (i.e. Facebook, Google, etc).\n\n\n\n\n\n\nAfter the user successfully grants the application access, the OAuth provider generates a user access token and passes it back to the application.\n\n\n\n\n\n\nThe application sends this user access token to the OAuth provider along with its own identity in order to authenticate.\n\n\n\n\n\n\nUpon successful authentication, the OAuth provider grants authorization and returns an app access token.\n\n\n\n\n\n\nNow that authorization is completed, the application may use the app access token for authentication to fetch authorized resources from the OAuth provider.\n\n\n\n\n\n\nApp access token is verified and the requested OAuth provider's resources are sent back to the application.\n\n\n\n\nThis isn't easy!\n\n\n\n\n\n\n\n\nTo do this yourself, you will have to perform the same workflow for every OAuth provider you wish to authenticate with. The best tool that we've found to help manage all these connections is \nAuth0\n. We'll be using this tool for the GraphQL walkthrough to help us set up OAuth.\n\n\nToday, we'll explore two of the most popular social providers:\n\n\n\n\nFacebook\n and \nGoogle\n.\n\n\n\n\nHere's the agenda:\n\n\n\n\n\n\nCreate an Auth0 account.\n\n\n\n\n\n\nConfigure Facebook and Google connections.\n\n\n\n\n\n\nUse Auth0 account keys to configure an Auth0 integration on \nScaphold\n.\n\n\n\n\n\n\nObtain access token from Facebook client SDK, exchange it for an ID token, and send GraphQL request to authenticate.\n\n\n\n\n\n\nStore JSON Web Token (JWT) as Authorization header in HTTP requests.\n\n\n\n\n\n\nOnce logged in, send another GraphQL request with a Google ID token to link both social authentication credentials.\n\n\n\n\n\n\nVoil\u00e1!\n\n\n\n\n\n\nLet's start by \ncreating a free Auth0 account\n.\n\n\nThis will help you manage your app credentials like client IDs and secrets for your OAuth providers. By connecting your apps on your social accounts like Facebook, Google, and Twitter, you'll then have the correct account credentials to utilize these services for your authentication flow.\n\n\n\n\nFor more information on configuring your social connections on Auth0, check out these guides: \nFacebook\n / \nGoogle\n\n\nOnce you've tested out your connections to see that they work, \nsave your Auth0 Domain, Client ID, and Client Secret\n.\n\n\n\n\nNext, \nconfigure Auth0 in \nScaphold\n from the Integrations Portal to include the OAuth providers that you plan to use for your app. This will enable a new mutation in your schema called \nloginUserWithAuth0\n which you can use to log in users with connected OAuth providers.\n\n\n\n\nIn your client app, you'll likely be using a client SDK to handle user login. For instance, you can use the \nFacebook SDK for React Native\n to ask your users to log in with their existing Facebook accounts. Your app will redirect them to a Facebook sign-in page and once this succeeds, you'll receive an \naccess token\n that you'll verify with your OAuth provider, and then the corresponding \nidToken\n will be sent to \nScaphold\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\nconst\n \nFBSDK\n \n=\n \nrequire\n(\nreact-native-fbsdk\n);\n\n\nconst\n \nrp\n \n=\n \nrequire\n(\nrequest-promise\n);\n\n\n\nconst\n \n{\n\n  \nLoginButton,\n\n  \nAccessToken\n\n\n}\n \n=\n \nFBSDK\n;\n\n\n\nvar\n \nLogin\n \n=\n \nReact\n.\ncreateClass\n(\n{\n\n  \nrender\n:\n \nfunction\n()\n \n{\n\n    \nreturn\n \n(\n\n      \nView\n\n        \nLoginButton\n\n          \npublishPermissions\n=\n{\n[\npublish_actions\n]\n}\n\n          \nonLoginFinished\n=\n{\n\n            \n(error,\n \nresult)\n \n=\n \n{\n\n              \nif\n \n(error)\n \n{\n\n                \nalert(\nlogin\n \nhas\n \nerror\n:\n \n + result.error);\n\n\n              } else if (result.isCancelled) {\n\n\n                alert(\nlogin\n \nis\n \ncancelled\n.\n);\n\n\n              } else {\n\n\n                AccessToken.getCurrentAccessToken().then(\n\n\n                  (data) =\n {\n\n\n\n                    /*\n\n\n                     * Use Access Token to retrieve Auth0 ID Token\n\n\n                     */\n\n\n\n                    const options = {\n\n\n                      method: \nPOST\n,\n\n\n                      uri: url,\n\n\n                      body: {\n\n\n                        client_id: \nxxxxxxxxxxx\n, // Your Auth0 Client ID\n\n\n                        access_token: data.accessToken.toString(),\n\n\n                        connection: \nfacebook\n,\n\n\n                        scope: \nopenid\n\n\n                      },\n\n\n                      json: true,\n\n\n                      resolveWithFullResponse: true\n\n\n                    };\n\n\n                    return rp(options);\n\n\n                  }).then(res =\n {\n\n\n\n                    /*\n\n\n                     * Example response\n\n\n                     * {\n\n\n                     *   \nidToken\n: \neyJ0eXAiOiJKV1Qi\n...\n,\n\n\n                     *   \naccess_token\n: \nA9CvPwFojaBI\n...\n,\n\n\n                     *   \ntoken_type\n: \nbearer\n\n\n                     * }\n\n\n                     */\n\n\n\n                    alert(res.body.idToken);\n\n\n\n                    /*\n\n\n                     * Send Scaphold login mutation (shown below)\n\n\n                     */\n\n\n\n                  }).catch(err =\n {\n\n\n                    logger.error(err);\n\n\n                    throw httpError(403, err);\n\n\n                  });\n\n\n                )\n\n\n              }\n\n\n            }\n\n\n          }\n\n\n          onLogoutFinished={() =\n alert(\nlogout\n.\n)}\n/\n\n      \n/\nView\n\n    \n);\n\n  \n}\n\n\n}\n);\n\n\n\n\n\n\n\nGiven the \nidToken\n, here's the \nGraphQL mutation you can use to log your user in\n to \nScaphold\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n// GraphQL Mutation\n\nmutation LoginUserWithAuth0 ($input: LoginUserWithAuth0Input!) {\n  loginUserWithAuth0 (input: $input) {\n    user {\n      id\n      username\n      createdAt\n    }\n  }\n}\n\n// Variables\n\n{\n  \ninput\n: {\n    \nidToken\n: \neyJ0eXAiOiJKV1Qi...\n // idToken from above\n  }\n}\n\n\n\n\n\n\nOnce you've sent that request, the response should resemble this:\n\n\n\n\nAfter \nScaphold\n securely logs the user in with the \nidToken\n, we'll pass back the newly generated \nidToken\n that you'll need to \nadd to your Authorization header\n for future requests.\nThat way, Scaphold will be able to authenticate you to make future requests through Scaphold, and it will also provide us the capability to work on that user's behalf to access the OAuth provider's resources.\nIn this case, we could authorize you to access their Facebook friends and their public profile information.\n\n\n\n\nIn addition, if you've logged in already and you make the same request again but with a new OAuth provider (i.e. Google), Scaphold will \nlink your two accounts together\n, since we know the requests being made belong to the same user.\n\n\nIn a similar fashion to the Facebook work flow from earlier, you'll likely use a \nclient SDK for Google sign-in\n. Upon logging in, you'll receive an access token and again verify it with the OAuth provider like so:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nGoogleSignin.signIn().then((user) =\n {\n  /*\n   * Send Access Token to Scaphold (shown below)\n   */\n  const options = {\n    method: \nPOST\n,\n    uri: url,\n    body: {\n      client_id: \nxxxxxxxxxxx\n, // Your Auth0 Client ID\n      access_token: user.accessToken,\n      connection: \ngoogle_oauth2\n,\n      scope: \nopenid\n\n    },\n    json: true,\n    resolveWithFullResponse: true\n  };\n  return rp(options);\n}).then(res =\n {\n  alert(res.body.idToken);\n\n  /*\n   * Send Scaphold login mutation (like earlier above)\n   */\n\n}).catch((err) =\n {\n  console.log(\nWRONG SIGNIN\n, err);\n}).done();\n\n\n\n\n\n\nWith this \nidToken\n, you'll \nsend a GraphQL request to Scaphold the same way as earlier\n.\n\n\nCongratulations! Now, you'll have access to both Facebook and Google information using your users' Facebook and Google account credentials. Thanks for checking this out, and check out our \ncommunity page\n for more tutorials on simple ways to get started with GraphQL!\n\n\n\n    \n\n    \nBrought to you by \nScaphold.io", 
            "title": "Add Social Auth"
        }, 
        {
            "location": "/tutorials/adding-social-auth/#how-to-integrate-oauth-with-scapholds-graphql-platform", 
            "text": "Hi GraphQL-Lovers!  Social authentication has been a hot topic for developers and users alike. There are many guides on how to implement it for traditional REST-based APIs, so here's one for the good guys.  Why social authentication? It all starts with the users. Most people have online social accounts on Facebook, Twitter, Google, and more. So they're thinking,   \u201cI'll check out your app if I can just log in with my existing Facebook or Twitter account.\u201d   The benefits are two-fold.    Users  are excited to get to remember one less account name and password. Hooray!    Developers  gets more content from these social authentication providers immediately upon log in, like emails, profile pictures, friends, etc\u2026    Here's how it works at a high level:   Source:  https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2    User must grant the application permission to access secured resources from an OAuth provider (i.e. Facebook, Google, etc).    After the user successfully grants the application access, the OAuth provider generates a user access token and passes it back to the application.    The application sends this user access token to the OAuth provider along with its own identity in order to authenticate.    Upon successful authentication, the OAuth provider grants authorization and returns an app access token.    Now that authorization is completed, the application may use the app access token for authentication to fetch authorized resources from the OAuth provider.    App access token is verified and the requested OAuth provider's resources are sent back to the application.", 
            "title": "How to integrate OAuth with Scaphold's GraphQL platform."
        }, 
        {
            "location": "/tutorials/adding-social-auth/#this-isnt-easy", 
            "text": "To do this yourself, you will have to perform the same workflow for every OAuth provider you wish to authenticate with. The best tool that we've found to help manage all these connections is  Auth0 . We'll be using this tool for the GraphQL walkthrough to help us set up OAuth.  Today, we'll explore two of the most popular social providers:   Facebook  and  Google .   Here's the agenda:    Create an Auth0 account.    Configure Facebook and Google connections.    Use Auth0 account keys to configure an Auth0 integration on  Scaphold .    Obtain access token from Facebook client SDK, exchange it for an ID token, and send GraphQL request to authenticate.    Store JSON Web Token (JWT) as Authorization header in HTTP requests.    Once logged in, send another GraphQL request with a Google ID token to link both social authentication credentials.    Voil\u00e1!    Let's start by  creating a free Auth0 account .  This will help you manage your app credentials like client IDs and secrets for your OAuth providers. By connecting your apps on your social accounts like Facebook, Google, and Twitter, you'll then have the correct account credentials to utilize these services for your authentication flow.   For more information on configuring your social connections on Auth0, check out these guides:  Facebook  /  Google  Once you've tested out your connections to see that they work,  save your Auth0 Domain, Client ID, and Client Secret .   Next,  configure Auth0 in  Scaphold  from the Integrations Portal to include the OAuth providers that you plan to use for your app. This will enable a new mutation in your schema called  loginUserWithAuth0  which you can use to log in users with connected OAuth providers.   In your client app, you'll likely be using a client SDK to handle user login. For instance, you can use the  Facebook SDK for React Native  to ask your users to log in with their existing Facebook accounts. Your app will redirect them to a Facebook sign-in page and once this succeeds, you'll receive an  access token  that you'll verify with your OAuth provider, and then the corresponding  idToken  will be sent to  Scaphold .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71 const   FBSDK   =   require ( react-native-fbsdk );  const   rp   =   require ( request-promise );  const   { \n   LoginButton, \n   AccessToken  }   =   FBSDK ;  var   Login   =   React . createClass ( { \n   render :   function ()   { \n     return   ( \n       View \n         LoginButton \n           publishPermissions = { [ publish_actions ] } \n           onLoginFinished = { \n             (error,   result)   =   { \n               if   (error)   { \n                 alert( login   has   error :    + result.error);                } else if (result.isCancelled) {                  alert( login   is   cancelled . );                } else {                  AccessToken.getCurrentAccessToken().then(                    (data) =  {                      /*                       * Use Access Token to retrieve Auth0 ID Token                       */                      const options = {                        method:  POST ,                        uri: url,                        body: {                          client_id:  xxxxxxxxxxx , // Your Auth0 Client ID                          access_token: data.accessToken.toString(),                          connection:  facebook ,                          scope:  openid                        },                        json: true,                        resolveWithFullResponse: true                      };                      return rp(options);                    }).then(res =  {                      /*                       * Example response                       * {                       *    idToken :  eyJ0eXAiOiJKV1Qi ... ,                       *    access_token :  A9CvPwFojaBI ... ,                       *    token_type :  bearer                       * }                       */                      alert(res.body.idToken);                      /*                       * Send Scaphold login mutation (shown below)                       */                    }).catch(err =  {                      logger.error(err);                      throw httpError(403, err);                    });                  )                }              }            }            onLogoutFinished={() =  alert( logout . )} / \n       / View \n     ); \n   }  } );    Given the  idToken , here's the  GraphQL mutation you can use to log your user in  to  Scaphold :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 // GraphQL Mutation\n\nmutation LoginUserWithAuth0 ($input: LoginUserWithAuth0Input!) {\n  loginUserWithAuth0 (input: $input) {\n    user {\n      id\n      username\n      createdAt\n    }\n  }\n}\n\n// Variables\n\n{\n   input : {\n     idToken :  eyJ0eXAiOiJKV1Qi...  // idToken from above\n  }\n}   Once you've sent that request, the response should resemble this:   After  Scaphold  securely logs the user in with the  idToken , we'll pass back the newly generated  idToken  that you'll need to  add to your Authorization header  for future requests.\nThat way, Scaphold will be able to authenticate you to make future requests through Scaphold, and it will also provide us the capability to work on that user's behalf to access the OAuth provider's resources.\nIn this case, we could authorize you to access their Facebook friends and their public profile information.   In addition, if you've logged in already and you make the same request again but with a new OAuth provider (i.e. Google), Scaphold will  link your two accounts together , since we know the requests being made belong to the same user.  In a similar fashion to the Facebook work flow from earlier, you'll likely use a  client SDK for Google sign-in . Upon logging in, you'll receive an access token and again verify it with the OAuth provider like so:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 GoogleSignin.signIn().then((user) =  {\n  /*\n   * Send Access Token to Scaphold (shown below)\n   */\n  const options = {\n    method:  POST ,\n    uri: url,\n    body: {\n      client_id:  xxxxxxxxxxx , // Your Auth0 Client ID\n      access_token: user.accessToken,\n      connection:  google_oauth2 ,\n      scope:  openid \n    },\n    json: true,\n    resolveWithFullResponse: true\n  };\n  return rp(options);\n}).then(res =  {\n  alert(res.body.idToken);\n\n  /*\n   * Send Scaphold login mutation (like earlier above)\n   */\n\n}).catch((err) =  {\n  console.log( WRONG SIGNIN , err);\n}).done();   With this  idToken , you'll  send a GraphQL request to Scaphold the same way as earlier .  Congratulations! Now, you'll have access to both Facebook and Google information using your users' Facebook and Google account credentials. Thanks for checking this out, and check out our  community page  for more tutorials on simple ways to get started with GraphQL!  \n     \n     Brought to you by  Scaphold.io", 
            "title": "This isn't easy!"
        }, 
        {
            "location": "/errors/", 
            "text": "Errors\n\n\n\n\nA typical Scaphold response\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ntype ScapholdResult {\n    data: any\n    errors: [ScapholdError]\n}\n\ntype ScapholdError {\n    message: string!\n    code: ErrorCode\n    param: string\n}\n\n\n\n\n\n\n\nErrors from the Scaphold API will be returned as a list under the `errors` attribute at the root of the response.\nI.E. Scaphold responses adhere to the ScapholdResult type.\n\n\n\n\n\n\n\n\n\n\nError Code\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n200\n\n\nOK -- Everything is working as expected\n\n\n\n\n\n\n400\n\n\nBad Request -- There was an error in your request.\n\n\n\n\n\n\n401\n\n\nUnauthorized -- Your API token is wrong or missing\n\n\n\n\n\n\n402\n\n\nPayment Required -- You have exceeded the free pricing teir. Please input a payment option via the Account page.\n\n\n\n\n\n\n403\n\n\nForbidden -- You have a valid API token but you do not have permission to this page.\n\n\n\n\n\n\n404\n\n\nNot Found -- The specified resource could not be found.\n\n\n\n\n\n\n429\n\n\nToo Many Requests -- You have approached the 60 req/s limit. Please try to spread out your requests more evenly.\n\n\n\n\n\n\n440\n\n\nLogin Failure -- We either couldn't find a user with that email or your password was incorrect.\n\n\n\n\n\n\n441\n\n\nRegistration Failure -- Invalid registration information. E.G. a user with that username already exists.\n\n\n\n\n\n\n500\n\n\nInternal Server Error -- We had a problem with our server. Please contact us via slack or try again later.\n\n\n\n\n\n\n503\n\n\nService Unavailable -- We're temporarially offline for maintanance. Happens very rarely.", 
            "title": "Errors"
        }, 
        {
            "location": "/errors/#errors", 
            "text": "A typical Scaphold response    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 type ScapholdResult {\n    data: any\n    errors: [ScapholdError]\n}\n\ntype ScapholdError {\n    message: string!\n    code: ErrorCode\n    param: string\n}   \nErrors from the Scaphold API will be returned as a list under the `errors` attribute at the root of the response.\nI.E. Scaphold responses adhere to the ScapholdResult type.     Error Code  Meaning      200  OK -- Everything is working as expected    400  Bad Request -- There was an error in your request.    401  Unauthorized -- Your API token is wrong or missing    402  Payment Required -- You have exceeded the free pricing teir. Please input a payment option via the Account page.    403  Forbidden -- You have a valid API token but you do not have permission to this page.    404  Not Found -- The specified resource could not be found.    429  Too Many Requests -- You have approached the 60 req/s limit. Please try to spread out your requests more evenly.    440  Login Failure -- We either couldn't find a user with that email or your password was incorrect.    441  Registration Failure -- Invalid registration information. E.G. a user with that username already exists.    500  Internal Server Error -- We had a problem with our server. Please contact us via slack or try again later.    503  Service Unavailable -- We're temporarially offline for maintanance. Happens very rarely.", 
            "title": "Errors"
        }, 
        {
            "location": "/changelog/", 
            "text": "Changelog\n\n\nJanuary 9, 2017\n\n\n\n\n\n\nScaphold Community Page\n! Find all the resources you need to launch a production app with GraphQL.\n\n\n\n\n\n\nBug fixes:\n\n\n\n\nSubscriptions filter with ID now accepts opaque unique ID properly\n\n\n\n\n\n\n\n\nJanuary 6, 2017\n\n\n\n\n\n\nCustom Logic\n: Use Scaphold's powerful webhook system to define custom business logic for your apps.\n\n\n\n\n\n\nAdded enums as values to \norderBy\n arguments on connections\n\n\n\n\n\n\nDecember 28, 2016\n\n\n\n\nExtended ordering functionality on a connection to order by an enum field\n\n\n\n\nDecember 26, 2016\n\n\n\n\n\n\nNew landing page\n!\n\n\n\n\n\n\nUser authentication\n:\n\n\n\n\nReset password\n\n\nForgot password\n\n\n\n\n\n\n\n\nBetter error handling:\n\n\n\n\nJSON syntax errors in Query Variables (no need to input empty object literal anymore)\n\n\nAccessing apps that don't exist or belong to you won't hang on loading page anymore\n\n\n\n\n\n\n\n\nUpdated \nreferral email\n!\n\n\n\n\n\n\nDateTime input form in Explorer page\n\n\n\n\n\n\nDecember 7, 2016\n\n\n\n\n\n\nMultiple Regions\n: We're launched to two regions now - US West (Oregon) and EU West (Ireland).\nPlease message us if you have a need for a new data center in your region!\n\n\n\n\n\n\nSuper Tokens\n: Create a new super token with a click of a button. Use this for administrative tasks.\n\n\n\n\n\n\nToken Expiration\n: Configure the expiration time of your JWT tokens for your users.", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#january-9-2017", 
            "text": "Scaphold Community Page ! Find all the resources you need to launch a production app with GraphQL.    Bug fixes:   Subscriptions filter with ID now accepts opaque unique ID properly", 
            "title": "January 9, 2017"
        }, 
        {
            "location": "/changelog/#january-6-2017", 
            "text": "Custom Logic : Use Scaphold's powerful webhook system to define custom business logic for your apps.    Added enums as values to  orderBy  arguments on connections", 
            "title": "January 6, 2017"
        }, 
        {
            "location": "/changelog/#december-28-2016", 
            "text": "Extended ordering functionality on a connection to order by an enum field", 
            "title": "December 28, 2016"
        }, 
        {
            "location": "/changelog/#december-26-2016", 
            "text": "New landing page !    User authentication :   Reset password  Forgot password     Better error handling:   JSON syntax errors in Query Variables (no need to input empty object literal anymore)  Accessing apps that don't exist or belong to you won't hang on loading page anymore     Updated  referral email !    DateTime input form in Explorer page", 
            "title": "December 26, 2016"
        }, 
        {
            "location": "/changelog/#december-7-2016", 
            "text": "Multiple Regions : We're launched to two regions now - US West (Oregon) and EU West (Ireland).\nPlease message us if you have a need for a new data center in your region!    Super Tokens : Create a new super token with a click of a button. Use this for administrative tasks.    Token Expiration : Configure the expiration time of your JWT tokens for your users.", 
            "title": "December 7, 2016"
        }, 
        {
            "location": "/faq/", 
            "text": "FAQ\n\n\nCan't find what you're looking for? Contact us on \nSlack\n!\n\n\nWhat can I build?\n\n\nWhether you're building a mobile or web app, we've got you covered. Scaphold will help you through every level of the development process. Use our schema designer to structure your data, GraphiQL to prototype your queries and export them directly into your client applications, monitor your application in our dashboard, and integrate popular services to extend your API.\n\n\nCan I trust Scaphold when a service like Parse shutdown?\n\n\nYES! We are Ycombinator backed company and are going strong! To help ease your mind, it is important to note that Facebook shut down Parse because it no longer fit in with their core strategy. There is a still a need for powerful BaaS products and we are here to bring you one.\n\n\nIn the extremely unlikely event that we do shut down then you still don't need to worry! GraphQL is a 100% open spec and you have the freedom to build a GraphQL API just like the ones we expose to you! You might lose some of the bells and whistles such as our seamless integrations but your business will survive and your client application code will remain the same!\n\n\nHow do we compare with other BaaS products?\n\n\nWe think GraphQL is the best way to build apps. It's that simple. There are other existing services like Firebase and Kinvey but they suffer from the same problems that have been plaguing BaaS solutions for years. This means vendor lock-in, complicated REST APIs, limited SDKs, and lack of flexibility. Scaphold turns this around and presents you with a standardized, extensible, and flexible GraphQL backend that can fit all kinds of application needs. Our GraphQL API releases you from vendor lock-in, provides you with API that anyone can understand, exposes a richer query language, and allows you to extend your APIs functionality with our many integrations. On top of all of this, our pricing model is the best in the industry so you can squeeze as much out of every dollar as possible!\n\n\nWhat is our SLA?\n\n\nAlthough we do not currently expose a standard SLA, our services run on a distributed cluster that was designed to prevent a single point of failure from bringing down our services. In the unlikely event that our services do go down for a time, we have systems working around the clock that will let us know so we can quickly fix the problem. You can trust that we are doing everything we can to provide the best possible experience for our clients and will continually push for 6 nines.\n\n\nWho is using GraphQL?\n\n\nThe biggest proponent of GraphQL by far is Facebook. They designed GraphQL to solve many of the problems that they experienced when building many of their web and mobile products and they are using the technology to power more and more of their products. It's not just Facebook however! Companies like Twitter, Meteor, and Kadira are also using GraphQL heavily and the feedback has been overwhelmingly positive.\n\n\nHow do I get support?\n\n\nIt's our goal to make your life as a developer as easy as possible and that means haveing great customer support. The best way to get support is either using the Intercom chat bubble on this page or to join us on Slack at \nScaphold Slack\n. Please feel free to contact us at any hour of the day and we will respond as soon as possible!\n\n\nResources\n\n\n\n\n\n\nFacebook's \nGraphQL.org\n\n\n\n\n\n\nKadira's \nLearnGraphQL.com\n\n\n\n\n\n\nApollo's \nGraphQL.com\n\n\n\n\n\n\nThe Fastest Way to Get Started\n\n\n\n\n\n\nGraphQL vs. REST\n\n\n\n\n\n\nState of GraphQL\n\n\n\n\n\n\nClay Allsopp's \nGraphQLHub.com\n\n\n\n\n\n\nOfficial GraphQL Slack\n\n\n\n\n\n\nScaphold Slack\n\n\n\n\n\n\nOther Community Sites\n\n\n\n\n\n\nUnofficial List of Resources\n\n\n\n\n\n\nIf you have other additions to this list that you'd like to add, feel free to contact us at our \nSlack channel\n. Message either @vince or @michael.\n\n\nLook Out For...\n\n\n\n\nMore public GraphQL APIs\n\n\nRelay 2.0!\n\n\nGraphQL Subscriptions updates\n\n\nOpen source tooling released by companies that are using it internally\n\n\nMore mobile support", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#faq", 
            "text": "Can't find what you're looking for? Contact us on  Slack !", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#what-can-i-build", 
            "text": "Whether you're building a mobile or web app, we've got you covered. Scaphold will help you through every level of the development process. Use our schema designer to structure your data, GraphiQL to prototype your queries and export them directly into your client applications, monitor your application in our dashboard, and integrate popular services to extend your API.", 
            "title": "What can I build?"
        }, 
        {
            "location": "/faq/#can-i-trust-scaphold-when-a-service-like-parse-shutdown", 
            "text": "YES! We are Ycombinator backed company and are going strong! To help ease your mind, it is important to note that Facebook shut down Parse because it no longer fit in with their core strategy. There is a still a need for powerful BaaS products and we are here to bring you one.  In the extremely unlikely event that we do shut down then you still don't need to worry! GraphQL is a 100% open spec and you have the freedom to build a GraphQL API just like the ones we expose to you! You might lose some of the bells and whistles such as our seamless integrations but your business will survive and your client application code will remain the same!", 
            "title": "Can I trust Scaphold when a service like Parse shutdown?"
        }, 
        {
            "location": "/faq/#how-do-we-compare-with-other-baas-products", 
            "text": "We think GraphQL is the best way to build apps. It's that simple. There are other existing services like Firebase and Kinvey but they suffer from the same problems that have been plaguing BaaS solutions for years. This means vendor lock-in, complicated REST APIs, limited SDKs, and lack of flexibility. Scaphold turns this around and presents you with a standardized, extensible, and flexible GraphQL backend that can fit all kinds of application needs. Our GraphQL API releases you from vendor lock-in, provides you with API that anyone can understand, exposes a richer query language, and allows you to extend your APIs functionality with our many integrations. On top of all of this, our pricing model is the best in the industry so you can squeeze as much out of every dollar as possible!", 
            "title": "How do we compare with other BaaS products?"
        }, 
        {
            "location": "/faq/#what-is-our-sla", 
            "text": "Although we do not currently expose a standard SLA, our services run on a distributed cluster that was designed to prevent a single point of failure from bringing down our services. In the unlikely event that our services do go down for a time, we have systems working around the clock that will let us know so we can quickly fix the problem. You can trust that we are doing everything we can to provide the best possible experience for our clients and will continually push for 6 nines.", 
            "title": "What is our SLA?"
        }, 
        {
            "location": "/faq/#who-is-using-graphql", 
            "text": "The biggest proponent of GraphQL by far is Facebook. They designed GraphQL to solve many of the problems that they experienced when building many of their web and mobile products and they are using the technology to power more and more of their products. It's not just Facebook however! Companies like Twitter, Meteor, and Kadira are also using GraphQL heavily and the feedback has been overwhelmingly positive.", 
            "title": "Who is using GraphQL?"
        }, 
        {
            "location": "/faq/#how-do-i-get-support", 
            "text": "It's our goal to make your life as a developer as easy as possible and that means haveing great customer support. The best way to get support is either using the Intercom chat bubble on this page or to join us on Slack at  Scaphold Slack . Please feel free to contact us at any hour of the day and we will respond as soon as possible!", 
            "title": "How do I get support?"
        }, 
        {
            "location": "/faq/#resources", 
            "text": "Facebook's  GraphQL.org    Kadira's  LearnGraphQL.com    Apollo's  GraphQL.com    The Fastest Way to Get Started    GraphQL vs. REST    State of GraphQL    Clay Allsopp's  GraphQLHub.com    Official GraphQL Slack    Scaphold Slack    Other Community Sites    Unofficial List of Resources    If you have other additions to this list that you'd like to add, feel free to contact us at our  Slack channel . Message either @vince or @michael.", 
            "title": "Resources"
        }, 
        {
            "location": "/faq/#look-out-for", 
            "text": "More public GraphQL APIs  Relay 2.0!  GraphQL Subscriptions updates  Open source tooling released by companies that are using it internally  More mobile support", 
            "title": "Look Out For..."
        }
    ]
}